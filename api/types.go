// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/wepala/square-go/api/core"
)

// Represents an additional recipient (other than the merchant) receiving a portion of this tender.
type AdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of this tender.
	LocationId string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The unique ID for the RETIRED `AdditionalRecipientReceivable` object. This field should be empty for any `AdditionalRecipient` objects created after the retirement.
	ReceivableId *string `json:"receivable_id,omitempty" url:"receivable_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a postal address in a country.
// For more information, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
type Address struct {
	// The first line of the address.
	//
	// Fields that start with `address_line` provide the address's most specific
	// details, like street number, street name, and building name. They do _not_
	// provide less specific details like city, state/province, or country (these
	// details are provided in other fields).
	AddressLine1 *string `json:"address_line_1,omitempty" url:"address_line_1,omitempty"`
	// The second line of the address, if any.
	AddressLine2 *string `json:"address_line_2,omitempty" url:"address_line_2,omitempty"`
	// The third line of the address, if any.
	AddressLine3 *string `json:"address_line_3,omitempty" url:"address_line_3,omitempty"`
	// The city or town of the address. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	Locality *string `json:"locality,omitempty" url:"locality,omitempty"`
	// A civil region within the address's `locality`, if any.
	Sublocality *string `json:"sublocality,omitempty" url:"sublocality,omitempty"`
	// A civil region within the address's `sublocality`, if any.
	Sublocality2 *string `json:"sublocality_2,omitempty" url:"sublocality_2,omitempty"`
	// A civil region within the address's `sublocality_2`, if any.
	Sublocality3 *string `json:"sublocality_3,omitempty" url:"sublocality_3,omitempty"`
	// A civil entity within the address's country. In the US, this
	// is the state. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	AdministrativeDistrictLevel1 *string `json:"administrative_district_level_1,omitempty" url:"administrative_district_level_1,omitempty"`
	// A civil entity within the address's `administrative_district_level_1`.
	// In the US, this is the county.
	AdministrativeDistrictLevel2 *string `json:"administrative_district_level_2,omitempty" url:"administrative_district_level_2,omitempty"`
	// A civil entity within the address's `administrative_district_level_2`,
	// if any.
	AdministrativeDistrictLevel3 *string `json:"administrative_district_level_3,omitempty" url:"administrative_district_level_3,omitempty"`
	// The address's postal code. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	PostalCode *string  `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	Country    *Country `json:"country,omitempty" url:"country,omitempty"`
	// Optional first name when it's representing recipient.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// Optional last name when it's representing recipient.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Indicates the country associated with another entity, such as a business.
// Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
type Country string

const (
	CountryZz Country = "ZZ"
	CountryAd Country = "AD"
	CountryAe Country = "AE"
	CountryAf Country = "AF"
	CountryAg Country = "AG"
	CountryAi Country = "AI"
	CountryAl Country = "AL"
	CountryAm Country = "AM"
	CountryAo Country = "AO"
	CountryAq Country = "AQ"
	CountryAr Country = "AR"
	CountryAs Country = "AS"
	CountryAt Country = "AT"
	CountryAu Country = "AU"
	CountryAw Country = "AW"
	CountryAx Country = "AX"
	CountryAz Country = "AZ"
	CountryBa Country = "BA"
	CountryBb Country = "BB"
	CountryBd Country = "BD"
	CountryBe Country = "BE"
	CountryBf Country = "BF"
	CountryBg Country = "BG"
	CountryBh Country = "BH"
	CountryBi Country = "BI"
	CountryBj Country = "BJ"
	CountryBl Country = "BL"
	CountryBm Country = "BM"
	CountryBn Country = "BN"
	CountryBo Country = "BO"
	CountryBq Country = "BQ"
	CountryBr Country = "BR"
	CountryBs Country = "BS"
	CountryBt Country = "BT"
	CountryBv Country = "BV"
	CountryBw Country = "BW"
	CountryBy Country = "BY"
	CountryBz Country = "BZ"
	CountryCa Country = "CA"
	CountryCc Country = "CC"
	CountryCd Country = "CD"
	CountryCf Country = "CF"
	CountryCg Country = "CG"
	CountryCh Country = "CH"
	CountryCi Country = "CI"
	CountryCk Country = "CK"
	CountryCl Country = "CL"
	CountryCm Country = "CM"
	CountryCn Country = "CN"
	CountryCo Country = "CO"
	CountryCr Country = "CR"
	CountryCu Country = "CU"
	CountryCv Country = "CV"
	CountryCw Country = "CW"
	CountryCx Country = "CX"
	CountryCy Country = "CY"
	CountryCz Country = "CZ"
	CountryDe Country = "DE"
	CountryDj Country = "DJ"
	CountryDk Country = "DK"
	CountryDm Country = "DM"
	CountryDo Country = "DO"
	CountryDz Country = "DZ"
	CountryEc Country = "EC"
	CountryEe Country = "EE"
	CountryEg Country = "EG"
	CountryEh Country = "EH"
	CountryEr Country = "ER"
	CountryEs Country = "ES"
	CountryEt Country = "ET"
	CountryFi Country = "FI"
	CountryFj Country = "FJ"
	CountryFk Country = "FK"
	CountryFm Country = "FM"
	CountryFo Country = "FO"
	CountryFr Country = "FR"
	CountryGa Country = "GA"
	CountryGb Country = "GB"
	CountryGd Country = "GD"
	CountryGe Country = "GE"
	CountryGf Country = "GF"
	CountryGg Country = "GG"
	CountryGh Country = "GH"
	CountryGi Country = "GI"
	CountryGl Country = "GL"
	CountryGm Country = "GM"
	CountryGn Country = "GN"
	CountryGp Country = "GP"
	CountryGq Country = "GQ"
	CountryGr Country = "GR"
	CountryGs Country = "GS"
	CountryGt Country = "GT"
	CountryGu Country = "GU"
	CountryGw Country = "GW"
	CountryGy Country = "GY"
	CountryHk Country = "HK"
	CountryHm Country = "HM"
	CountryHn Country = "HN"
	CountryHr Country = "HR"
	CountryHt Country = "HT"
	CountryHu Country = "HU"
	CountryId Country = "ID"
	CountryIe Country = "IE"
	CountryIl Country = "IL"
	CountryIm Country = "IM"
	CountryIn Country = "IN"
	CountryIo Country = "IO"
	CountryIq Country = "IQ"
	CountryIr Country = "IR"
	CountryIs Country = "IS"
	CountryIt Country = "IT"
	CountryJe Country = "JE"
	CountryJm Country = "JM"
	CountryJo Country = "JO"
	CountryJp Country = "JP"
	CountryKe Country = "KE"
	CountryKg Country = "KG"
	CountryKh Country = "KH"
	CountryKi Country = "KI"
	CountryKm Country = "KM"
	CountryKn Country = "KN"
	CountryKp Country = "KP"
	CountryKr Country = "KR"
	CountryKw Country = "KW"
	CountryKy Country = "KY"
	CountryKz Country = "KZ"
	CountryLa Country = "LA"
	CountryLb Country = "LB"
	CountryLc Country = "LC"
	CountryLi Country = "LI"
	CountryLk Country = "LK"
	CountryLr Country = "LR"
	CountryLs Country = "LS"
	CountryLt Country = "LT"
	CountryLu Country = "LU"
	CountryLv Country = "LV"
	CountryLy Country = "LY"
	CountryMa Country = "MA"
	CountryMc Country = "MC"
	CountryMd Country = "MD"
	CountryMe Country = "ME"
	CountryMf Country = "MF"
	CountryMg Country = "MG"
	CountryMh Country = "MH"
	CountryMk Country = "MK"
	CountryMl Country = "ML"
	CountryMm Country = "MM"
	CountryMn Country = "MN"
	CountryMo Country = "MO"
	CountryMp Country = "MP"
	CountryMq Country = "MQ"
	CountryMr Country = "MR"
	CountryMs Country = "MS"
	CountryMt Country = "MT"
	CountryMu Country = "MU"
	CountryMv Country = "MV"
	CountryMw Country = "MW"
	CountryMx Country = "MX"
	CountryMy Country = "MY"
	CountryMz Country = "MZ"
	CountryNa Country = "NA"
	CountryNc Country = "NC"
	CountryNe Country = "NE"
	CountryNf Country = "NF"
	CountryNg Country = "NG"
	CountryNi Country = "NI"
	CountryNl Country = "NL"
	CountryNo Country = "NO"
	CountryNp Country = "NP"
	CountryNr Country = "NR"
	CountryNu Country = "NU"
	CountryNz Country = "NZ"
	CountryOm Country = "OM"
	CountryPa Country = "PA"
	CountryPe Country = "PE"
	CountryPf Country = "PF"
	CountryPg Country = "PG"
	CountryPh Country = "PH"
	CountryPk Country = "PK"
	CountryPl Country = "PL"
	CountryPm Country = "PM"
	CountryPn Country = "PN"
	CountryPr Country = "PR"
	CountryPs Country = "PS"
	CountryPt Country = "PT"
	CountryPw Country = "PW"
	CountryPy Country = "PY"
	CountryQa Country = "QA"
	CountryRe Country = "RE"
	CountryRo Country = "RO"
	CountryRs Country = "RS"
	CountryRu Country = "RU"
	CountryRw Country = "RW"
	CountrySa Country = "SA"
	CountrySb Country = "SB"
	CountrySc Country = "SC"
	CountrySd Country = "SD"
	CountrySe Country = "SE"
	CountrySg Country = "SG"
	CountrySh Country = "SH"
	CountrySi Country = "SI"
	CountrySj Country = "SJ"
	CountrySk Country = "SK"
	CountrySl Country = "SL"
	CountrySm Country = "SM"
	CountrySn Country = "SN"
	CountrySo Country = "SO"
	CountrySr Country = "SR"
	CountrySs Country = "SS"
	CountrySt Country = "ST"
	CountrySv Country = "SV"
	CountrySx Country = "SX"
	CountrySy Country = "SY"
	CountrySz Country = "SZ"
	CountryTc Country = "TC"
	CountryTd Country = "TD"
	CountryTf Country = "TF"
	CountryTg Country = "TG"
	CountryTh Country = "TH"
	CountryTj Country = "TJ"
	CountryTk Country = "TK"
	CountryTl Country = "TL"
	CountryTm Country = "TM"
	CountryTn Country = "TN"
	CountryTo Country = "TO"
	CountryTr Country = "TR"
	CountryTt Country = "TT"
	CountryTv Country = "TV"
	CountryTw Country = "TW"
	CountryTz Country = "TZ"
	CountryUa Country = "UA"
	CountryUg Country = "UG"
	CountryUm Country = "UM"
	CountryUs Country = "US"
	CountryUy Country = "UY"
	CountryUz Country = "UZ"
	CountryVa Country = "VA"
	CountryVc Country = "VC"
	CountryVe Country = "VE"
	CountryVg Country = "VG"
	CountryVi Country = "VI"
	CountryVn Country = "VN"
	CountryVu Country = "VU"
	CountryWf Country = "WF"
	CountryWs Country = "WS"
	CountryYe Country = "YE"
	CountryYt Country = "YT"
	CountryZa Country = "ZA"
	CountryZm Country = "ZM"
	CountryZw Country = "ZW"
)

func NewCountryFromString(s string) (Country, error) {
	switch s {
	case "ZZ":
		return CountryZz, nil
	case "AD":
		return CountryAd, nil
	case "AE":
		return CountryAe, nil
	case "AF":
		return CountryAf, nil
	case "AG":
		return CountryAg, nil
	case "AI":
		return CountryAi, nil
	case "AL":
		return CountryAl, nil
	case "AM":
		return CountryAm, nil
	case "AO":
		return CountryAo, nil
	case "AQ":
		return CountryAq, nil
	case "AR":
		return CountryAr, nil
	case "AS":
		return CountryAs, nil
	case "AT":
		return CountryAt, nil
	case "AU":
		return CountryAu, nil
	case "AW":
		return CountryAw, nil
	case "AX":
		return CountryAx, nil
	case "AZ":
		return CountryAz, nil
	case "BA":
		return CountryBa, nil
	case "BB":
		return CountryBb, nil
	case "BD":
		return CountryBd, nil
	case "BE":
		return CountryBe, nil
	case "BF":
		return CountryBf, nil
	case "BG":
		return CountryBg, nil
	case "BH":
		return CountryBh, nil
	case "BI":
		return CountryBi, nil
	case "BJ":
		return CountryBj, nil
	case "BL":
		return CountryBl, nil
	case "BM":
		return CountryBm, nil
	case "BN":
		return CountryBn, nil
	case "BO":
		return CountryBo, nil
	case "BQ":
		return CountryBq, nil
	case "BR":
		return CountryBr, nil
	case "BS":
		return CountryBs, nil
	case "BT":
		return CountryBt, nil
	case "BV":
		return CountryBv, nil
	case "BW":
		return CountryBw, nil
	case "BY":
		return CountryBy, nil
	case "BZ":
		return CountryBz, nil
	case "CA":
		return CountryCa, nil
	case "CC":
		return CountryCc, nil
	case "CD":
		return CountryCd, nil
	case "CF":
		return CountryCf, nil
	case "CG":
		return CountryCg, nil
	case "CH":
		return CountryCh, nil
	case "CI":
		return CountryCi, nil
	case "CK":
		return CountryCk, nil
	case "CL":
		return CountryCl, nil
	case "CM":
		return CountryCm, nil
	case "CN":
		return CountryCn, nil
	case "CO":
		return CountryCo, nil
	case "CR":
		return CountryCr, nil
	case "CU":
		return CountryCu, nil
	case "CV":
		return CountryCv, nil
	case "CW":
		return CountryCw, nil
	case "CX":
		return CountryCx, nil
	case "CY":
		return CountryCy, nil
	case "CZ":
		return CountryCz, nil
	case "DE":
		return CountryDe, nil
	case "DJ":
		return CountryDj, nil
	case "DK":
		return CountryDk, nil
	case "DM":
		return CountryDm, nil
	case "DO":
		return CountryDo, nil
	case "DZ":
		return CountryDz, nil
	case "EC":
		return CountryEc, nil
	case "EE":
		return CountryEe, nil
	case "EG":
		return CountryEg, nil
	case "EH":
		return CountryEh, nil
	case "ER":
		return CountryEr, nil
	case "ES":
		return CountryEs, nil
	case "ET":
		return CountryEt, nil
	case "FI":
		return CountryFi, nil
	case "FJ":
		return CountryFj, nil
	case "FK":
		return CountryFk, nil
	case "FM":
		return CountryFm, nil
	case "FO":
		return CountryFo, nil
	case "FR":
		return CountryFr, nil
	case "GA":
		return CountryGa, nil
	case "GB":
		return CountryGb, nil
	case "GD":
		return CountryGd, nil
	case "GE":
		return CountryGe, nil
	case "GF":
		return CountryGf, nil
	case "GG":
		return CountryGg, nil
	case "GH":
		return CountryGh, nil
	case "GI":
		return CountryGi, nil
	case "GL":
		return CountryGl, nil
	case "GM":
		return CountryGm, nil
	case "GN":
		return CountryGn, nil
	case "GP":
		return CountryGp, nil
	case "GQ":
		return CountryGq, nil
	case "GR":
		return CountryGr, nil
	case "GS":
		return CountryGs, nil
	case "GT":
		return CountryGt, nil
	case "GU":
		return CountryGu, nil
	case "GW":
		return CountryGw, nil
	case "GY":
		return CountryGy, nil
	case "HK":
		return CountryHk, nil
	case "HM":
		return CountryHm, nil
	case "HN":
		return CountryHn, nil
	case "HR":
		return CountryHr, nil
	case "HT":
		return CountryHt, nil
	case "HU":
		return CountryHu, nil
	case "ID":
		return CountryId, nil
	case "IE":
		return CountryIe, nil
	case "IL":
		return CountryIl, nil
	case "IM":
		return CountryIm, nil
	case "IN":
		return CountryIn, nil
	case "IO":
		return CountryIo, nil
	case "IQ":
		return CountryIq, nil
	case "IR":
		return CountryIr, nil
	case "IS":
		return CountryIs, nil
	case "IT":
		return CountryIt, nil
	case "JE":
		return CountryJe, nil
	case "JM":
		return CountryJm, nil
	case "JO":
		return CountryJo, nil
	case "JP":
		return CountryJp, nil
	case "KE":
		return CountryKe, nil
	case "KG":
		return CountryKg, nil
	case "KH":
		return CountryKh, nil
	case "KI":
		return CountryKi, nil
	case "KM":
		return CountryKm, nil
	case "KN":
		return CountryKn, nil
	case "KP":
		return CountryKp, nil
	case "KR":
		return CountryKr, nil
	case "KW":
		return CountryKw, nil
	case "KY":
		return CountryKy, nil
	case "KZ":
		return CountryKz, nil
	case "LA":
		return CountryLa, nil
	case "LB":
		return CountryLb, nil
	case "LC":
		return CountryLc, nil
	case "LI":
		return CountryLi, nil
	case "LK":
		return CountryLk, nil
	case "LR":
		return CountryLr, nil
	case "LS":
		return CountryLs, nil
	case "LT":
		return CountryLt, nil
	case "LU":
		return CountryLu, nil
	case "LV":
		return CountryLv, nil
	case "LY":
		return CountryLy, nil
	case "MA":
		return CountryMa, nil
	case "MC":
		return CountryMc, nil
	case "MD":
		return CountryMd, nil
	case "ME":
		return CountryMe, nil
	case "MF":
		return CountryMf, nil
	case "MG":
		return CountryMg, nil
	case "MH":
		return CountryMh, nil
	case "MK":
		return CountryMk, nil
	case "ML":
		return CountryMl, nil
	case "MM":
		return CountryMm, nil
	case "MN":
		return CountryMn, nil
	case "MO":
		return CountryMo, nil
	case "MP":
		return CountryMp, nil
	case "MQ":
		return CountryMq, nil
	case "MR":
		return CountryMr, nil
	case "MS":
		return CountryMs, nil
	case "MT":
		return CountryMt, nil
	case "MU":
		return CountryMu, nil
	case "MV":
		return CountryMv, nil
	case "MW":
		return CountryMw, nil
	case "MX":
		return CountryMx, nil
	case "MY":
		return CountryMy, nil
	case "MZ":
		return CountryMz, nil
	case "NA":
		return CountryNa, nil
	case "NC":
		return CountryNc, nil
	case "NE":
		return CountryNe, nil
	case "NF":
		return CountryNf, nil
	case "NG":
		return CountryNg, nil
	case "NI":
		return CountryNi, nil
	case "NL":
		return CountryNl, nil
	case "NO":
		return CountryNo, nil
	case "NP":
		return CountryNp, nil
	case "NR":
		return CountryNr, nil
	case "NU":
		return CountryNu, nil
	case "NZ":
		return CountryNz, nil
	case "OM":
		return CountryOm, nil
	case "PA":
		return CountryPa, nil
	case "PE":
		return CountryPe, nil
	case "PF":
		return CountryPf, nil
	case "PG":
		return CountryPg, nil
	case "PH":
		return CountryPh, nil
	case "PK":
		return CountryPk, nil
	case "PL":
		return CountryPl, nil
	case "PM":
		return CountryPm, nil
	case "PN":
		return CountryPn, nil
	case "PR":
		return CountryPr, nil
	case "PS":
		return CountryPs, nil
	case "PT":
		return CountryPt, nil
	case "PW":
		return CountryPw, nil
	case "PY":
		return CountryPy, nil
	case "QA":
		return CountryQa, nil
	case "RE":
		return CountryRe, nil
	case "RO":
		return CountryRo, nil
	case "RS":
		return CountryRs, nil
	case "RU":
		return CountryRu, nil
	case "RW":
		return CountryRw, nil
	case "SA":
		return CountrySa, nil
	case "SB":
		return CountrySb, nil
	case "SC":
		return CountrySc, nil
	case "SD":
		return CountrySd, nil
	case "SE":
		return CountrySe, nil
	case "SG":
		return CountrySg, nil
	case "SH":
		return CountrySh, nil
	case "SI":
		return CountrySi, nil
	case "SJ":
		return CountrySj, nil
	case "SK":
		return CountrySk, nil
	case "SL":
		return CountrySl, nil
	case "SM":
		return CountrySm, nil
	case "SN":
		return CountrySn, nil
	case "SO":
		return CountrySo, nil
	case "SR":
		return CountrySr, nil
	case "SS":
		return CountrySs, nil
	case "ST":
		return CountrySt, nil
	case "SV":
		return CountrySv, nil
	case "SX":
		return CountrySx, nil
	case "SY":
		return CountrySy, nil
	case "SZ":
		return CountrySz, nil
	case "TC":
		return CountryTc, nil
	case "TD":
		return CountryTd, nil
	case "TF":
		return CountryTf, nil
	case "TG":
		return CountryTg, nil
	case "TH":
		return CountryTh, nil
	case "TJ":
		return CountryTj, nil
	case "TK":
		return CountryTk, nil
	case "TL":
		return CountryTl, nil
	case "TM":
		return CountryTm, nil
	case "TN":
		return CountryTn, nil
	case "TO":
		return CountryTo, nil
	case "TR":
		return CountryTr, nil
	case "TT":
		return CountryTt, nil
	case "TV":
		return CountryTv, nil
	case "TW":
		return CountryTw, nil
	case "TZ":
		return CountryTz, nil
	case "UA":
		return CountryUa, nil
	case "UG":
		return CountryUg, nil
	case "UM":
		return CountryUm, nil
	case "US":
		return CountryUs, nil
	case "UY":
		return CountryUy, nil
	case "UZ":
		return CountryUz, nil
	case "VA":
		return CountryVa, nil
	case "VC":
		return CountryVc, nil
	case "VE":
		return CountryVe, nil
	case "VG":
		return CountryVg, nil
	case "VI":
		return CountryVi, nil
	case "VN":
		return CountryVn, nil
	case "VU":
		return CountryVu, nil
	case "WF":
		return CountryWf, nil
	case "WS":
		return CountryWs, nil
	case "YE":
		return CountryYe, nil
	case "YT":
		return CountryYt, nil
	case "ZA":
		return CountryZa, nil
	case "ZM":
		return CountryZm, nil
	case "ZW":
		return CountryZw, nil
	}
	var t Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Country) Ptr() *Country {
	return &c
}

// Defines the fields that are included in the response body of
// a request to the `CreateOrder` endpoint.
//
// Either `errors` or `order` is present in a given response, but never both.
type CreateOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the associated currency for an amount of money. Values correspond
// to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
type Currency string

const (
	CurrencyUnknownCurrency Currency = "UNKNOWN_CURRENCY"
	CurrencyAed             Currency = "AED"
	CurrencyAfn             Currency = "AFN"
	CurrencyAll             Currency = "ALL"
	CurrencyAmd             Currency = "AMD"
	CurrencyAng             Currency = "ANG"
	CurrencyAoa             Currency = "AOA"
	CurrencyArs             Currency = "ARS"
	CurrencyAud             Currency = "AUD"
	CurrencyAwg             Currency = "AWG"
	CurrencyAzn             Currency = "AZN"
	CurrencyBam             Currency = "BAM"
	CurrencyBbd             Currency = "BBD"
	CurrencyBdt             Currency = "BDT"
	CurrencyBgn             Currency = "BGN"
	CurrencyBhd             Currency = "BHD"
	CurrencyBif             Currency = "BIF"
	CurrencyBmd             Currency = "BMD"
	CurrencyBnd             Currency = "BND"
	CurrencyBob             Currency = "BOB"
	CurrencyBov             Currency = "BOV"
	CurrencyBrl             Currency = "BRL"
	CurrencyBsd             Currency = "BSD"
	CurrencyBtn             Currency = "BTN"
	CurrencyBwp             Currency = "BWP"
	CurrencyByr             Currency = "BYR"
	CurrencyBzd             Currency = "BZD"
	CurrencyCad             Currency = "CAD"
	CurrencyCdf             Currency = "CDF"
	CurrencyChe             Currency = "CHE"
	CurrencyChf             Currency = "CHF"
	CurrencyChw             Currency = "CHW"
	CurrencyClf             Currency = "CLF"
	CurrencyClp             Currency = "CLP"
	CurrencyCny             Currency = "CNY"
	CurrencyCop             Currency = "COP"
	CurrencyCou             Currency = "COU"
	CurrencyCrc             Currency = "CRC"
	CurrencyCuc             Currency = "CUC"
	CurrencyCup             Currency = "CUP"
	CurrencyCve             Currency = "CVE"
	CurrencyCzk             Currency = "CZK"
	CurrencyDjf             Currency = "DJF"
	CurrencyDkk             Currency = "DKK"
	CurrencyDop             Currency = "DOP"
	CurrencyDzd             Currency = "DZD"
	CurrencyEgp             Currency = "EGP"
	CurrencyErn             Currency = "ERN"
	CurrencyEtb             Currency = "ETB"
	CurrencyEur             Currency = "EUR"
	CurrencyFjd             Currency = "FJD"
	CurrencyFkp             Currency = "FKP"
	CurrencyGbp             Currency = "GBP"
	CurrencyGel             Currency = "GEL"
	CurrencyGhs             Currency = "GHS"
	CurrencyGip             Currency = "GIP"
	CurrencyGmd             Currency = "GMD"
	CurrencyGnf             Currency = "GNF"
	CurrencyGtq             Currency = "GTQ"
	CurrencyGyd             Currency = "GYD"
	CurrencyHkd             Currency = "HKD"
	CurrencyHnl             Currency = "HNL"
	CurrencyHrk             Currency = "HRK"
	CurrencyHtg             Currency = "HTG"
	CurrencyHuf             Currency = "HUF"
	CurrencyIdr             Currency = "IDR"
	CurrencyIls             Currency = "ILS"
	CurrencyInr             Currency = "INR"
	CurrencyIqd             Currency = "IQD"
	CurrencyIrr             Currency = "IRR"
	CurrencyIsk             Currency = "ISK"
	CurrencyJmd             Currency = "JMD"
	CurrencyJod             Currency = "JOD"
	CurrencyJpy             Currency = "JPY"
	CurrencyKes             Currency = "KES"
	CurrencyKgs             Currency = "KGS"
	CurrencyKhr             Currency = "KHR"
	CurrencyKmf             Currency = "KMF"
	CurrencyKpw             Currency = "KPW"
	CurrencyKrw             Currency = "KRW"
	CurrencyKwd             Currency = "KWD"
	CurrencyKyd             Currency = "KYD"
	CurrencyKzt             Currency = "KZT"
	CurrencyLak             Currency = "LAK"
	CurrencyLbp             Currency = "LBP"
	CurrencyLkr             Currency = "LKR"
	CurrencyLrd             Currency = "LRD"
	CurrencyLsl             Currency = "LSL"
	CurrencyLtl             Currency = "LTL"
	CurrencyLvl             Currency = "LVL"
	CurrencyLyd             Currency = "LYD"
	CurrencyMad             Currency = "MAD"
	CurrencyMdl             Currency = "MDL"
	CurrencyMga             Currency = "MGA"
	CurrencyMkd             Currency = "MKD"
	CurrencyMmk             Currency = "MMK"
	CurrencyMnt             Currency = "MNT"
	CurrencyMop             Currency = "MOP"
	CurrencyMro             Currency = "MRO"
	CurrencyMur             Currency = "MUR"
	CurrencyMvr             Currency = "MVR"
	CurrencyMwk             Currency = "MWK"
	CurrencyMxn             Currency = "MXN"
	CurrencyMxv             Currency = "MXV"
	CurrencyMyr             Currency = "MYR"
	CurrencyMzn             Currency = "MZN"
	CurrencyNad             Currency = "NAD"
	CurrencyNgn             Currency = "NGN"
	CurrencyNio             Currency = "NIO"
	CurrencyNok             Currency = "NOK"
	CurrencyNpr             Currency = "NPR"
	CurrencyNzd             Currency = "NZD"
	CurrencyOmr             Currency = "OMR"
	CurrencyPab             Currency = "PAB"
	CurrencyPen             Currency = "PEN"
	CurrencyPgk             Currency = "PGK"
	CurrencyPhp             Currency = "PHP"
	CurrencyPkr             Currency = "PKR"
	CurrencyPln             Currency = "PLN"
	CurrencyPyg             Currency = "PYG"
	CurrencyQar             Currency = "QAR"
	CurrencyRon             Currency = "RON"
	CurrencyRsd             Currency = "RSD"
	CurrencyRub             Currency = "RUB"
	CurrencyRwf             Currency = "RWF"
	CurrencySar             Currency = "SAR"
	CurrencySbd             Currency = "SBD"
	CurrencyScr             Currency = "SCR"
	CurrencySdg             Currency = "SDG"
	CurrencySek             Currency = "SEK"
	CurrencySgd             Currency = "SGD"
	CurrencyShp             Currency = "SHP"
	CurrencySll             Currency = "SLL"
	CurrencySos             Currency = "SOS"
	CurrencySrd             Currency = "SRD"
	CurrencySsp             Currency = "SSP"
	CurrencyStd             Currency = "STD"
	CurrencySvc             Currency = "SVC"
	CurrencySyp             Currency = "SYP"
	CurrencySzl             Currency = "SZL"
	CurrencyThb             Currency = "THB"
	CurrencyTjs             Currency = "TJS"
	CurrencyTmt             Currency = "TMT"
	CurrencyTnd             Currency = "TND"
	CurrencyTop             Currency = "TOP"
	CurrencyTry             Currency = "TRY"
	CurrencyTtd             Currency = "TTD"
	CurrencyTwd             Currency = "TWD"
	CurrencyTzs             Currency = "TZS"
	CurrencyUah             Currency = "UAH"
	CurrencyUgx             Currency = "UGX"
	CurrencyUsd             Currency = "USD"
	CurrencyUsn             Currency = "USN"
	CurrencyUss             Currency = "USS"
	CurrencyUyi             Currency = "UYI"
	CurrencyUyu             Currency = "UYU"
	CurrencyUzs             Currency = "UZS"
	CurrencyVef             Currency = "VEF"
	CurrencyVnd             Currency = "VND"
	CurrencyVuv             Currency = "VUV"
	CurrencyWst             Currency = "WST"
	CurrencyXaf             Currency = "XAF"
	CurrencyXag             Currency = "XAG"
	CurrencyXau             Currency = "XAU"
	CurrencyXba             Currency = "XBA"
	CurrencyXbb             Currency = "XBB"
	CurrencyXbc             Currency = "XBC"
	CurrencyXbd             Currency = "XBD"
	CurrencyXcd             Currency = "XCD"
	CurrencyXdr             Currency = "XDR"
	CurrencyXof             Currency = "XOF"
	CurrencyXpd             Currency = "XPD"
	CurrencyXpf             Currency = "XPF"
	CurrencyXpt             Currency = "XPT"
	CurrencyXts             Currency = "XTS"
	CurrencyXxx             Currency = "XXX"
	CurrencyYer             Currency = "YER"
	CurrencyZar             Currency = "ZAR"
	CurrencyZmk             Currency = "ZMK"
	CurrencyZmw             Currency = "ZMW"
	CurrencyBtc             Currency = "BTC"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "UNKNOWN_CURRENCY":
		return CurrencyUnknownCurrency, nil
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XAG":
		return CurrencyXag, nil
	case "XAU":
		return CurrencyXau, nil
	case "XBA":
		return CurrencyXba, nil
	case "XBB":
		return CurrencyXbb, nil
	case "XBC":
		return CurrencyXbc, nil
	case "XBD":
		return CurrencyXbd, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XDR":
		return CurrencyXdr, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPD":
		return CurrencyXpd, nil
	case "XPF":
		return CurrencyXpf, nil
	case "XPT":
		return CurrencyXpt, nil
	case "XTS":
		return CurrencyXts, nil
	case "XXX":
		return CurrencyXxx, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMK":
		return CurrencyZmk, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "BTC":
		return CurrencyBtc, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

// Information about the destination against which the payout was made.
type Destination struct {
	Type *DestinationType `json:"type,omitempty" url:"type,omitempty"`
	// Square issued unique ID (also known as the instrument ID) associated with this destination.
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Destination) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Destination) UnmarshalJSON(data []byte) error {
	type unmarshaler Destination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Destination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Destination) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of possible destinations against which a payout can be made.
type DestinationType string

const (
	DestinationTypeUnknownDestinationTypeDoNotUse DestinationType = "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE"
	DestinationTypeBankAccount                    DestinationType = "BANK_ACCOUNT"
	DestinationTypeCard                           DestinationType = "CARD"
	DestinationTypeSquareBalance                  DestinationType = "SQUARE_BALANCE"
	DestinationTypeSquareStoredBalance            DestinationType = "SQUARE_STORED_BALANCE"
)

func NewDestinationTypeFromString(s string) (DestinationType, error) {
	switch s {
	case "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE":
		return DestinationTypeUnknownDestinationTypeDoNotUse, nil
	case "BANK_ACCOUNT":
		return DestinationTypeBankAccount, nil
	case "CARD":
		return DestinationTypeCard, nil
	case "SQUARE_BALANCE":
		return DestinationTypeSquareBalance, nil
	case "SQUARE_STORED_BALANCE":
		return DestinationTypeSquareStoredBalance, nil
	}
	var t DestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationType) Ptr() *DestinationType {
	return &d
}

// Represents an error encountered during a request to the Connect API.
//
// See [Handling errors](https://developer.squareup.com/docs/build-basics/handling-errors) for more information.
type Error struct {
	Category ErrorCategory `json:"category" url:"category"`
	Code     ErrorCode     `json:"code" url:"code"`
	// A human-readable description of the error for debugging purposes.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// The name of the field provided in the original request (if any) that
	// the error pertains to.
	Field *string `json:"field,omitempty" url:"field,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which high-level category of error has occurred during a
// request to the Connect API.
type ErrorCategory string

const (
	ErrorCategoryApiError                  ErrorCategory = "API_ERROR"
	ErrorCategoryAuthenticationError       ErrorCategory = "AUTHENTICATION_ERROR"
	ErrorCategoryInvalidRequestError       ErrorCategory = "INVALID_REQUEST_ERROR"
	ErrorCategoryRateLimitError            ErrorCategory = "RATE_LIMIT_ERROR"
	ErrorCategoryPaymentMethodError        ErrorCategory = "PAYMENT_METHOD_ERROR"
	ErrorCategoryRefundError               ErrorCategory = "REFUND_ERROR"
	ErrorCategoryMerchantSubscriptionError ErrorCategory = "MERCHANT_SUBSCRIPTION_ERROR"
)

func NewErrorCategoryFromString(s string) (ErrorCategory, error) {
	switch s {
	case "API_ERROR":
		return ErrorCategoryApiError, nil
	case "AUTHENTICATION_ERROR":
		return ErrorCategoryAuthenticationError, nil
	case "INVALID_REQUEST_ERROR":
		return ErrorCategoryInvalidRequestError, nil
	case "RATE_LIMIT_ERROR":
		return ErrorCategoryRateLimitError, nil
	case "PAYMENT_METHOD_ERROR":
		return ErrorCategoryPaymentMethodError, nil
	case "REFUND_ERROR":
		return ErrorCategoryRefundError, nil
	case "MERCHANT_SUBSCRIPTION_ERROR":
		return ErrorCategoryMerchantSubscriptionError, nil
	}
	var t ErrorCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCategory) Ptr() *ErrorCategory {
	return &e
}

// Indicates the specific error that occurred during a request to a
// Square API.
type ErrorCode string

const (
	ErrorCodeInternalServerError                                 ErrorCode = "INTERNAL_SERVER_ERROR"
	ErrorCodeUnauthorized                                        ErrorCode = "UNAUTHORIZED"
	ErrorCodeAccessTokenExpired                                  ErrorCode = "ACCESS_TOKEN_EXPIRED"
	ErrorCodeAccessTokenRevoked                                  ErrorCode = "ACCESS_TOKEN_REVOKED"
	ErrorCodeClientDisabled                                      ErrorCode = "CLIENT_DISABLED"
	ErrorCodeForbidden                                           ErrorCode = "FORBIDDEN"
	ErrorCodeInsufficientScopes                                  ErrorCode = "INSUFFICIENT_SCOPES"
	ErrorCodeApplicationDisabled                                 ErrorCode = "APPLICATION_DISABLED"
	ErrorCodeV1Application                                       ErrorCode = "V1_APPLICATION"
	ErrorCodeV1AccessToken                                       ErrorCode = "V1_ACCESS_TOKEN"
	ErrorCodeCardProcessingNotEnabled                            ErrorCode = "CARD_PROCESSING_NOT_ENABLED"
	ErrorCodeMerchantSubscriptionNotFound                        ErrorCode = "MERCHANT_SUBSCRIPTION_NOT_FOUND"
	ErrorCodeBadRequest                                          ErrorCode = "BAD_REQUEST"
	ErrorCodeMissingRequiredParameter                            ErrorCode = "MISSING_REQUIRED_PARAMETER"
	ErrorCodeIncorrectType                                       ErrorCode = "INCORRECT_TYPE"
	ErrorCodeInvalidTime                                         ErrorCode = "INVALID_TIME"
	ErrorCodeInvalidTimeRange                                    ErrorCode = "INVALID_TIME_RANGE"
	ErrorCodeInvalidValue                                        ErrorCode = "INVALID_VALUE"
	ErrorCodeInvalidCursor                                       ErrorCode = "INVALID_CURSOR"
	ErrorCodeUnknownQueryParameter                               ErrorCode = "UNKNOWN_QUERY_PARAMETER"
	ErrorCodeConflictingParameters                               ErrorCode = "CONFLICTING_PARAMETERS"
	ErrorCodeExpectedJsonBody                                    ErrorCode = "EXPECTED_JSON_BODY"
	ErrorCodeInvalidSortOrder                                    ErrorCode = "INVALID_SORT_ORDER"
	ErrorCodeValueRegexMismatch                                  ErrorCode = "VALUE_REGEX_MISMATCH"
	ErrorCodeValueTooShort                                       ErrorCode = "VALUE_TOO_SHORT"
	ErrorCodeValueTooLong                                        ErrorCode = "VALUE_TOO_LONG"
	ErrorCodeValueTooLow                                         ErrorCode = "VALUE_TOO_LOW"
	ErrorCodeValueTooHigh                                        ErrorCode = "VALUE_TOO_HIGH"
	ErrorCodeValueEmpty                                          ErrorCode = "VALUE_EMPTY"
	ErrorCodeArrayLengthTooLong                                  ErrorCode = "ARRAY_LENGTH_TOO_LONG"
	ErrorCodeArrayLengthTooShort                                 ErrorCode = "ARRAY_LENGTH_TOO_SHORT"
	ErrorCodeArrayEmpty                                          ErrorCode = "ARRAY_EMPTY"
	ErrorCodeExpectedBoolean                                     ErrorCode = "EXPECTED_BOOLEAN"
	ErrorCodeExpectedInteger                                     ErrorCode = "EXPECTED_INTEGER"
	ErrorCodeExpectedFloat                                       ErrorCode = "EXPECTED_FLOAT"
	ErrorCodeExpectedString                                      ErrorCode = "EXPECTED_STRING"
	ErrorCodeExpectedObject                                      ErrorCode = "EXPECTED_OBJECT"
	ErrorCodeExpectedArray                                       ErrorCode = "EXPECTED_ARRAY"
	ErrorCodeExpectedMap                                         ErrorCode = "EXPECTED_MAP"
	ErrorCodeExpectedBase64EncodedByteArray                      ErrorCode = "EXPECTED_BASE64_ENCODED_BYTE_ARRAY"
	ErrorCodeInvalidArrayValue                                   ErrorCode = "INVALID_ARRAY_VALUE"
	ErrorCodeInvalidEnumValue                                    ErrorCode = "INVALID_ENUM_VALUE"
	ErrorCodeInvalidContentType                                  ErrorCode = "INVALID_CONTENT_TYPE"
	ErrorCodeInvalidFormValue                                    ErrorCode = "INVALID_FORM_VALUE"
	ErrorCodeCustomerNotFound                                    ErrorCode = "CUSTOMER_NOT_FOUND"
	ErrorCodeBuyerNotFound                                       ErrorCode = "BUYER_NOT_FOUND"
	ErrorCodeOneInstrumentExpected                               ErrorCode = "ONE_INSTRUMENT_EXPECTED"
	ErrorCodeNoFieldsSet                                         ErrorCode = "NO_FIELDS_SET"
	ErrorCodeDeprecatedFieldSet                                  ErrorCode = "DEPRECATED_FIELD_SET"
	ErrorCodeRetiredFieldSet                                     ErrorCode = "RETIRED_FIELD_SET"
	ErrorCodeTooManyMapEntries                                   ErrorCode = "TOO_MANY_MAP_ENTRIES"
	ErrorCodeMapKeyLengthTooShort                                ErrorCode = "MAP_KEY_LENGTH_TOO_SHORT"
	ErrorCodeMapKeyLengthTooLong                                 ErrorCode = "MAP_KEY_LENGTH_TOO_LONG"
	ErrorCodeCustomerMissingName                                 ErrorCode = "CUSTOMER_MISSING_NAME"
	ErrorCodeCustomerMissingEmail                                ErrorCode = "CUSTOMER_MISSING_EMAIL"
	ErrorCodeInvalidPauseLength                                  ErrorCode = "INVALID_PAUSE_LENGTH"
	ErrorCodeInvalidDate                                         ErrorCode = "INVALID_DATE"
	ErrorCodeJobTemplateNameTaken                                ErrorCode = "JOB_TEMPLATE_NAME_TAKEN"
	ErrorCodeClientNotSupported                                  ErrorCode = "CLIENT_NOT_SUPPORTED"
	ErrorCodeCardExpired                                         ErrorCode = "CARD_EXPIRED"
	ErrorCodeInvalidExpiration                                   ErrorCode = "INVALID_EXPIRATION"
	ErrorCodeInvalidExpirationYear                               ErrorCode = "INVALID_EXPIRATION_YEAR"
	ErrorCodeInvalidExpirationDate                               ErrorCode = "INVALID_EXPIRATION_DATE"
	ErrorCodeUnsupportedCardBrand                                ErrorCode = "UNSUPPORTED_CARD_BRAND"
	ErrorCodeUnsupportedEntryMethod                              ErrorCode = "UNSUPPORTED_ENTRY_METHOD"
	ErrorCodeInvalidEncryptedCard                                ErrorCode = "INVALID_ENCRYPTED_CARD"
	ErrorCodeInvalidCard                                         ErrorCode = "INVALID_CARD"
	ErrorCodePaymentAmountMismatch                               ErrorCode = "PAYMENT_AMOUNT_MISMATCH"
	ErrorCodeGenericDecline                                      ErrorCode = "GENERIC_DECLINE"
	ErrorCodeCvvFailure                                          ErrorCode = "CVV_FAILURE"
	ErrorCodeAddressVerificationFailure                          ErrorCode = "ADDRESS_VERIFICATION_FAILURE"
	ErrorCodeInvalidAccount                                      ErrorCode = "INVALID_ACCOUNT"
	ErrorCodeCurrencyMismatch                                    ErrorCode = "CURRENCY_MISMATCH"
	ErrorCodeInsufficientFunds                                   ErrorCode = "INSUFFICIENT_FUNDS"
	ErrorCodeInsufficientPermissions                             ErrorCode = "INSUFFICIENT_PERMISSIONS"
	ErrorCodeCardholderInsufficientPermissions                   ErrorCode = "CARDHOLDER_INSUFFICIENT_PERMISSIONS"
	ErrorCodeInvalidLocation                                     ErrorCode = "INVALID_LOCATION"
	ErrorCodeTransactionLimit                                    ErrorCode = "TRANSACTION_LIMIT"
	ErrorCodeVoiceFailure                                        ErrorCode = "VOICE_FAILURE"
	ErrorCodePanFailure                                          ErrorCode = "PAN_FAILURE"
	ErrorCodeExpirationFailure                                   ErrorCode = "EXPIRATION_FAILURE"
	ErrorCodeCardNotSupported                                    ErrorCode = "CARD_NOT_SUPPORTED"
	ErrorCodeInvalidPin                                          ErrorCode = "INVALID_PIN"
	ErrorCodeMissingPin                                          ErrorCode = "MISSING_PIN"
	ErrorCodeMissingAccountType                                  ErrorCode = "MISSING_ACCOUNT_TYPE"
	ErrorCodeInvalidPostalCode                                   ErrorCode = "INVALID_POSTAL_CODE"
	ErrorCodeInvalidFees                                         ErrorCode = "INVALID_FEES"
	ErrorCodeManuallyEnteredPaymentNotSupported                  ErrorCode = "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED"
	ErrorCodePaymentLimitExceeded                                ErrorCode = "PAYMENT_LIMIT_EXCEEDED"
	ErrorCodeGiftCardAvailableAmount                             ErrorCode = "GIFT_CARD_AVAILABLE_AMOUNT"
	ErrorCodeGiftCardBuyerDailyLimitReached                      ErrorCode = "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED"
	ErrorCodeGiftCardInvalidAmount                               ErrorCode = "GIFT_CARD_INVALID_AMOUNT"
	ErrorCodeGiftCardMaxValueReached                             ErrorCode = "GIFT_CARD_MAX_VALUE_REACHED"
	ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached        ErrorCode = "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED"
	ErrorCodeGiftCardValueAdditionLimitReached                   ErrorCode = "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED"
	ErrorCodeAccountUnusable                                     ErrorCode = "ACCOUNT_UNUSABLE"
	ErrorCodeBuyerRefusedPayment                                 ErrorCode = "BUYER_REFUSED_PAYMENT"
	ErrorCodeDelayedTransactionExpired                           ErrorCode = "DELAYED_TRANSACTION_EXPIRED"
	ErrorCodeDelayedTransactionCanceled                          ErrorCode = "DELAYED_TRANSACTION_CANCELED"
	ErrorCodeDelayedTransactionCaptured                          ErrorCode = "DELAYED_TRANSACTION_CAPTURED"
	ErrorCodeDelayedTransactionFailed                            ErrorCode = "DELAYED_TRANSACTION_FAILED"
	ErrorCodeCardTokenExpired                                    ErrorCode = "CARD_TOKEN_EXPIRED"
	ErrorCodeCardTokenUsed                                       ErrorCode = "CARD_TOKEN_USED"
	ErrorCodeAmountTooHigh                                       ErrorCode = "AMOUNT_TOO_HIGH"
	ErrorCodeUnsupportedInstrumentType                           ErrorCode = "UNSUPPORTED_INSTRUMENT_TYPE"
	ErrorCodeRefundAmountInvalid                                 ErrorCode = "REFUND_AMOUNT_INVALID"
	ErrorCodeRefundAlreadyPending                                ErrorCode = "REFUND_ALREADY_PENDING"
	ErrorCodePaymentNotRefundable                                ErrorCode = "PAYMENT_NOT_REFUNDABLE"
	ErrorCodeRefundDeclined                                      ErrorCode = "REFUND_DECLINED"
	ErrorCodeInvalidCardData                                     ErrorCode = "INVALID_CARD_DATA"
	ErrorCodeSourceUsed                                          ErrorCode = "SOURCE_USED"
	ErrorCodeSourceExpired                                       ErrorCode = "SOURCE_EXPIRED"
	ErrorCodeUnsupportedLoyaltyRewardTier                        ErrorCode = "UNSUPPORTED_LOYALTY_REWARD_TIER"
	ErrorCodeLocationMismatch                                    ErrorCode = "LOCATION_MISMATCH"
	ErrorCodeOrderExpired                                        ErrorCode = "ORDER_EXPIRED"
	ErrorCodeOrderAlreadyUsed                                    ErrorCode = "ORDER_ALREADY_USED"
	ErrorCodeOrderTooManyCatalogObjects                          ErrorCode = "ORDER_TOO_MANY_CATALOG_OBJECTS"
	ErrorCodeInsufficientInventory                               ErrorCode = "INSUFFICIENT_INVENTORY"
	ErrorCodePriceMismatch                                       ErrorCode = "PRICE_MISMATCH"
	ErrorCodeVersionMismatch                                     ErrorCode = "VERSION_MISMATCH"
	ErrorCodeIdempotencyKeyReused                                ErrorCode = "IDEMPOTENCY_KEY_REUSED"
	ErrorCodeUnexpectedValue                                     ErrorCode = "UNEXPECTED_VALUE"
	ErrorCodeSandboxNotSupported                                 ErrorCode = "SANDBOX_NOT_SUPPORTED"
	ErrorCodeInvalidEmailAddress                                 ErrorCode = "INVALID_EMAIL_ADDRESS"
	ErrorCodeInvalidPhoneNumber                                  ErrorCode = "INVALID_PHONE_NUMBER"
	ErrorCodeCheckoutExpired                                     ErrorCode = "CHECKOUT_EXPIRED"
	ErrorCodeBadCertificate                                      ErrorCode = "BAD_CERTIFICATE"
	ErrorCodeInvalidSquareVersionFormat                          ErrorCode = "INVALID_SQUARE_VERSION_FORMAT"
	ErrorCodeApiVersionIncompatible                              ErrorCode = "API_VERSION_INCOMPATIBLE"
	ErrorCodeInvalidUrl                                          ErrorCode = "INVALID_URL"
	ErrorCodeHttpsOnly                                           ErrorCode = "HTTPS_ONLY"
	ErrorCodeUnreachableUrl                                      ErrorCode = "UNREACHABLE_URL"
	ErrorCodeSessionExpired                                      ErrorCode = "SESSION_EXPIRED"
	ErrorCodeInvalidVerificationCode                             ErrorCode = "INVALID_VERIFICATION_CODE"
	ErrorCodeCardDeclined                                        ErrorCode = "CARD_DECLINED"
	ErrorCodeVerifyCvvFailure                                    ErrorCode = "VERIFY_CVV_FAILURE"
	ErrorCodeVerifyAvsFailure                                    ErrorCode = "VERIFY_AVS_FAILURE"
	ErrorCodeCardDeclinedCallIssuer                              ErrorCode = "CARD_DECLINED_CALL_ISSUER"
	ErrorCodeCardDeclinedVerificationRequired                    ErrorCode = "CARD_DECLINED_VERIFICATION_REQUIRED"
	ErrorCodeBadExpiration                                       ErrorCode = "BAD_EXPIRATION"
	ErrorCodeChipInsertionRequired                               ErrorCode = "CHIP_INSERTION_REQUIRED"
	ErrorCodeAllowablePinTriesExceeded                           ErrorCode = "ALLOWABLE_PIN_TRIES_EXCEEDED"
	ErrorCodeReservationDeclined                                 ErrorCode = "RESERVATION_DECLINED"
	ErrorCodeBlockedByBlocklist                                  ErrorCode = "BLOCKED_BY_BLOCKLIST"
	ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique       ErrorCode = "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE"
	ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime     ErrorCode = "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME"
	ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed ErrorCode = "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED"
	ErrorCodeFulfillmentPreferencesAssignmentIsImmutable         ErrorCode = "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE"
	ErrorCodeInvalidTimezone                                     ErrorCode = "INVALID_TIMEZONE"
	ErrorCodeUnknownBodyParameter                                ErrorCode = "UNKNOWN_BODY_PARAMETER"
	ErrorCodeFulfillmentPreferencesConflictingAssignmentType     ErrorCode = "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE"
	ErrorCodeNotFound                                            ErrorCode = "NOT_FOUND"
	ErrorCodeApplePaymentProcessingCertificateHashNotFound       ErrorCode = "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND"
	ErrorCodeMethodNotAllowed                                    ErrorCode = "METHOD_NOT_ALLOWED"
	ErrorCodeNotAcceptable                                       ErrorCode = "NOT_ACCEPTABLE"
	ErrorCodeRequestTimeout                                      ErrorCode = "REQUEST_TIMEOUT"
	ErrorCodeConflict                                            ErrorCode = "CONFLICT"
	ErrorCodeGone                                                ErrorCode = "GONE"
	ErrorCodeRequestEntityTooLarge                               ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeUnsupportedMediaType                                ErrorCode = "UNSUPPORTED_MEDIA_TYPE"
	ErrorCodeUnprocessableEntity                                 ErrorCode = "UNPROCESSABLE_ENTITY"
	ErrorCodeRateLimited                                         ErrorCode = "RATE_LIMITED"
	ErrorCodeClientClosedRequest                                 ErrorCode = "CLIENT_CLOSED_REQUEST"
	ErrorCodeNotImplemented                                      ErrorCode = "NOT_IMPLEMENTED"
	ErrorCodeBadGateway                                          ErrorCode = "BAD_GATEWAY"
	ErrorCodeServiceUnavailable                                  ErrorCode = "SERVICE_UNAVAILABLE"
	ErrorCodeTemporaryError                                      ErrorCode = "TEMPORARY_ERROR"
	ErrorCodeGatewayTimeout                                      ErrorCode = "GATEWAY_TIMEOUT"
)

func NewErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "INTERNAL_SERVER_ERROR":
		return ErrorCodeInternalServerError, nil
	case "UNAUTHORIZED":
		return ErrorCodeUnauthorized, nil
	case "ACCESS_TOKEN_EXPIRED":
		return ErrorCodeAccessTokenExpired, nil
	case "ACCESS_TOKEN_REVOKED":
		return ErrorCodeAccessTokenRevoked, nil
	case "CLIENT_DISABLED":
		return ErrorCodeClientDisabled, nil
	case "FORBIDDEN":
		return ErrorCodeForbidden, nil
	case "INSUFFICIENT_SCOPES":
		return ErrorCodeInsufficientScopes, nil
	case "APPLICATION_DISABLED":
		return ErrorCodeApplicationDisabled, nil
	case "V1_APPLICATION":
		return ErrorCodeV1Application, nil
	case "V1_ACCESS_TOKEN":
		return ErrorCodeV1AccessToken, nil
	case "CARD_PROCESSING_NOT_ENABLED":
		return ErrorCodeCardProcessingNotEnabled, nil
	case "MERCHANT_SUBSCRIPTION_NOT_FOUND":
		return ErrorCodeMerchantSubscriptionNotFound, nil
	case "BAD_REQUEST":
		return ErrorCodeBadRequest, nil
	case "MISSING_REQUIRED_PARAMETER":
		return ErrorCodeMissingRequiredParameter, nil
	case "INCORRECT_TYPE":
		return ErrorCodeIncorrectType, nil
	case "INVALID_TIME":
		return ErrorCodeInvalidTime, nil
	case "INVALID_TIME_RANGE":
		return ErrorCodeInvalidTimeRange, nil
	case "INVALID_VALUE":
		return ErrorCodeInvalidValue, nil
	case "INVALID_CURSOR":
		return ErrorCodeInvalidCursor, nil
	case "UNKNOWN_QUERY_PARAMETER":
		return ErrorCodeUnknownQueryParameter, nil
	case "CONFLICTING_PARAMETERS":
		return ErrorCodeConflictingParameters, nil
	case "EXPECTED_JSON_BODY":
		return ErrorCodeExpectedJsonBody, nil
	case "INVALID_SORT_ORDER":
		return ErrorCodeInvalidSortOrder, nil
	case "VALUE_REGEX_MISMATCH":
		return ErrorCodeValueRegexMismatch, nil
	case "VALUE_TOO_SHORT":
		return ErrorCodeValueTooShort, nil
	case "VALUE_TOO_LONG":
		return ErrorCodeValueTooLong, nil
	case "VALUE_TOO_LOW":
		return ErrorCodeValueTooLow, nil
	case "VALUE_TOO_HIGH":
		return ErrorCodeValueTooHigh, nil
	case "VALUE_EMPTY":
		return ErrorCodeValueEmpty, nil
	case "ARRAY_LENGTH_TOO_LONG":
		return ErrorCodeArrayLengthTooLong, nil
	case "ARRAY_LENGTH_TOO_SHORT":
		return ErrorCodeArrayLengthTooShort, nil
	case "ARRAY_EMPTY":
		return ErrorCodeArrayEmpty, nil
	case "EXPECTED_BOOLEAN":
		return ErrorCodeExpectedBoolean, nil
	case "EXPECTED_INTEGER":
		return ErrorCodeExpectedInteger, nil
	case "EXPECTED_FLOAT":
		return ErrorCodeExpectedFloat, nil
	case "EXPECTED_STRING":
		return ErrorCodeExpectedString, nil
	case "EXPECTED_OBJECT":
		return ErrorCodeExpectedObject, nil
	case "EXPECTED_ARRAY":
		return ErrorCodeExpectedArray, nil
	case "EXPECTED_MAP":
		return ErrorCodeExpectedMap, nil
	case "EXPECTED_BASE64_ENCODED_BYTE_ARRAY":
		return ErrorCodeExpectedBase64EncodedByteArray, nil
	case "INVALID_ARRAY_VALUE":
		return ErrorCodeInvalidArrayValue, nil
	case "INVALID_ENUM_VALUE":
		return ErrorCodeInvalidEnumValue, nil
	case "INVALID_CONTENT_TYPE":
		return ErrorCodeInvalidContentType, nil
	case "INVALID_FORM_VALUE":
		return ErrorCodeInvalidFormValue, nil
	case "CUSTOMER_NOT_FOUND":
		return ErrorCodeCustomerNotFound, nil
	case "BUYER_NOT_FOUND":
		return ErrorCodeBuyerNotFound, nil
	case "ONE_INSTRUMENT_EXPECTED":
		return ErrorCodeOneInstrumentExpected, nil
	case "NO_FIELDS_SET":
		return ErrorCodeNoFieldsSet, nil
	case "DEPRECATED_FIELD_SET":
		return ErrorCodeDeprecatedFieldSet, nil
	case "RETIRED_FIELD_SET":
		return ErrorCodeRetiredFieldSet, nil
	case "TOO_MANY_MAP_ENTRIES":
		return ErrorCodeTooManyMapEntries, nil
	case "MAP_KEY_LENGTH_TOO_SHORT":
		return ErrorCodeMapKeyLengthTooShort, nil
	case "MAP_KEY_LENGTH_TOO_LONG":
		return ErrorCodeMapKeyLengthTooLong, nil
	case "CUSTOMER_MISSING_NAME":
		return ErrorCodeCustomerMissingName, nil
	case "CUSTOMER_MISSING_EMAIL":
		return ErrorCodeCustomerMissingEmail, nil
	case "INVALID_PAUSE_LENGTH":
		return ErrorCodeInvalidPauseLength, nil
	case "INVALID_DATE":
		return ErrorCodeInvalidDate, nil
	case "JOB_TEMPLATE_NAME_TAKEN":
		return ErrorCodeJobTemplateNameTaken, nil
	case "CLIENT_NOT_SUPPORTED":
		return ErrorCodeClientNotSupported, nil
	case "CARD_EXPIRED":
		return ErrorCodeCardExpired, nil
	case "INVALID_EXPIRATION":
		return ErrorCodeInvalidExpiration, nil
	case "INVALID_EXPIRATION_YEAR":
		return ErrorCodeInvalidExpirationYear, nil
	case "INVALID_EXPIRATION_DATE":
		return ErrorCodeInvalidExpirationDate, nil
	case "UNSUPPORTED_CARD_BRAND":
		return ErrorCodeUnsupportedCardBrand, nil
	case "UNSUPPORTED_ENTRY_METHOD":
		return ErrorCodeUnsupportedEntryMethod, nil
	case "INVALID_ENCRYPTED_CARD":
		return ErrorCodeInvalidEncryptedCard, nil
	case "INVALID_CARD":
		return ErrorCodeInvalidCard, nil
	case "PAYMENT_AMOUNT_MISMATCH":
		return ErrorCodePaymentAmountMismatch, nil
	case "GENERIC_DECLINE":
		return ErrorCodeGenericDecline, nil
	case "CVV_FAILURE":
		return ErrorCodeCvvFailure, nil
	case "ADDRESS_VERIFICATION_FAILURE":
		return ErrorCodeAddressVerificationFailure, nil
	case "INVALID_ACCOUNT":
		return ErrorCodeInvalidAccount, nil
	case "CURRENCY_MISMATCH":
		return ErrorCodeCurrencyMismatch, nil
	case "INSUFFICIENT_FUNDS":
		return ErrorCodeInsufficientFunds, nil
	case "INSUFFICIENT_PERMISSIONS":
		return ErrorCodeInsufficientPermissions, nil
	case "CARDHOLDER_INSUFFICIENT_PERMISSIONS":
		return ErrorCodeCardholderInsufficientPermissions, nil
	case "INVALID_LOCATION":
		return ErrorCodeInvalidLocation, nil
	case "TRANSACTION_LIMIT":
		return ErrorCodeTransactionLimit, nil
	case "VOICE_FAILURE":
		return ErrorCodeVoiceFailure, nil
	case "PAN_FAILURE":
		return ErrorCodePanFailure, nil
	case "EXPIRATION_FAILURE":
		return ErrorCodeExpirationFailure, nil
	case "CARD_NOT_SUPPORTED":
		return ErrorCodeCardNotSupported, nil
	case "INVALID_PIN":
		return ErrorCodeInvalidPin, nil
	case "MISSING_PIN":
		return ErrorCodeMissingPin, nil
	case "MISSING_ACCOUNT_TYPE":
		return ErrorCodeMissingAccountType, nil
	case "INVALID_POSTAL_CODE":
		return ErrorCodeInvalidPostalCode, nil
	case "INVALID_FEES":
		return ErrorCodeInvalidFees, nil
	case "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED":
		return ErrorCodeManuallyEnteredPaymentNotSupported, nil
	case "PAYMENT_LIMIT_EXCEEDED":
		return ErrorCodePaymentLimitExceeded, nil
	case "GIFT_CARD_AVAILABLE_AMOUNT":
		return ErrorCodeGiftCardAvailableAmount, nil
	case "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED":
		return ErrorCodeGiftCardBuyerDailyLimitReached, nil
	case "GIFT_CARD_INVALID_AMOUNT":
		return ErrorCodeGiftCardInvalidAmount, nil
	case "GIFT_CARD_MAX_VALUE_REACHED":
		return ErrorCodeGiftCardMaxValueReached, nil
	case "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED":
		return ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached, nil
	case "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED":
		return ErrorCodeGiftCardValueAdditionLimitReached, nil
	case "ACCOUNT_UNUSABLE":
		return ErrorCodeAccountUnusable, nil
	case "BUYER_REFUSED_PAYMENT":
		return ErrorCodeBuyerRefusedPayment, nil
	case "DELAYED_TRANSACTION_EXPIRED":
		return ErrorCodeDelayedTransactionExpired, nil
	case "DELAYED_TRANSACTION_CANCELED":
		return ErrorCodeDelayedTransactionCanceled, nil
	case "DELAYED_TRANSACTION_CAPTURED":
		return ErrorCodeDelayedTransactionCaptured, nil
	case "DELAYED_TRANSACTION_FAILED":
		return ErrorCodeDelayedTransactionFailed, nil
	case "CARD_TOKEN_EXPIRED":
		return ErrorCodeCardTokenExpired, nil
	case "CARD_TOKEN_USED":
		return ErrorCodeCardTokenUsed, nil
	case "AMOUNT_TOO_HIGH":
		return ErrorCodeAmountTooHigh, nil
	case "UNSUPPORTED_INSTRUMENT_TYPE":
		return ErrorCodeUnsupportedInstrumentType, nil
	case "REFUND_AMOUNT_INVALID":
		return ErrorCodeRefundAmountInvalid, nil
	case "REFUND_ALREADY_PENDING":
		return ErrorCodeRefundAlreadyPending, nil
	case "PAYMENT_NOT_REFUNDABLE":
		return ErrorCodePaymentNotRefundable, nil
	case "REFUND_DECLINED":
		return ErrorCodeRefundDeclined, nil
	case "INVALID_CARD_DATA":
		return ErrorCodeInvalidCardData, nil
	case "SOURCE_USED":
		return ErrorCodeSourceUsed, nil
	case "SOURCE_EXPIRED":
		return ErrorCodeSourceExpired, nil
	case "UNSUPPORTED_LOYALTY_REWARD_TIER":
		return ErrorCodeUnsupportedLoyaltyRewardTier, nil
	case "LOCATION_MISMATCH":
		return ErrorCodeLocationMismatch, nil
	case "ORDER_EXPIRED":
		return ErrorCodeOrderExpired, nil
	case "ORDER_ALREADY_USED":
		return ErrorCodeOrderAlreadyUsed, nil
	case "ORDER_TOO_MANY_CATALOG_OBJECTS":
		return ErrorCodeOrderTooManyCatalogObjects, nil
	case "INSUFFICIENT_INVENTORY":
		return ErrorCodeInsufficientInventory, nil
	case "PRICE_MISMATCH":
		return ErrorCodePriceMismatch, nil
	case "VERSION_MISMATCH":
		return ErrorCodeVersionMismatch, nil
	case "IDEMPOTENCY_KEY_REUSED":
		return ErrorCodeIdempotencyKeyReused, nil
	case "UNEXPECTED_VALUE":
		return ErrorCodeUnexpectedValue, nil
	case "SANDBOX_NOT_SUPPORTED":
		return ErrorCodeSandboxNotSupported, nil
	case "INVALID_EMAIL_ADDRESS":
		return ErrorCodeInvalidEmailAddress, nil
	case "INVALID_PHONE_NUMBER":
		return ErrorCodeInvalidPhoneNumber, nil
	case "CHECKOUT_EXPIRED":
		return ErrorCodeCheckoutExpired, nil
	case "BAD_CERTIFICATE":
		return ErrorCodeBadCertificate, nil
	case "INVALID_SQUARE_VERSION_FORMAT":
		return ErrorCodeInvalidSquareVersionFormat, nil
	case "API_VERSION_INCOMPATIBLE":
		return ErrorCodeApiVersionIncompatible, nil
	case "INVALID_URL":
		return ErrorCodeInvalidUrl, nil
	case "HTTPS_ONLY":
		return ErrorCodeHttpsOnly, nil
	case "UNREACHABLE_URL":
		return ErrorCodeUnreachableUrl, nil
	case "SESSION_EXPIRED":
		return ErrorCodeSessionExpired, nil
	case "INVALID_VERIFICATION_CODE":
		return ErrorCodeInvalidVerificationCode, nil
	case "CARD_DECLINED":
		return ErrorCodeCardDeclined, nil
	case "VERIFY_CVV_FAILURE":
		return ErrorCodeVerifyCvvFailure, nil
	case "VERIFY_AVS_FAILURE":
		return ErrorCodeVerifyAvsFailure, nil
	case "CARD_DECLINED_CALL_ISSUER":
		return ErrorCodeCardDeclinedCallIssuer, nil
	case "CARD_DECLINED_VERIFICATION_REQUIRED":
		return ErrorCodeCardDeclinedVerificationRequired, nil
	case "BAD_EXPIRATION":
		return ErrorCodeBadExpiration, nil
	case "CHIP_INSERTION_REQUIRED":
		return ErrorCodeChipInsertionRequired, nil
	case "ALLOWABLE_PIN_TRIES_EXCEEDED":
		return ErrorCodeAllowablePinTriesExceeded, nil
	case "RESERVATION_DECLINED":
		return ErrorCodeReservationDeclined, nil
	case "BLOCKED_BY_BLOCKLIST":
		return ErrorCodeBlockedByBlocklist, nil
	case "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE":
		return ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique, nil
	case "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME":
		return ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime, nil
	case "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED":
		return ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed, nil
	case "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE":
		return ErrorCodeFulfillmentPreferencesAssignmentIsImmutable, nil
	case "INVALID_TIMEZONE":
		return ErrorCodeInvalidTimezone, nil
	case "UNKNOWN_BODY_PARAMETER":
		return ErrorCodeUnknownBodyParameter, nil
	case "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE":
		return ErrorCodeFulfillmentPreferencesConflictingAssignmentType, nil
	case "NOT_FOUND":
		return ErrorCodeNotFound, nil
	case "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND":
		return ErrorCodeApplePaymentProcessingCertificateHashNotFound, nil
	case "METHOD_NOT_ALLOWED":
		return ErrorCodeMethodNotAllowed, nil
	case "NOT_ACCEPTABLE":
		return ErrorCodeNotAcceptable, nil
	case "REQUEST_TIMEOUT":
		return ErrorCodeRequestTimeout, nil
	case "CONFLICT":
		return ErrorCodeConflict, nil
	case "GONE":
		return ErrorCodeGone, nil
	case "REQUEST_ENTITY_TOO_LARGE":
		return ErrorCodeRequestEntityTooLarge, nil
	case "UNSUPPORTED_MEDIA_TYPE":
		return ErrorCodeUnsupportedMediaType, nil
	case "UNPROCESSABLE_ENTITY":
		return ErrorCodeUnprocessableEntity, nil
	case "RATE_LIMITED":
		return ErrorCodeRateLimited, nil
	case "CLIENT_CLOSED_REQUEST":
		return ErrorCodeClientClosedRequest, nil
	case "NOT_IMPLEMENTED":
		return ErrorCodeNotImplemented, nil
	case "BAD_GATEWAY":
		return ErrorCodeBadGateway, nil
	case "SERVICE_UNAVAILABLE":
		return ErrorCodeServiceUnavailable, nil
	case "TEMPORARY_ERROR":
		return ErrorCodeTemporaryError, nil
	case "GATEWAY_TIMEOUT":
		return ErrorCodeGatewayTimeout, nil
	}
	var t ErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCode) Ptr() *ErrorCode {
	return &e
}

// Defines the response returned by [GetRefund](api-endpoint:Refunds-GetPaymentRefund).
//
// Note: If there are errors processing the request, the refund field might not be
// present or it might be present in a FAILED state.
type GetPaymentRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error       `json:"errors,omitempty" url:"errors,omitempty"`
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRefundResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayoutResponse struct {
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPayoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayoutResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the response returned by [ListPaymentRefunds](api-endpoint:Refunds-ListPaymentRefunds).
//
// Either `errors` or `refunds` is present in a given response (never both).
type ListPaymentRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of requested refunds.
	Refunds []*PaymentRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentRefundsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentRefundsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to retrieve payout records entries.
type ListPayoutsResponse struct {
	// The requested list of payouts.
	Payouts []*Payout `json:"payouts,omitempty" url:"payouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a unit of measurement to use with a quantity, such as ounces
// or inches. Exactly one of the following fields are required: `custom_unit`,
// `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
type MeasurementUnit struct {
	CustomUnit  *MeasurementUnitCustom   `json:"custom_unit,omitempty" url:"custom_unit,omitempty"`
	AreaUnit    *MeasurementUnitArea     `json:"area_unit,omitempty" url:"area_unit,omitempty"`
	LengthUnit  *MeasurementUnitLength   `json:"length_unit,omitempty" url:"length_unit,omitempty"`
	VolumeUnit  *MeasurementUnitVolume   `json:"volume_unit,omitempty" url:"volume_unit,omitempty"`
	WeightUnit  *MeasurementUnitWeight   `json:"weight_unit,omitempty" url:"weight_unit,omitempty"`
	GenericUnit *MeasurementUnitGeneric  `json:"generic_unit,omitempty" url:"generic_unit,omitempty"`
	TimeUnit    *MeasurementUnitTime     `json:"time_unit,omitempty" url:"time_unit,omitempty"`
	Type        *MeasurementUnitUnitType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnit) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnit) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of area used to measure a quantity.
type MeasurementUnitArea string

const (
	MeasurementUnitAreaInvalidArea            MeasurementUnitArea = "INVALID_AREA"
	MeasurementUnitAreaImperialAcre           MeasurementUnitArea = "IMPERIAL_ACRE"
	MeasurementUnitAreaImperialSquareInch     MeasurementUnitArea = "IMPERIAL_SQUARE_INCH"
	MeasurementUnitAreaImperialSquareFoot     MeasurementUnitArea = "IMPERIAL_SQUARE_FOOT"
	MeasurementUnitAreaImperialSquareYard     MeasurementUnitArea = "IMPERIAL_SQUARE_YARD"
	MeasurementUnitAreaImperialSquareMile     MeasurementUnitArea = "IMPERIAL_SQUARE_MILE"
	MeasurementUnitAreaMetricSquareCentimeter MeasurementUnitArea = "METRIC_SQUARE_CENTIMETER"
	MeasurementUnitAreaMetricSquareMeter      MeasurementUnitArea = "METRIC_SQUARE_METER"
	MeasurementUnitAreaMetricSquareKilometer  MeasurementUnitArea = "METRIC_SQUARE_KILOMETER"
)

func NewMeasurementUnitAreaFromString(s string) (MeasurementUnitArea, error) {
	switch s {
	case "INVALID_AREA":
		return MeasurementUnitAreaInvalidArea, nil
	case "IMPERIAL_ACRE":
		return MeasurementUnitAreaImperialAcre, nil
	case "IMPERIAL_SQUARE_INCH":
		return MeasurementUnitAreaImperialSquareInch, nil
	case "IMPERIAL_SQUARE_FOOT":
		return MeasurementUnitAreaImperialSquareFoot, nil
	case "IMPERIAL_SQUARE_YARD":
		return MeasurementUnitAreaImperialSquareYard, nil
	case "IMPERIAL_SQUARE_MILE":
		return MeasurementUnitAreaImperialSquareMile, nil
	case "METRIC_SQUARE_CENTIMETER":
		return MeasurementUnitAreaMetricSquareCentimeter, nil
	case "METRIC_SQUARE_METER":
		return MeasurementUnitAreaMetricSquareMeter, nil
	case "METRIC_SQUARE_KILOMETER":
		return MeasurementUnitAreaMetricSquareKilometer, nil
	}
	var t MeasurementUnitArea
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitArea) Ptr() *MeasurementUnitArea {
	return &m
}

// The information needed to define a custom unit, provided by the seller.
type MeasurementUnitCustom struct {
	// The name of the custom unit, for example "bushel".
	Name string `json:"name" url:"name"`
	// The abbreviation of the custom unit, such as "bsh" (bushel). This appears
	// in the cart for the Point of Sale app, and in reports.
	Abbreviation string `json:"abbreviation" url:"abbreviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnitCustom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnitCustom) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnitCustom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnitCustom(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnitCustom) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MeasurementUnitGeneric string

const (
	MeasurementUnitGenericInvalidGenericUnit MeasurementUnitGeneric = "INVALID_GENERIC_UNIT"
	MeasurementUnitGenericUnit               MeasurementUnitGeneric = "UNIT"
)

func NewMeasurementUnitGenericFromString(s string) (MeasurementUnitGeneric, error) {
	switch s {
	case "INVALID_GENERIC_UNIT":
		return MeasurementUnitGenericInvalidGenericUnit, nil
	case "UNIT":
		return MeasurementUnitGenericUnit, nil
	}
	var t MeasurementUnitGeneric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitGeneric) Ptr() *MeasurementUnitGeneric {
	return &m
}

// The unit of length used to measure a quantity.
type MeasurementUnitLength string

const (
	MeasurementUnitLengthInvalidLength    MeasurementUnitLength = "INVALID_LENGTH"
	MeasurementUnitLengthImperialInch     MeasurementUnitLength = "IMPERIAL_INCH"
	MeasurementUnitLengthImperialFoot     MeasurementUnitLength = "IMPERIAL_FOOT"
	MeasurementUnitLengthImperialYard     MeasurementUnitLength = "IMPERIAL_YARD"
	MeasurementUnitLengthImperialMile     MeasurementUnitLength = "IMPERIAL_MILE"
	MeasurementUnitLengthMetricMillimeter MeasurementUnitLength = "METRIC_MILLIMETER"
	MeasurementUnitLengthMetricCentimeter MeasurementUnitLength = "METRIC_CENTIMETER"
	MeasurementUnitLengthMetricMeter      MeasurementUnitLength = "METRIC_METER"
	MeasurementUnitLengthMetricKilometer  MeasurementUnitLength = "METRIC_KILOMETER"
)

func NewMeasurementUnitLengthFromString(s string) (MeasurementUnitLength, error) {
	switch s {
	case "INVALID_LENGTH":
		return MeasurementUnitLengthInvalidLength, nil
	case "IMPERIAL_INCH":
		return MeasurementUnitLengthImperialInch, nil
	case "IMPERIAL_FOOT":
		return MeasurementUnitLengthImperialFoot, nil
	case "IMPERIAL_YARD":
		return MeasurementUnitLengthImperialYard, nil
	case "IMPERIAL_MILE":
		return MeasurementUnitLengthImperialMile, nil
	case "METRIC_MILLIMETER":
		return MeasurementUnitLengthMetricMillimeter, nil
	case "METRIC_CENTIMETER":
		return MeasurementUnitLengthMetricCentimeter, nil
	case "METRIC_METER":
		return MeasurementUnitLengthMetricMeter, nil
	case "METRIC_KILOMETER":
		return MeasurementUnitLengthMetricKilometer, nil
	}
	var t MeasurementUnitLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitLength) Ptr() *MeasurementUnitLength {
	return &m
}

// Unit of time used to measure a quantity (a duration).
type MeasurementUnitTime string

const (
	MeasurementUnitTimeInvalidTime        MeasurementUnitTime = "INVALID_TIME"
	MeasurementUnitTimeGenericMillisecond MeasurementUnitTime = "GENERIC_MILLISECOND"
	MeasurementUnitTimeGenericSecond      MeasurementUnitTime = "GENERIC_SECOND"
	MeasurementUnitTimeGenericMinute      MeasurementUnitTime = "GENERIC_MINUTE"
	MeasurementUnitTimeGenericHour        MeasurementUnitTime = "GENERIC_HOUR"
	MeasurementUnitTimeGenericDay         MeasurementUnitTime = "GENERIC_DAY"
)

func NewMeasurementUnitTimeFromString(s string) (MeasurementUnitTime, error) {
	switch s {
	case "INVALID_TIME":
		return MeasurementUnitTimeInvalidTime, nil
	case "GENERIC_MILLISECOND":
		return MeasurementUnitTimeGenericMillisecond, nil
	case "GENERIC_SECOND":
		return MeasurementUnitTimeGenericSecond, nil
	case "GENERIC_MINUTE":
		return MeasurementUnitTimeGenericMinute, nil
	case "GENERIC_HOUR":
		return MeasurementUnitTimeGenericHour, nil
	case "GENERIC_DAY":
		return MeasurementUnitTimeGenericDay, nil
	}
	var t MeasurementUnitTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitTime) Ptr() *MeasurementUnitTime {
	return &m
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type MeasurementUnitUnitType string

const (
	MeasurementUnitUnitTypeInvalidType MeasurementUnitUnitType = "INVALID_TYPE"
	MeasurementUnitUnitTypeTypeCustom  MeasurementUnitUnitType = "TYPE_CUSTOM"
	MeasurementUnitUnitTypeTypeArea    MeasurementUnitUnitType = "TYPE_AREA"
	MeasurementUnitUnitTypeTypeLength  MeasurementUnitUnitType = "TYPE_LENGTH"
	MeasurementUnitUnitTypeTypeVolume  MeasurementUnitUnitType = "TYPE_VOLUME"
	MeasurementUnitUnitTypeTypeWeight  MeasurementUnitUnitType = "TYPE_WEIGHT"
	MeasurementUnitUnitTypeTypeTime    MeasurementUnitUnitType = "TYPE_TIME"
	MeasurementUnitUnitTypeTypeGeneric MeasurementUnitUnitType = "TYPE_GENERIC"
)

func NewMeasurementUnitUnitTypeFromString(s string) (MeasurementUnitUnitType, error) {
	switch s {
	case "INVALID_TYPE":
		return MeasurementUnitUnitTypeInvalidType, nil
	case "TYPE_CUSTOM":
		return MeasurementUnitUnitTypeTypeCustom, nil
	case "TYPE_AREA":
		return MeasurementUnitUnitTypeTypeArea, nil
	case "TYPE_LENGTH":
		return MeasurementUnitUnitTypeTypeLength, nil
	case "TYPE_VOLUME":
		return MeasurementUnitUnitTypeTypeVolume, nil
	case "TYPE_WEIGHT":
		return MeasurementUnitUnitTypeTypeWeight, nil
	case "TYPE_TIME":
		return MeasurementUnitUnitTypeTypeTime, nil
	case "TYPE_GENERIC":
		return MeasurementUnitUnitTypeTypeGeneric, nil
	}
	var t MeasurementUnitUnitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitUnitType) Ptr() *MeasurementUnitUnitType {
	return &m
}

// The unit of volume used to measure a quantity.
type MeasurementUnitVolume string

const (
	MeasurementUnitVolumeInvalidVolume     MeasurementUnitVolume = "INVALID_VOLUME"
	MeasurementUnitVolumeGenericFluidOunce MeasurementUnitVolume = "GENERIC_FLUID_OUNCE"
	MeasurementUnitVolumeGenericShot       MeasurementUnitVolume = "GENERIC_SHOT"
	MeasurementUnitVolumeGenericCup        MeasurementUnitVolume = "GENERIC_CUP"
	MeasurementUnitVolumeGenericPint       MeasurementUnitVolume = "GENERIC_PINT"
	MeasurementUnitVolumeGenericQuart      MeasurementUnitVolume = "GENERIC_QUART"
	MeasurementUnitVolumeGenericGallon     MeasurementUnitVolume = "GENERIC_GALLON"
	MeasurementUnitVolumeImperialCubicInch MeasurementUnitVolume = "IMPERIAL_CUBIC_INCH"
	MeasurementUnitVolumeImperialCubicFoot MeasurementUnitVolume = "IMPERIAL_CUBIC_FOOT"
	MeasurementUnitVolumeImperialCubicYard MeasurementUnitVolume = "IMPERIAL_CUBIC_YARD"
	MeasurementUnitVolumeMetricMilliliter  MeasurementUnitVolume = "METRIC_MILLILITER"
	MeasurementUnitVolumeMetricLiter       MeasurementUnitVolume = "METRIC_LITER"
)

func NewMeasurementUnitVolumeFromString(s string) (MeasurementUnitVolume, error) {
	switch s {
	case "INVALID_VOLUME":
		return MeasurementUnitVolumeInvalidVolume, nil
	case "GENERIC_FLUID_OUNCE":
		return MeasurementUnitVolumeGenericFluidOunce, nil
	case "GENERIC_SHOT":
		return MeasurementUnitVolumeGenericShot, nil
	case "GENERIC_CUP":
		return MeasurementUnitVolumeGenericCup, nil
	case "GENERIC_PINT":
		return MeasurementUnitVolumeGenericPint, nil
	case "GENERIC_QUART":
		return MeasurementUnitVolumeGenericQuart, nil
	case "GENERIC_GALLON":
		return MeasurementUnitVolumeGenericGallon, nil
	case "IMPERIAL_CUBIC_INCH":
		return MeasurementUnitVolumeImperialCubicInch, nil
	case "IMPERIAL_CUBIC_FOOT":
		return MeasurementUnitVolumeImperialCubicFoot, nil
	case "IMPERIAL_CUBIC_YARD":
		return MeasurementUnitVolumeImperialCubicYard, nil
	case "METRIC_MILLILITER":
		return MeasurementUnitVolumeMetricMilliliter, nil
	case "METRIC_LITER":
		return MeasurementUnitVolumeMetricLiter, nil
	}
	var t MeasurementUnitVolume
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitVolume) Ptr() *MeasurementUnitVolume {
	return &m
}

// Unit of weight used to measure a quantity.
type MeasurementUnitWeight string

const (
	MeasurementUnitWeightInvalidWeight       MeasurementUnitWeight = "INVALID_WEIGHT"
	MeasurementUnitWeightImperialWeightOunce MeasurementUnitWeight = "IMPERIAL_WEIGHT_OUNCE"
	MeasurementUnitWeightImperialPound       MeasurementUnitWeight = "IMPERIAL_POUND"
	MeasurementUnitWeightImperialStone       MeasurementUnitWeight = "IMPERIAL_STONE"
	MeasurementUnitWeightMetricMilligram     MeasurementUnitWeight = "METRIC_MILLIGRAM"
	MeasurementUnitWeightMetricGram          MeasurementUnitWeight = "METRIC_GRAM"
	MeasurementUnitWeightMetricKilogram      MeasurementUnitWeight = "METRIC_KILOGRAM"
)

func NewMeasurementUnitWeightFromString(s string) (MeasurementUnitWeight, error) {
	switch s {
	case "INVALID_WEIGHT":
		return MeasurementUnitWeightInvalidWeight, nil
	case "IMPERIAL_WEIGHT_OUNCE":
		return MeasurementUnitWeightImperialWeightOunce, nil
	case "IMPERIAL_POUND":
		return MeasurementUnitWeightImperialPound, nil
	case "IMPERIAL_STONE":
		return MeasurementUnitWeightImperialStone, nil
	case "METRIC_MILLIGRAM":
		return MeasurementUnitWeightMetricMilligram, nil
	case "METRIC_GRAM":
		return MeasurementUnitWeightMetricGram, nil
	case "METRIC_KILOGRAM":
		return MeasurementUnitWeightMetricKilogram, nil
	}
	var t MeasurementUnitWeight
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitWeight) Ptr() *MeasurementUnitWeight {
	return &m
}

// Represents a business that sells with Square.
type Merchant struct {
	// The Square-issued ID of the merchant.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the merchant's overall business.
	BusinessName *string `json:"business_name,omitempty" url:"business_name,omitempty"`
	Country      Country `json:"country" url:"country"`
	// The code indicating the [language preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences) of the merchant, in [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A). For example, `en-US` or `fr-CA`.
	LanguageCode *string         `json:"language_code,omitempty" url:"language_code,omitempty"`
	Currency     *Currency       `json:"currency,omitempty" url:"currency,omitempty"`
	Status       *MerchantStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the [main `Location`](https://developer.squareup.com/docs/locations-api#about-the-main-location) for this merchant.
	MainLocationId *string `json:"main_location_id,omitempty" url:"main_location_id,omitempty"`
	// The time when the merchant was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Merchant) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Merchant) UnmarshalJSON(data []byte) error {
	type unmarshaler Merchant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Merchant(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Merchant) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantStatus string

const (
	MerchantStatusActive   MerchantStatus = "ACTIVE"
	MerchantStatusInactive MerchantStatus = "INACTIVE"
)

func NewMerchantStatusFromString(s string) (MerchantStatus, error) {
	switch s {
	case "ACTIVE":
		return MerchantStatusActive, nil
	case "INACTIVE":
		return MerchantStatusInactive, nil
	}
	var t MerchantStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MerchantStatus) Ptr() *MerchantStatus {
	return &m
}

// Represents an amount of money. `Money` fields can be signed or unsigned.
// Fields that do not explicitly define whether they are signed or unsigned are
// considered unsigned and can only hold positive amounts. For signed fields, the
// sign of the value indicates the purpose of the money transfer. See
// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
// for more information.
type Money struct {
	// The amount of money, in the smallest denomination of the currency
	// indicated by `currency`. For example, when `currency` is `USD`, `amount` is
	// in cents. Monetary amounts can be positive or negative. See the specific
	// field description to determine the meaning of the sign in a particular case.
	Amount   *int64    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Money) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Money) UnmarshalJSON(data []byte) error {
	type unmarshaler Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Money) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OauthScope string

const (
	// **HTTP Method**: `GET`
	//
	// Grants read access to bank account information associated with the targeted
	// Square account. For example, to call the Connect v1 ListBankAccounts endpoint.
	OauthScopeBankAccountsRead OauthScope = "BANK_ACCOUNTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to cash drawer shift information. For example, to call the
	// ListCashDrawerShifts endpoint.
	OauthScopeCashDrawerRead OauthScope = "CASH_DRAWER_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to customer information. For example, to call the
	// ListCustomers endpoint.
	OauthScopeCustomersRead OauthScope = "CUSTOMERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to customer information. For example, to create and update
	// customer profiles.
	OauthScopeCustomersWrite OauthScope = "CUSTOMERS_WRITE"
	// **HTTP Method**: `POST`, `GET`
	//
	// Grants read/write access to device credentials information. For example, to
	// call the CreateDeviceCode endpoint.
	OauthScopeDeviceCredentialManagement OauthScope = "DEVICE_CREDENTIAL_MANAGEMENT"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee profile information. For example, to call the
	// Connect v1 Employees API.
	OauthScopeEmployeesRead OauthScope = "EMPLOYEES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee profile information. For example, to create
	// and modify employee profiles.
	OauthScopeEmployeesWrite OauthScope = "EMPLOYEES_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to inventory information. For example, to call the
	// RetrieveInventoryCount endpoint.
	OauthScopeInventoryRead OauthScope = "INVENTORY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to inventory information. For example, to call the
	// BatchChangeInventory endpoint.
	OauthScopeInventoryWrite OauthScope = "INVENTORY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeItemsRead OauthScope = "ITEMS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to product catalog information. For example, to modify or
	// add to a product catalog.
	OauthScopeItemsWrite OauthScope = "ITEMS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to loyalty information. For example, to call the
	// ListLoyaltyPrograms endpoint.
	OauthScopeLoyaltyRead OauthScope = "LOYALTY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to loyalty information. For example, to call the
	// CreateLoyaltyAccount endpoint.
	OauthScopeLoyaltyWrite OauthScope = "LOYALTY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeMerchantProfileRead OauthScope = "MERCHANT_PROFILE_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to order information. For example, to call the
	// BatchRetrieveOrders endpoint.
	OauthScopeOrdersRead OauthScope = "ORDERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to order information. For example, to call the
	// CreateCheckout endpoint.
	OauthScopeOrdersWrite OauthScope = "ORDERS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to transaction and refund information. For example, to call
	// the RetrieveTransaction endpoint.
	OauthScopePaymentsRead OauthScope = "PAYMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to transaction and refunds information. For example, to
	// process payments with the Payments or Checkout API.
	OauthScopePaymentsWrite OauthScope = "PAYMENTS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allow third party applications to deduct a portion of each transaction amount.
	// **Required** to use multiparty transaction functionality with the Payments
	// API.
	OauthScopePaymentsWriteAdditionalRecipients OauthScope = "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to payments and refunds information. For example, to
	// process in-person payments.
	OauthScopePaymentsWriteInPerson OauthScope = "PAYMENTS_WRITE_IN_PERSON"
	// **HTTP Method**: `GET`
	//
	// Grants read access to settlement (deposit) information. For example, to call
	// the Connect v1 ListSettlements endpoint.
	OauthScopeSettlementsRead OauthScope = "SETTLEMENTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard information. For example, to call the
	// Connect v2 SearchShifts endpoint.
	OauthScopeTimecardsRead OauthScope = "TIMECARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee shift information. For example, to create
	// and modify employee shifts.
	OauthScopeTimecardsWrite OauthScope = "TIMECARDS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard settings information. For example, to
	// call the GetBreakType endpoint.
	OauthScopeTimecardsSettingsRead OauthScope = "TIMECARDS_SETTINGS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee timecard settings information. For example, to
	// call the UpdateBreakType endpoint.
	OauthScopeTimecardsSettingsWrite OauthScope = "TIMECARDS_SETTINGS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to booking information. For example, to call the
	// RetrieveBooking endpoint.
	OauthScopeAppointmentsRead OauthScope = "APPOINTMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to booking information. For example, to call the CreateBooking endpoint.
	OauthScopeAppointmentsWrite OauthScope = "APPOINTMENTS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to booking business settings. For example, to call the
	// ListTeamMemberBookingProfiles endpoint.
	OauthScopeAppointmentsBusinessSettingsRead OauthScope = "APPOINTMENTS_BUSINESS_SETTINGS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to invoice information. For example, to call the ListInvoices endpoint.
	OauthScopeInvoicesRead OauthScope = "INVOICES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to invoice information. For example, to call the CreateInvoice endpoint.
	OauthScopeInvoicesWrite OauthScope = "INVOICES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to subscription information. For example, to call the RetrieveSubscription
	// endpoint.
	OauthScopeSubscriptionsRead OauthScope = "SUBSCRIPTIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to subscription information. For example, to call the CreateSubscription
	// endpoint.
	OauthScopeSubscriptionsWrite OauthScope = "SUBSCRIPTIONS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to dispute information. For example, to call the RetrieveDispute
	// endpoint.
	OauthScopeDisputesRead OauthScope = "DISPUTES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to dispute information. For example, to call the SubmitEvidence
	// endpoint.
	OauthScopeDisputesWrite OauthScope = "DISPUTES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to gift card information. For example, to call the RetrieveGiftCard
	// endpoint.
	OauthScopeGiftcardsRead OauthScope = "GIFTCARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to gift card information. For example, to call the CreateGiftCard
	// endpoint.
	OauthScopeGiftcardsWrite OauthScope = "GIFTCARDS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Write access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsWrite OauthScope = "ONLINE_STORE_SNIPPETS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsRead OauthScope = "ONLINE_STORE_SNIPPETS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store site details.
	OauthScopeOnlineStoreSiteRead OauthScope = "ONLINE_STORE_SITE_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allows the developer to process payments on behalf of a seller using a shared on file payment method.
	OauthScopePaymentsWriteSharedOnfile OauthScope = "PAYMENTS_WRITE_SHARED_ONFILE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to all of a seller's booking information, calendar, and business details.
	// This permission must be accompanied by the `APPOINTMENTS_READ` permission.
	OauthScopeAppointmentsAllRead OauthScope = "APPOINTMENTS_ALL_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to all booking details, including double-booking a seller.
	// This permission must be accompanied by the `APPOINTMENTS_WRITE` permission.
	OauthScopeAppointmentsAllWrite OauthScope = "APPOINTMENTS_ALL_WRITE"
	// **HTTP Method**: `POST`, `PUT`
	//
	// Grants write access to business and location information. For example, to create a new location or
	// update the business hours at an existing location.
	OauthScopeMerchantProfileWrite OauthScope = "MERCHANT_PROFILE_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to vendor information, for example, when calling the
	// `RetrieveVendor` endpoint.
	OauthScopeVendorRead OauthScope = "VENDOR_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to vendor information, for example, when calling the
	// `BulkUpdateVendors` endpoint.
	OauthScopeVendorWrite OauthScope = "VENDOR_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to payouts and payout entries information. For example,
	// to call the Connect v2 `ListPayouts` endpoint.
	OauthScopePayoutsRead OauthScope = "PAYOUTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to reservation information, for example, when calling the
	// `RetrieveReservation` endpoint.
	OauthScopeReservationsRead OauthScope = "RESERVATIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to reservation information, for example, when calling the
	// `CreateReservation` endpoint.
	OauthScopeReservationsWrite OauthScope = "RESERVATIONS_WRITE"
)

func NewOauthScopeFromString(s string) (OauthScope, error) {
	switch s {
	case "BANK_ACCOUNTS_READ":
		return OauthScopeBankAccountsRead, nil
	case "CASH_DRAWER_READ":
		return OauthScopeCashDrawerRead, nil
	case "CUSTOMERS_READ":
		return OauthScopeCustomersRead, nil
	case "CUSTOMERS_WRITE":
		return OauthScopeCustomersWrite, nil
	case "DEVICE_CREDENTIAL_MANAGEMENT":
		return OauthScopeDeviceCredentialManagement, nil
	case "EMPLOYEES_READ":
		return OauthScopeEmployeesRead, nil
	case "EMPLOYEES_WRITE":
		return OauthScopeEmployeesWrite, nil
	case "INVENTORY_READ":
		return OauthScopeInventoryRead, nil
	case "INVENTORY_WRITE":
		return OauthScopeInventoryWrite, nil
	case "ITEMS_READ":
		return OauthScopeItemsRead, nil
	case "ITEMS_WRITE":
		return OauthScopeItemsWrite, nil
	case "LOYALTY_READ":
		return OauthScopeLoyaltyRead, nil
	case "LOYALTY_WRITE":
		return OauthScopeLoyaltyWrite, nil
	case "MERCHANT_PROFILE_READ":
		return OauthScopeMerchantProfileRead, nil
	case "ORDERS_READ":
		return OauthScopeOrdersRead, nil
	case "ORDERS_WRITE":
		return OauthScopeOrdersWrite, nil
	case "PAYMENTS_READ":
		return OauthScopePaymentsRead, nil
	case "PAYMENTS_WRITE":
		return OauthScopePaymentsWrite, nil
	case "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS":
		return OauthScopePaymentsWriteAdditionalRecipients, nil
	case "PAYMENTS_WRITE_IN_PERSON":
		return OauthScopePaymentsWriteInPerson, nil
	case "SETTLEMENTS_READ":
		return OauthScopeSettlementsRead, nil
	case "TIMECARDS_READ":
		return OauthScopeTimecardsRead, nil
	case "TIMECARDS_WRITE":
		return OauthScopeTimecardsWrite, nil
	case "TIMECARDS_SETTINGS_READ":
		return OauthScopeTimecardsSettingsRead, nil
	case "TIMECARDS_SETTINGS_WRITE":
		return OauthScopeTimecardsSettingsWrite, nil
	case "APPOINTMENTS_READ":
		return OauthScopeAppointmentsRead, nil
	case "APPOINTMENTS_WRITE":
		return OauthScopeAppointmentsWrite, nil
	case "APPOINTMENTS_BUSINESS_SETTINGS_READ":
		return OauthScopeAppointmentsBusinessSettingsRead, nil
	case "INVOICES_READ":
		return OauthScopeInvoicesRead, nil
	case "INVOICES_WRITE":
		return OauthScopeInvoicesWrite, nil
	case "SUBSCRIPTIONS_READ":
		return OauthScopeSubscriptionsRead, nil
	case "SUBSCRIPTIONS_WRITE":
		return OauthScopeSubscriptionsWrite, nil
	case "DISPUTES_READ":
		return OauthScopeDisputesRead, nil
	case "DISPUTES_WRITE":
		return OauthScopeDisputesWrite, nil
	case "GIFTCARDS_READ":
		return OauthScopeGiftcardsRead, nil
	case "GIFTCARDS_WRITE":
		return OauthScopeGiftcardsWrite, nil
	case "ONLINE_STORE_SNIPPETS_WRITE":
		return OauthScopeOnlineStoreSnippetsWrite, nil
	case "ONLINE_STORE_SNIPPETS_READ":
		return OauthScopeOnlineStoreSnippetsRead, nil
	case "ONLINE_STORE_SITE_READ":
		return OauthScopeOnlineStoreSiteRead, nil
	case "PAYMENTS_WRITE_SHARED_ONFILE":
		return OauthScopePaymentsWriteSharedOnfile, nil
	case "APPOINTMENTS_ALL_READ":
		return OauthScopeAppointmentsAllRead, nil
	case "APPOINTMENTS_ALL_WRITE":
		return OauthScopeAppointmentsAllWrite, nil
	case "MERCHANT_PROFILE_WRITE":
		return OauthScopeMerchantProfileWrite, nil
	case "VENDOR_READ":
		return OauthScopeVendorRead, nil
	case "VENDOR_WRITE":
		return OauthScopeVendorWrite, nil
	case "PAYOUTS_READ":
		return OauthScopePayoutsRead, nil
	case "RESERVATIONS_READ":
		return OauthScopeReservationsRead, nil
	case "RESERVATIONS_WRITE":
		return OauthScopeReservationsWrite, nil
	}
	var t OauthScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OauthScope) Ptr() *OauthScope {
	return &o
}

// Contains all information related to a single order to process with Square,
// including line items that specify the products to purchase. `Order` objects also
// include information about any associated tenders, refunds, and returns.
//
// All Connect V2 Transactions have all been converted to Orders including all associated
// itemization data.
type Order struct {
	// The order's unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId string `json:"location_id" url:"location_id"`
	// A client-specified ID to associate an entity in another system
	// with this order.
	ReferenceId *string      `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	Source      *OrderSource `json:"source,omitempty" url:"source,omitempty"`
	// The ID of the [customer](entity:Customer) associated with the order.
	//
	// **IMPORTANT:** You should specify a `customer_id` if you want the corresponding payment transactions
	// to be explicitly linked to the customer in the Seller Dashboard. If this field is omitted, the
	// `customer_id` assigned to any underlying `Payment` objects is ignored and might result in the
	// creation of new [instant profiles](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The line items included in the order.
	LineItems []*OrderLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// The list of all taxes associated with the order.
	//
	// Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an
	// `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes
	// with `ORDER` scope, the server generates an `OrderLineItemAppliedTax` for every line item.
	//
	// On reads, each tax in the list includes the total amount of that tax applied to the order.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any taxes in this field, using the deprecated
	// `line_items.taxes` field results in an error. Use `line_items.applied_taxes`
	// instead.
	Taxes []*OrderLineItemTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// The list of all discounts associated with the order.
	//
	// Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`,
	// an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to.
	// For discounts with `ORDER` scope, the server generates an `OrderLineItemAppliedDiscount`
	// for every line item.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any discounts in this field, using the deprecated
	// `line_items.discounts` field results in an error. Use `line_items.applied_discounts`
	// instead.
	Discounts []*OrderLineItemDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// A list of service charges applied to the order.
	ServiceCharges []*OrderServiceCharge `json:"service_charges,omitempty" url:"service_charges,omitempty"`
	// Details about order fulfillment.
	//
	// Orders can only be created with at most one fulfillment. However, orders returned
	// by the API might contain multiple fulfillments.
	Fulfillments []*OrderFulfillment `json:"fulfillments,omitempty" url:"fulfillments,omitempty"`
	// A collection of items from sale orders being returned in this one. Normally part of an
	// itemized return or exchange. There is exactly one `Return` object per sale `Order` being
	// referenced.
	Returns            []*OrderReturn           `json:"returns,omitempty" url:"returns,omitempty"`
	ReturnAmounts      *OrderMoneyAmounts       `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`
	NetAmounts         *OrderMoneyAmounts       `json:"net_amounts,omitempty" url:"net_amounts,omitempty"`
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// The refunds that are part of this order.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp for when the order reached a terminal [state](entity:OrderState), in RFC 3339 format (for example "2016-09-04T23:59:33.123Z").
	ClosedAt *string     `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	State    *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders).
	Version                 *int   `json:"version,omitempty" url:"version,omitempty"`
	TotalMoney              *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney           *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney      *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalTipMoney           *Money `json:"total_tip_money,omitempty" url:"total_tip_money,omitempty"`
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`
	// A short-term identifier for the order (such as a customer first name,
	// table number, or auto-generated order number that resets daily).
	TicketName     *string              `json:"ticket_name,omitempty" url:"ticket_name,omitempty"`
	PricingOptions *OrderPricingOptions `json:"pricing_options,omitempty" url:"pricing_options,omitempty"`
	// A set-like list of Rewards that have been added to the Order.
	Rewards           []*OrderReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	NetAmountDueMoney *Money         `json:"net_amount_due_money,omitempty" url:"net_amount_due_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type unmarshaler Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Order(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A lightweight description of an [order](entity:Order) that is returned when
// `returned_entries` is `true` on a [SearchOrdersRequest](api-endpoint:Orders-SearchOrders).
type OrderEntry struct {
	// The ID of the order.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The location ID the order belongs to.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains details about how to fulfill this order.
type OrderFulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	Uid                 *string                                         `json:"uid,omitempty" url:"uid,omitempty"`
	Type                *OrderFulfillmentType                           `json:"type,omitempty" url:"type,omitempty"`
	State               *OrderFulfillmentState                          `json:"state,omitempty" url:"state,omitempty"`
	LineItemApplication *OrderFulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	//
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	//
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*OrderFulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata        map[string]string                `json:"metadata,omitempty" url:"metadata,omitempty"`
	PickupDetails   *OrderFulfillmentPickupDetails   `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	ShipmentDetails *OrderFulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type OrderFulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUid string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentFulfillmentEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentFulfillmentEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type OrderFulfillmentFulfillmentLineItemApplication string

const (
	OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication OrderFulfillmentFulfillmentLineItemApplication = "UNKNOWN_APPLICATION"
	OrderFulfillmentFulfillmentLineItemApplicationAll                OrderFulfillmentFulfillmentLineItemApplication = "ALL"
	OrderFulfillmentFulfillmentLineItemApplicationEntryList          OrderFulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewOrderFulfillmentFulfillmentLineItemApplicationFromString(s string) (OrderFulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "UNKNOWN_APPLICATION":
		return OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication, nil
	case "ALL":
		return OrderFulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return OrderFulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t OrderFulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentFulfillmentLineItemApplication) Ptr() *OrderFulfillmentFulfillmentLineItemApplication {
	return &o
}

// Contains details necessary to fulfill a pickup order.
type OrderFulfillmentPickupDetails struct {
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set up to 7 days in the future.
	// If `expires_at` is not set, this pickup fulfillment is automatically accepted when
	// placed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an open and accepted pickup fulfillment
	// is automatically moved to the `COMPLETED` state. The duration must be in RFC 3339
	// format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains accepted until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	//
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Information about the fulfillment recipient.
type OrderFulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	//
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	//
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	//
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	//
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string  `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentRecipient) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the details necessary to fulfill a shipment order.
type OrderFulfillmentShipmentDetails struct {
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingUrl *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentShipmentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentShipmentDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The current state of this fulfillment.
type OrderFulfillmentState string

const (
	OrderFulfillmentStateFulfillmentStateDoNotUse OrderFulfillmentState = "FULFILLMENT_STATE_DO_NOT_USE"
	OrderFulfillmentStateProposed                 OrderFulfillmentState = "PROPOSED"
	OrderFulfillmentStateReserved                 OrderFulfillmentState = "RESERVED"
	OrderFulfillmentStatePrepared                 OrderFulfillmentState = "PREPARED"
	OrderFulfillmentStateCompleted                OrderFulfillmentState = "COMPLETED"
	OrderFulfillmentStateCanceled                 OrderFulfillmentState = "CANCELED"
	OrderFulfillmentStateFailed                   OrderFulfillmentState = "FAILED"
)

func NewOrderFulfillmentStateFromString(s string) (OrderFulfillmentState, error) {
	switch s {
	case "FULFILLMENT_STATE_DO_NOT_USE":
		return OrderFulfillmentStateFulfillmentStateDoNotUse, nil
	case "PROPOSED":
		return OrderFulfillmentStateProposed, nil
	case "RESERVED":
		return OrderFulfillmentStateReserved, nil
	case "PREPARED":
		return OrderFulfillmentStatePrepared, nil
	case "COMPLETED":
		return OrderFulfillmentStateCompleted, nil
	case "CANCELED":
		return OrderFulfillmentStateCanceled, nil
	case "FAILED":
		return OrderFulfillmentStateFailed, nil
	}
	var t OrderFulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentState) Ptr() *OrderFulfillmentState {
	return &o
}

// The type of fulfillment.
type OrderFulfillmentType string

const (
	OrderFulfillmentTypeFulfillmentTypeDoNotUse OrderFulfillmentType = "FULFILLMENT_TYPE_DO_NOT_USE"
	OrderFulfillmentTypeCustom                  OrderFulfillmentType = "CUSTOM"
	OrderFulfillmentTypePickup                  OrderFulfillmentType = "PICKUP"
	OrderFulfillmentTypeManagedDelivery         OrderFulfillmentType = "MANAGED_DELIVERY"
	OrderFulfillmentTypeShipment                OrderFulfillmentType = "SHIPMENT"
	OrderFulfillmentTypeDigital                 OrderFulfillmentType = "DIGITAL"
	OrderFulfillmentTypeDelivery                OrderFulfillmentType = "DELIVERY"
	OrderFulfillmentTypeSimple                  OrderFulfillmentType = "SIMPLE"
)

func NewOrderFulfillmentTypeFromString(s string) (OrderFulfillmentType, error) {
	switch s {
	case "FULFILLMENT_TYPE_DO_NOT_USE":
		return OrderFulfillmentTypeFulfillmentTypeDoNotUse, nil
	case "CUSTOM":
		return OrderFulfillmentTypeCustom, nil
	case "PICKUP":
		return OrderFulfillmentTypePickup, nil
	case "MANAGED_DELIVERY":
		return OrderFulfillmentTypeManagedDelivery, nil
	case "SHIPMENT":
		return OrderFulfillmentTypeShipment, nil
	case "DIGITAL":
		return OrderFulfillmentTypeDigital, nil
	case "DELIVERY":
		return OrderFulfillmentTypeDelivery, nil
	case "SIMPLE":
		return OrderFulfillmentTypeSimple, nil
	}
	var t OrderFulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentType) Ptr() *OrderFulfillmentType {
	return &o
}

// Represents a line item in an order. Each line item describes a different
// product to purchase, with its own quantity and price details.
type OrderLineItem struct {
	// A unique ID that identifies the line item only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity purchased, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a quantity of `"0"` are automatically removed
	// when paying for or otherwise completing the order.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity     string             `json:"quantity" url:"quantity"`
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this line item.
	VariationName *string                `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	ItemType      *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// Application-defined data attached to this line item. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	Modifiers []*OrderLineItemModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The list of references to taxes applied to this line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a
	// top-level `OrderLineItemTax` applied to the line item. On reads, the
	// amount applied is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every line
	// item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax`
	// records for `LINE_ITEM` scoped taxes must be added in requests for the tax
	// to apply to any line items.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to discounts applied to this line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderLineItemDiscounts` applied to the line item. On reads, the amount
	// applied is populated.
	//
	// An `OrderLineItemAppliedDiscount` is automatically created on every line item for all
	// `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records
	// for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any
	// line items.
	//
	// To change the amount of a discount, modify the referenced top-level discount.
	AppliedDiscounts         []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	BasePriceMoney           *Money                          `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	VariationTotalPriceMoney *Money                          `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	GrossSalesMoney          *Money                          `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	TotalTaxMoney            *Money                          `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney       *Money                          `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalMoney               *Money                          `json:"total_money,omitempty" url:"total_money,omitempty"`
	PricingBlocklists        *OrderLineItemPricingBlocklists `json:"pricing_blocklists,omitempty" url:"pricing_blocklists,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a discount to a line item in an order.
//
// Order scoped discounts have automatically applied discounts present for each line item.
// Line-item scoped discounts must have applied discounts added manually for any applicable line
// items. The corresponding applied money is automatically computed based on participating
// line items.
type OrderLineItemAppliedDiscount struct {
	// A unique ID that identifies the applied discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that the applied discount represents. It must
	// reference a discount present in the `order.discounts` field.
	//
	// This field is immutable. To change which discounts apply to a line item,
	// you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
	DiscountUid  string `json:"discount_uid" url:"discount_uid"`
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a tax to a line item in an order.
//
// Order-scoped taxes automatically include the applied taxes in each line item.
// Line item taxes must be referenced from any applicable line items.
// The corresponding applied money is automatically computed, based on the
// set of participating line items.
type OrderLineItemAppliedTax struct {
	// A unique ID that identifies the applied tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax for which this applied tax represents. It must reference
	// a tax present in the `order.taxes` field.
	//
	// This field is immutable. To change which taxes apply to a line item, delete and add a new
	// `OrderLineItemAppliedTax`.
	TaxUid       string `json:"tax_uid" url:"tax_uid"`
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount that applies to one or more line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the
// amount contributed by the item to the order subtotal.
type OrderLineItemDiscount struct {
	// A unique ID that identifies the discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string                    `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the discount, as a string representation of a decimal number.
	// A value of `7.25` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage   *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney  *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney *Money  `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Application-defined data attached to this discount. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string           `json:"metadata,omitempty" url:"metadata,omitempty"`
	Scope    *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`
	// The reward IDs corresponding to this discount. The application and
	// specification of discounts that have `reward_ids` are completely controlled by the backing
	// criteria corresponding to the reward tiers of the rewards that are added to the order
	// through the Loyalty API. To manually unapply discounts that are the result of added rewards,
	// the rewards must be removed from the order through the Loyalty API.
	RewardIds []string `json:"reward_ids,omitempty" url:"reward_ids,omitempty"`
	// The object ID of a [pricing rule](entity:CatalogPricingRule) to be applied
	// automatically to this discount. The specification and application of the discounts, to
	// which a `pricing_rule_id` is assigned, are completely controlled by the corresponding
	// pricing rule.
	PricingRuleId *string `json:"pricing_rule_id,omitempty" url:"pricing_rule_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level discount.
type OrderLineItemDiscountScope string

const (
	OrderLineItemDiscountScopeOtherDiscountScope OrderLineItemDiscountScope = "OTHER_DISCOUNT_SCOPE"
	OrderLineItemDiscountScopeLineItem           OrderLineItemDiscountScope = "LINE_ITEM"
	OrderLineItemDiscountScopeOrder              OrderLineItemDiscountScope = "ORDER"
)

func NewOrderLineItemDiscountScopeFromString(s string) (OrderLineItemDiscountScope, error) {
	switch s {
	case "OTHER_DISCOUNT_SCOPE":
		return OrderLineItemDiscountScopeOtherDiscountScope, nil
	case "LINE_ITEM":
		return OrderLineItemDiscountScopeLineItem, nil
	case "ORDER":
		return OrderLineItemDiscountScopeOrder, nil
	}
	var t OrderLineItemDiscountScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountScope) Ptr() *OrderLineItemDiscountScope {
	return &o
}

// Indicates how the discount is applied to the associated line item or order.
type OrderLineItemDiscountType string

const (
	OrderLineItemDiscountTypeUnknownDiscount    OrderLineItemDiscountType = "UNKNOWN_DISCOUNT"
	OrderLineItemDiscountTypeFixedPercentage    OrderLineItemDiscountType = "FIXED_PERCENTAGE"
	OrderLineItemDiscountTypeFixedAmount        OrderLineItemDiscountType = "FIXED_AMOUNT"
	OrderLineItemDiscountTypeVariablePercentage OrderLineItemDiscountType = "VARIABLE_PERCENTAGE"
	OrderLineItemDiscountTypeVariableAmount     OrderLineItemDiscountType = "VARIABLE_AMOUNT"
)

func NewOrderLineItemDiscountTypeFromString(s string) (OrderLineItemDiscountType, error) {
	switch s {
	case "UNKNOWN_DISCOUNT":
		return OrderLineItemDiscountTypeUnknownDiscount, nil
	case "FIXED_PERCENTAGE":
		return OrderLineItemDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return OrderLineItemDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return OrderLineItemDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return OrderLineItemDiscountTypeVariableAmount, nil
	}
	var t OrderLineItemDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountType) Ptr() *OrderLineItemDiscountType {
	return &o
}

// Represents the line item type.
type OrderLineItemItemType string

const (
	OrderLineItemItemTypeDoNotUse     OrderLineItemItemType = "DO_NOT_USE"
	OrderLineItemItemTypeItem         OrderLineItemItemType = "ITEM"
	OrderLineItemItemTypeCustomAmount OrderLineItemItemType = "CUSTOM_AMOUNT"
	OrderLineItemItemTypeGiftCard     OrderLineItemItemType = "GIFT_CARD"
)

func NewOrderLineItemItemTypeFromString(s string) (OrderLineItemItemType, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderLineItemItemTypeDoNotUse, nil
	case "ITEM":
		return OrderLineItemItemTypeItem, nil
	case "CUSTOM_AMOUNT":
		return OrderLineItemItemTypeCustomAmount, nil
	case "GIFT_CARD":
		return OrderLineItemItemTypeGiftCard, nil
	}
	var t OrderLineItemItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemItemType) Ptr() *OrderLineItemItemType {
	return &o
}

// A [CatalogModifier](entity:CatalogModifier).
type OrderLineItemModifier struct {
	// A unique ID that identifies the modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity        *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	BasePriceMoney  *Money  `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	TotalPriceMoney *Money  `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes pricing adjustments that are blocked from manual and
// automatic application to a line item. For more information, see
// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
type OrderLineItemPricingBlocklists struct {
	// A list of discounts blocked from applying to the line item.
	// Discounts can be blocked by the `discount_uid` (for ad hoc discounts) or
	// the `discount_catalog_object_id` (for catalog discounts).
	BlockedDiscounts []*OrderLineItemPricingBlocklistsBlockedDiscount `json:"blocked_discounts,omitempty" url:"blocked_discounts,omitempty"`
	// A list of taxes blocked from applying to the line item.
	// Taxes can be blocked by the `tax_uid` (for ad hoc taxes) or
	// the `tax_catalog_object_id` (for catalog taxes).
	BlockedTaxes []*OrderLineItemPricingBlocklistsBlockedTax `json:"blocked_taxes,omitempty" url:"blocked_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklists) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklists) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklists(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklists) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A discount to block from applying to a line item. The discount must be
// identified by either `discount_uid` or `discount_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedDiscount struct {
	// A unique ID of the `BlockedDiscount` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that should be blocked. Use this field to block
	// ad hoc discounts. For catalog discounts, use the `discount_catalog_object_id` field.
	DiscountUid *string `json:"discount_uid,omitempty" url:"discount_uid,omitempty"`
	// The `catalog_object_id` of the discount that should be blocked.
	// Use this field to block catalog discounts. For ad hoc discounts, use the
	// `discount_uid` field.
	DiscountCatalogObjectId *string `json:"discount_catalog_object_id,omitempty" url:"discount_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tax to block from applying to a line item. The tax must be
// identified by either `tax_uid` or `tax_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedTax struct {
	// A unique ID of the `BlockedTax` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax that should be blocked. Use this field to block
	// ad hoc taxes. For catalog, taxes use the `tax_catalog_object_id` field.
	TaxUid *string `json:"tax_uid,omitempty" url:"tax_uid,omitempty"`
	// The `catalog_object_id` of the tax that should be blocked.
	// Use this field to block catalog taxes. For ad hoc taxes, use the
	// `tax_uid` field.
	TaxCatalogObjectId *string `json:"tax_catalog_object_id,omitempty" url:"tax_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax that applies to one or more line item in the order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the amount the item
// contributes to the order subtotal.
type OrderLineItemTax struct {
	// A unique ID that identifies the tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string               `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal
	// number. For example, a value of `"7.25"` corresponds to a percentage of
	// 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Application-defined data attached to this tax. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata     map[string]string      `json:"metadata,omitempty" url:"metadata,omitempty"`
	AppliedMoney *Money                 `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`
	// Determines whether the tax was automatically applied to the order based on
	// the catalog configuration. For an example, see
	// [Automatically Apply Taxes to an Order](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts/auto-apply-taxes).
	AutoApplied *bool `json:"auto_applied,omitempty" url:"auto_applied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level tax.
type OrderLineItemTaxScope string

const (
	OrderLineItemTaxScopeOtherTaxScope OrderLineItemTaxScope = "OTHER_TAX_SCOPE"
	OrderLineItemTaxScopeLineItem      OrderLineItemTaxScope = "LINE_ITEM"
	OrderLineItemTaxScopeOrder         OrderLineItemTaxScope = "ORDER"
)

func NewOrderLineItemTaxScopeFromString(s string) (OrderLineItemTaxScope, error) {
	switch s {
	case "OTHER_TAX_SCOPE":
		return OrderLineItemTaxScopeOtherTaxScope, nil
	case "LINE_ITEM":
		return OrderLineItemTaxScopeLineItem, nil
	case "ORDER":
		return OrderLineItemTaxScopeOrder, nil
	}
	var t OrderLineItemTaxScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxScope) Ptr() *OrderLineItemTaxScope {
	return &o
}

// Indicates how the tax is applied to the associated line item or order.
type OrderLineItemTaxType string

const (
	OrderLineItemTaxTypeUnknownTax OrderLineItemTaxType = "UNKNOWN_TAX"
	OrderLineItemTaxTypeAdditive   OrderLineItemTaxType = "ADDITIVE"
	OrderLineItemTaxTypeInclusive  OrderLineItemTaxType = "INCLUSIVE"
)

func NewOrderLineItemTaxTypeFromString(s string) (OrderLineItemTaxType, error) {
	switch s {
	case "UNKNOWN_TAX":
		return OrderLineItemTaxTypeUnknownTax, nil
	case "ADDITIVE":
		return OrderLineItemTaxTypeAdditive, nil
	case "INCLUSIVE":
		return OrderLineItemTaxTypeInclusive, nil
	}
	var t OrderLineItemTaxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxType) Ptr() *OrderLineItemTaxType {
	return &o
}

// A collection of various money amounts.
type OrderMoneyAmounts struct {
	TotalMoney         *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	TaxMoney           *Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	DiscountMoney      *Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	TipMoney           *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	ServiceChargeMoney *Money `json:"service_charge_money,omitempty" url:"service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderMoneyAmounts) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderMoneyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderMoneyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderMoneyAmounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderMoneyAmounts) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Pricing options for an order. The options affect how the order's price is calculated.
// They can be used, for example, to apply automatic price adjustments that are based on preconfigured
// [pricing rules](entity:CatalogPricingRule).
type OrderPricingOptions struct {
	// The option to determine whether pricing rule-based
	// discounts are automatically applied to an order.
	AutoApplyDiscounts *bool `json:"auto_apply_discounts,omitempty" url:"auto_apply_discounts,omitempty"`
	// The option to determine whether rule-based taxes are automatically
	// applied to an order when the criteria of the corresponding rules are met.
	AutoApplyTaxes *bool `json:"auto_apply_taxes,omitempty" url:"auto_apply_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderPricingOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderPricingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderPricingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderPricingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderPricingOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the measurement unit for a quantity and a precision that
// specifies the number of digits after the decimal point for decimal quantities.
type OrderQuantityUnit struct {
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// For non-integer quantities, represents the number of digits after the decimal point that are
	// recorded for this quantity.
	//
	// For example, a precision of 1 allows quantities such as `"1.0"` and `"1.1"`, but not `"1.01"`.
	//
	// Min: 0. Max: 5.
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`
	// The catalog object ID referencing the
	// [CatalogMeasurementUnit](entity:CatalogMeasurementUnit).
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this measurement unit references.
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderQuantityUnit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderQuantityUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderQuantityUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderQuantityUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderQuantityUnit) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The set of line items, service charges, taxes, discounts, tips, and other items being returned in an order.
type OrderReturn struct {
	// A unique ID that identifies the return only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An order that contains the original sale of these return line items. This is unset
	// for unlinked returns.
	SourceOrderId *string `json:"source_order_id,omitempty" url:"source_order_id,omitempty"`
	// A collection of line items that are being returned.
	ReturnLineItems []*OrderReturnLineItem `json:"return_line_items,omitempty" url:"return_line_items,omitempty"`
	// A collection of service charges that are being returned.
	ReturnServiceCharges []*OrderReturnServiceCharge `json:"return_service_charges,omitempty" url:"return_service_charges,omitempty"`
	// A collection of references to taxes being returned for an order, including the total
	// applied tax amount to be returned. The taxes must reference a top-level tax ID from the source
	// order.
	ReturnTaxes []*OrderReturnTax `json:"return_taxes,omitempty" url:"return_taxes,omitempty"`
	// A collection of references to discounts being returned for an order, including the total
	// applied discount amount to be returned. The discounts must reference a top-level discount ID
	// from the source order.
	ReturnDiscounts    []*OrderReturnDiscount   `json:"return_discounts,omitempty" url:"return_discounts,omitempty"`
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	ReturnAmounts      *OrderMoneyAmounts       `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturn) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturn) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturn(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturn) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount being returned that applies to one or more return line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnDiscount struct {
	// A unique ID that identifies the returned discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The discount `uid` from the order that contains the original application of this discount.
	SourceDiscountUid *string `json:"source_discount_uid,omitempty" url:"source_discount_uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string                    `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// A value of `"7.25"` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage   *string                     `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney  *Money                      `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney *Money                      `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The line item being returned in an order.
type OrderReturnLineItem struct {
	// A unique ID for this return line-item entry.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the line item in the original sale order.
	SourceLineItemUid *string `json:"source_line_item_uid,omitempty" url:"source_line_item_uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity returned, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity     string             `json:"quantity" url:"quantity"`
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the return line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this return line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this return line item.
	VariationName *string                `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	ItemType      *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	ReturnModifiers []*OrderReturnLineItemModifier `json:"return_modifiers,omitempty" url:"return_modifiers,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the return line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderReturnTax` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to `OrderReturnDiscount` entities applied to the return line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderReturnDiscount` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedDiscounts         []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	BasePriceMoney           *Money                          `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	VariationTotalPriceMoney *Money                          `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	GrossReturnMoney         *Money                          `json:"gross_return_money,omitempty" url:"gross_return_money,omitempty"`
	TotalTaxMoney            *Money                          `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney       *Money                          `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalMoney               *Money                          `json:"total_money,omitempty" url:"total_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A line item modifier being returned.
type OrderReturnLineItemModifier struct {
	// A unique ID that identifies the return modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The modifier `uid` from the order's line item that contains the
	// original sale of this line item modifier.
	SourceModifierUid *string `json:"source_modifier_uid,omitempty" url:"source_modifier_uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name            *string `json:"name,omitempty" url:"name,omitempty"`
	BasePriceMoney  *Money  `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	TotalPriceMoney *Money  `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents the service charge applied to the original order.
type OrderReturnServiceCharge struct {
	// A unique ID that identifies the return service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The service charge `uid` from the order containing the original
	// service charge. `source_service_charge_uid` is `null` for
	// unlinked returns.
	SourceServiceChargeUid *string `json:"source_service_charge_uid,omitempty" url:"source_service_charge_uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID of the associated [OrderServiceCharge](entity:OrderServiceCharge).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The percentage of the service charge, as a string representation of
	// a decimal number. For example, a value of `"7.25"` corresponds to a
	// percentage of 7.25%.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	Percentage       *string                             `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney      *Money                              `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney     *Money                              `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	TotalMoney       *Money                              `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney    *Money                              `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the surcharge can be taxed. Service charges
	// calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the
	// `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid`
	// that references the `uid` of a top-level `OrderReturnTax` that is being
	// applied to the `OrderReturnServiceCharge`. On reads, the applied amount is
	// populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax being returned that applies to one or more return line items in an order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnTax struct {
	// A unique ID that identifies the returned tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The tax `uid` from the order that contains the original tax charge.
	SourceTaxUid *string `json:"source_tax_uid,omitempty" url:"source_tax_uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string               `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// For example, a value of `"7.25"` corresponds to a percentage of 7.25%.
	Percentage   *string                `json:"percentage,omitempty" url:"percentage,omitempty"`
	AppliedMoney *Money                 `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a reward that can be applied to an order if the necessary
// reward tier criteria are met. Rewards are created through the Loyalty API.
type OrderReward struct {
	// The identifier of the reward.
	Id string `json:"id" url:"id"`
	// The identifier of the reward tier corresponding to this reward.
	RewardTierId string `json:"reward_tier_id" url:"reward_tier_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReward) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReward) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReward) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A rounding adjustment of the money being returned. Commonly used to apply cash rounding
// when the minimum unit of the account is smaller than the lowest physical denomination of the currency.
type OrderRoundingAdjustment struct {
	// A unique ID that identifies the rounding adjustment only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the rounding adjustment from the original sale order.
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderRoundingAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderRoundingAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderRoundingAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderRoundingAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderRoundingAdjustment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a service charge applied to an order.
type OrderServiceCharge struct {
	// A unique ID that identifies the service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID referencing the service charge [CatalogObject](entity:CatalogObject).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The service charge percentage as a string representation of a
	// decimal number. For example, `"7.25"` indicates a service charge of 7.25%.
	//
	// Exactly 1 of `percentage` or `amount_money` should be set.
	Percentage       *string                             `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney      *Money                              `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney     *Money                              `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	TotalMoney       *Money                              `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney    *Money                              `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the service charge can be taxed. If set to `true`,
	// order-level taxes automatically apply to the service charge. Note that
	// service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to the taxes applied to this service charge. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied
	// is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every taxable service charge
	// for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records
	// for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable
	// service charge. Taxable service charges have the `taxable` field set to `true` and calculated
	// in the `SUBTOTAL_PHASE`.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// Application-defined data attached to this service charge. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string       `json:"metadata,omitempty" url:"metadata,omitempty"`
	Type     *OrderServiceChargeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a phase in the process of calculating order totals.
// Service charges are applied after the indicated phase.
//
// [Read more about how order totals are calculated.](https://developer.squareup.com/docs/orders-api/how-it-works#how-totals-are-calculated)
type OrderServiceChargeCalculationPhase string

const (
	OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse OrderServiceChargeCalculationPhase = "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE"
	OrderServiceChargeCalculationPhaseSubtotalPhase                         OrderServiceChargeCalculationPhase = "SUBTOTAL_PHASE"
	OrderServiceChargeCalculationPhaseTotalPhase                            OrderServiceChargeCalculationPhase = "TOTAL_PHASE"
	OrderServiceChargeCalculationPhaseApportionedPercentagePhase            OrderServiceChargeCalculationPhase = "APPORTIONED_PERCENTAGE_PHASE"
	OrderServiceChargeCalculationPhaseApportionedAmountPhase                OrderServiceChargeCalculationPhase = "APPORTIONED_AMOUNT_PHASE"
)

func NewOrderServiceChargeCalculationPhaseFromString(s string) (OrderServiceChargeCalculationPhase, error) {
	switch s {
	case "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE":
		return OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse, nil
	case "SUBTOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseSubtotalPhase, nil
	case "TOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseTotalPhase, nil
	case "APPORTIONED_PERCENTAGE_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedPercentagePhase, nil
	case "APPORTIONED_AMOUNT_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedAmountPhase, nil
	}
	var t OrderServiceChargeCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeCalculationPhase) Ptr() *OrderServiceChargeCalculationPhase {
	return &o
}

type OrderServiceChargeType string

const (
	OrderServiceChargeTypeServiceChargeTypeDoNotUse OrderServiceChargeType = "SERVICE_CHARGE_TYPE_DO_NOT_USE"
	OrderServiceChargeTypeAutoGratuity              OrderServiceChargeType = "AUTO_GRATUITY"
	OrderServiceChargeTypeCustom                    OrderServiceChargeType = "CUSTOM"
)

func NewOrderServiceChargeTypeFromString(s string) (OrderServiceChargeType, error) {
	switch s {
	case "SERVICE_CHARGE_TYPE_DO_NOT_USE":
		return OrderServiceChargeTypeServiceChargeTypeDoNotUse, nil
	case "AUTO_GRATUITY":
		return OrderServiceChargeTypeAutoGratuity, nil
	case "CUSTOM":
		return OrderServiceChargeTypeCustom, nil
	}
	var t OrderServiceChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeType) Ptr() *OrderServiceChargeType {
	return &o
}

// Represents the origination details of an order.
type OrderSource struct {
	// The name used to identify the place (physical or digital) that an order originates.
	// If unset, the name defaults to the name of the application that created the order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSource) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSource) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSource) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The state of the order.
type OrderState string

const (
	OrderStateDoNotUse  OrderState = "DO_NOT_USE"
	OrderStateOpen      OrderState = "OPEN"
	OrderStateCompleted OrderState = "COMPLETED"
	OrderStateCanceled  OrderState = "CANCELED"
	OrderStateDraft     OrderState = "DRAFT"
)

func NewOrderStateFromString(s string) (OrderState, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderStateDoNotUse, nil
	case "OPEN":
		return OrderStateOpen, nil
	case "COMPLETED":
		return OrderStateCompleted, nil
	case "CANCELED":
		return OrderStateCanceled, nil
	case "DRAFT":
		return OrderStateDraft, nil
	}
	var t OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderState) Ptr() *OrderState {
	return &o
}

// Represents a refund of a payment made using Square. Contains information about
// the original payment and the amount of money refunded.
type PaymentRefund struct {
	// The unique ID for this refund, generated by Square.
	Id string `json:"id" url:"id"`
	// The refund's status:
	//
	// - `PENDING` - Awaiting approval.
	// - `COMPLETED` - Successfully completed.
	// - `REJECTED` - The refund was rejected.
	// - `FAILED` - An error occurred.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The location ID associated with the payment this refund is attached to.
	LocationId  *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppFeeMoney *Money  `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Processing fees and fee adjustments assessed by Square for this refund.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	// The ID of the payment associated with this refund.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the order associated with the refund.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The reason for the refund.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The timestamp of when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the refund was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional ID of the team member associated with taking the payment.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRefund) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRefund) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An accounting of the amount owed the seller and record of the actual transfer to their
// external bank account or to the Square balance.
type Payout struct {
	// A unique ID for the payout.
	Id     string        `json:"id" url:"id"`
	Status *PayoutStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the location associated with the payout.
	LocationId string `json:"location_id" url:"location_id"`
	// The timestamp of when the payout was created and submitted for deposit to the seller's banking destination, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payout was last updated, in RFC 3339 format.
	UpdatedAt   *string      `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	AmountMoney *Money       `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	Destination *Destination `json:"destination,omitempty" url:"destination,omitempty"`
	// The version number, which is incremented each time an update is made to this payout record.
	// The version number helps developers receive event notifications or feeds out of order.
	Version *int        `json:"version,omitempty" url:"version,omitempty"`
	Type    *PayoutType `json:"type,omitempty" url:"type,omitempty"`
	// A list of transfer fees and any taxes on the fees assessed by Square for this payout.
	PayoutFee []*PayoutFee `json:"payout_fee,omitempty" url:"payout_fee,omitempty"`
	// The calendar date, in ISO 8601 format (YYYY-MM-DD), when the payout is due to arrive in the seller’s banking destination.
	ArrivalDate *string `json:"arrival_date,omitempty" url:"arrival_date,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payout) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payout) UnmarshalJSON(data []byte) error {
	type unmarshaler Payout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payout) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a payout fee that can incur as part of a payout.
type PayoutFee struct {
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string        `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	Type        *PayoutFeeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFee) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the type of payout fee that can incur as part of a payout.
type PayoutFeeType string

const (
	PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse PayoutFeeType = "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE"
	PayoutFeeTypeTransferFee                  PayoutFeeType = "TRANSFER_FEE"
	PayoutFeeTypeTaxOnTransferFee             PayoutFeeType = "TAX_ON_TRANSFER_FEE"
)

func NewPayoutFeeTypeFromString(s string) (PayoutFeeType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE":
		return PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse, nil
	case "TRANSFER_FEE":
		return PayoutFeeTypeTransferFee, nil
	case "TAX_ON_TRANSFER_FEE":
		return PayoutFeeTypeTaxOnTransferFee, nil
	}
	var t PayoutFeeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutFeeType) Ptr() *PayoutFeeType {
	return &p
}

// Payout status types
type PayoutStatus string

const (
	PayoutStatusUnknownPayoutStatusDoNotUse PayoutStatus = "UNKNOWN_PAYOUT_STATUS_DO_NOT_USE"
	PayoutStatusSent                        PayoutStatus = "SENT"
	PayoutStatusFailed                      PayoutStatus = "FAILED"
	PayoutStatusPaid                        PayoutStatus = "PAID"
)

func NewPayoutStatusFromString(s string) (PayoutStatus, error) {
	switch s {
	case "UNKNOWN_PAYOUT_STATUS_DO_NOT_USE":
		return PayoutStatusUnknownPayoutStatusDoNotUse, nil
	case "SENT":
		return PayoutStatusSent, nil
	case "FAILED":
		return PayoutStatusFailed, nil
	case "PAID":
		return PayoutStatusPaid, nil
	}
	var t PayoutStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutStatus) Ptr() *PayoutStatus {
	return &p
}

// The type of payout: “BATCH” or “SIMPLE”.
// BATCH payouts include a list of payout entries that can be considered settled.
// SIMPLE payouts do not have any payout entries associated with them
// and will show up as one of the payout entries in a future BATCH payout.
type PayoutType string

const (
	PayoutTypeUnknownPayoutTypeDoNotUse PayoutType = "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE"
	PayoutTypeBatch                     PayoutType = "BATCH"
	PayoutTypeSimple                    PayoutType = "SIMPLE"
)

func NewPayoutTypeFromString(s string) (PayoutType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE":
		return PayoutTypeUnknownPayoutTypeDoNotUse, nil
	case "BATCH":
		return PayoutTypeBatch, nil
	case "SIMPLE":
		return PayoutTypeSimple, nil
	}
	var t PayoutType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutType) Ptr() *PayoutType {
	return &p
}

// Represents the Square processing fee.
type ProcessingFee struct {
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed or adjusted. The fee type can be `INITIAL` or `ADJUSTMENT`.
	Type        *string `json:"type,omitempty" url:"type,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProcessingFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a refund processed for a Square transaction.
type Refund struct {
	// The refund's unique ID.
	Id string `json:"id" url:"id"`
	// The ID of the refund's associated location.
	LocationId string `json:"location_id" url:"location_id"`
	// The ID of the transaction that the refunded tender is part of.
	TransactionId *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The ID of the refunded tender.
	TenderId string `json:"tender_id" url:"tender_id"`
	// The timestamp for when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The reason for the refund being issued.
	Reason             string       `json:"reason" url:"reason"`
	AmountMoney        *Money       `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	Status             RefundStatus `json:"status" url:"status"`
	ProcessingFeeMoney *Money       `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this refund.
	// For example, fees assessed on a refund of a purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Refund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Refund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Refund) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the response returned by
// [RefundPayment](api-endpoint:Refunds-RefundPayment).
//
// If there are errors processing the request, the `refund` field might not be
// present, or it might be present with a status of `FAILED`.
type RefundPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error       `json:"errors,omitempty" url:"errors,omitempty"`
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundPaymentResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundPaymentResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates a refund's current status.
type RefundStatus string

const (
	RefundStatusPending  RefundStatus = "PENDING"
	RefundStatusApproved RefundStatus = "APPROVED"
	RefundStatusRejected RefundStatus = "REJECTED"
	RefundStatusFailed   RefundStatus = "FAILED"
)

func NewRefundStatusFromString(s string) (RefundStatus, error) {
	switch s {
	case "PENDING":
		return RefundStatusPending, nil
	case "APPROVED":
		return RefundStatusApproved, nil
	case "REJECTED":
		return RefundStatusRejected, nil
	case "FAILED":
		return RefundStatusFailed, nil
	}
	var t RefundStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundStatus) Ptr() *RefundStatus {
	return &r
}

// The response object returned by the [RetrieveMerchant](api-endpoint:Merchants-RetrieveMerchant) endpoint.
type RetrieveMerchantResponse struct {
	// Information on errors encountered during the request.
	Errors   []*Error  `json:"errors,omitempty" url:"errors,omitempty"`
	Merchant *Merchant `json:"merchant,omitempty" url:"merchant,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveOrderResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// A filter based on the order `customer_id` and any tender `customer_id`
// associated with the order. It does not filter based on the
// [FulfillmentRecipient](entity:OrderFulfillmentRecipient) `customer_id`.
type SearchOrdersCustomerFilter struct {
	// A list of customer IDs to filter by.
	//
	// Max: 10 customer IDs.
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersCustomerFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersCustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersCustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersCustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersCustomerFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter for `Order` objects based on whether their `CREATED_AT`,
// `CLOSED_AT`, or `UPDATED_AT` timestamps fall within a specified time range.
// You can specify the time range and which timestamp to filter for. You can filter
// for only one time range at a time.
//
// For each time range, the start time and end time are inclusive. If the end time
// is absent, it defaults to the time of the first request for the cursor.
//
// **Important:** If you use the `DateTimeFilter` in a `SearchOrders` query,
// you must set the `sort_field` in [OrdersSort](entity:SearchOrdersSort)
// to the same field you filter for. For example, if you set the `CLOSED_AT` field
// in `DateTimeFilter`, you must set the `sort_field` in `SearchOrdersSort` to
// `CLOSED_AT`. Otherwise, `SearchOrders` throws an error.
// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range)
type SearchOrdersDateTimeFilter struct {
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	ClosedAt  *TimeRange `json:"closed_at,omitempty" url:"closed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersDateTimeFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filtering criteria to use for a `SearchOrders` request. Multiple filters
// are ANDed together.
type SearchOrdersFilter struct {
	StateFilter       *SearchOrdersStateFilter       `json:"state_filter,omitempty" url:"state_filter,omitempty"`
	DateTimeFilter    *SearchOrdersDateTimeFilter    `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	FulfillmentFilter *SearchOrdersFulfillmentFilter `json:"fulfillment_filter,omitempty" url:"fulfillment_filter,omitempty"`
	SourceFilter      *SearchOrdersSourceFilter      `json:"source_filter,omitempty" url:"source_filter,omitempty"`
	CustomerFilter    *SearchOrdersCustomerFilter    `json:"customer_filter,omitempty" url:"customer_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter based on [order fulfillment](entity:OrderFulfillment) information.
type SearchOrdersFulfillmentFilter struct {
	// A list of [fulfillment types](entity:OrderFulfillmentType) to filter
	// for. The list returns orders if any of its fulfillments match any of the fulfillment types
	// listed in this field.
	// See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
	FulfillmentTypes []OrderFulfillmentType `json:"fulfillment_types,omitempty" url:"fulfillment_types,omitempty"`
	// A list of [fulfillment states](entity:OrderFulfillmentState) to filter
	// for. The list returns orders if any of its fulfillments match any of the
	// fulfillment states listed in this field.
	// See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
	FulfillmentStates []OrderFulfillmentState `json:"fulfillment_states,omitempty" url:"fulfillment_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFulfillmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFulfillmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFulfillmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFulfillmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFulfillmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains query criteria for the search.
type SearchOrdersQuery struct {
	Filter *SearchOrdersFilter `json:"filter,omitempty" url:"filter,omitempty"`
	Sort   *SearchOrdersSort   `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Either the `order_entries` or `orders` field is set, depending on whether
// `return_entries` is set on the [SearchOrdersRequest](api-endpoint:Orders-SearchOrders).
type SearchOrdersResponse struct {
	// A list of [OrderEntries](entity:OrderEntry) that fit the query
	// conditions. The list is populated only if `return_entries` is set to `true` in the request.
	OrderEntries []*OrderEntry `json:"order_entries,omitempty" url:"order_entries,omitempty"`
	// A list of
	// [Order](entity:Order) objects that match the query conditions. The list is populated only if
	// `return_entries` is set to `false` in the request.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// [Errors](entity:Error) encountered during the search.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sorting criteria for a `SearchOrders` request. Results can only be sorted
// by a timestamp field.
type SearchOrdersSort struct {
	SortField SearchOrdersSortField `json:"sort_field" url:"sort_field"`
	SortOrder *SortOrder            `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies which timestamp to use to sort `SearchOrder` results.
type SearchOrdersSortField string

const (
	SearchOrdersSortFieldDoNotUse  SearchOrdersSortField = "DO_NOT_USE"
	SearchOrdersSortFieldCreatedAt SearchOrdersSortField = "CREATED_AT"
	SearchOrdersSortFieldUpdatedAt SearchOrdersSortField = "UPDATED_AT"
	SearchOrdersSortFieldClosedAt  SearchOrdersSortField = "CLOSED_AT"
)

func NewSearchOrdersSortFieldFromString(s string) (SearchOrdersSortField, error) {
	switch s {
	case "DO_NOT_USE":
		return SearchOrdersSortFieldDoNotUse, nil
	case "CREATED_AT":
		return SearchOrdersSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return SearchOrdersSortFieldUpdatedAt, nil
	case "CLOSED_AT":
		return SearchOrdersSortFieldClosedAt, nil
	}
	var t SearchOrdersSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchOrdersSortField) Ptr() *SearchOrdersSortField {
	return &s
}

// A filter based on order `source` information.
type SearchOrdersSourceFilter struct {
	// Filters by the [Source](entity:OrderSource) `name`. The filter returns any orders
	// with a `source.name` that matches any of the listed source names.
	//
	// Max: 10 source names.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSourceFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSourceFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter by the current order `state`.
type SearchOrdersStateFilter struct {
	// States to filter for.
	// See [OrderState](#type-orderstate) for possible values
	States []OrderState `json:"states,omitempty" url:"states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersStateFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersStateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersStateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersStateFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersStateFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The order (e.g., chronological or alphabetical) in which results from a request are returned.
type SortOrder string

const (
	SortOrderDesc SortOrder = "DESC"
	SortOrderAsc  SortOrder = "ASC"
)

func NewSortOrderFromString(s string) (SortOrder, error) {
	switch s {
	case "DESC":
		return SortOrderDesc, nil
	case "ASC":
		return SortOrderAsc, nil
	}
	var t SortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortOrder) Ptr() *SortOrder {
	return &s
}

// Represents a generic time range. The start and end values are
// represented in RFC 3339 format. Time ranges are customized to be
// inclusive or exclusive based on the needs of a particular endpoint.
// Refer to the relevant endpoint-specific documentation to determine
// how time ranges are handled.
type TimeRange struct {
	// A datetime value in RFC 3339 format indicating when the time range
	// starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A datetime value in RFC 3339 format indicating when the time range
	// ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint.
type UpdateOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOrderResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrderResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
