// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/wepala/square-go/api/core"
)

// ACH-specific details about `BANK_ACCOUNT` type payments with the `transfer_type` of `ACH`.
type AchDetails struct {
	// The routing number for the bank account.
	RoutingNumber *string `json:"routing_number,omitempty" url:"routing_number,omitempty"`
	// The last few digits of the bank account number.
	AccountNumberSuffix *string `json:"account_number_suffix,omitempty" url:"account_number_suffix,omitempty"`
	// The type of the bank account performing the transfer. The account type can be `CHECKING`,
	// `SAVINGS`, or `UNKNOWN`.
	AccountType *string `json:"account_type,omitempty" url:"account_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AchDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AchDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AchDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AchDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AchDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents an additional recipient (other than the merchant) receiving a portion of this tender.
type AdditionalRecipient struct {
	// The location ID for a recipient (other than the merchant) receiving a portion of this tender.
	LocationId string `json:"location_id" url:"location_id"`
	// The description of the additional recipient.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The unique ID for the RETIRED `AdditionalRecipientReceivable` object. This field should be empty for any `AdditionalRecipient` objects created after the retirement.
	ReceivableId *string `json:"receivable_id,omitempty" url:"receivable_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AdditionalRecipient) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AdditionalRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler AdditionalRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AdditionalRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AdditionalRecipient) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Represents a postal address in a country.
// For more information, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
type Address struct {
	// The first line of the address.
	//
	// Fields that start with `address_line` provide the address's most specific
	// details, like street number, street name, and building name. They do _not_
	// provide less specific details like city, state/province, or country (these
	// details are provided in other fields).
	AddressLine1 *string `json:"address_line_1,omitempty" url:"address_line_1,omitempty"`
	// The second line of the address, if any.
	AddressLine2 *string `json:"address_line_2,omitempty" url:"address_line_2,omitempty"`
	// The third line of the address, if any.
	AddressLine3 *string `json:"address_line_3,omitempty" url:"address_line_3,omitempty"`
	// The city or town of the address. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	Locality *string `json:"locality,omitempty" url:"locality,omitempty"`
	// A civil region within the address's `locality`, if any.
	Sublocality *string `json:"sublocality,omitempty" url:"sublocality,omitempty"`
	// A civil region within the address's `sublocality`, if any.
	Sublocality2 *string `json:"sublocality_2,omitempty" url:"sublocality_2,omitempty"`
	// A civil region within the address's `sublocality_2`, if any.
	Sublocality3 *string `json:"sublocality_3,omitempty" url:"sublocality_3,omitempty"`
	// A civil entity within the address's country. In the US, this
	// is the state. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	AdministrativeDistrictLevel1 *string `json:"administrative_district_level_1,omitempty" url:"administrative_district_level_1,omitempty"`
	// A civil entity within the address's `administrative_district_level_1`.
	// In the US, this is the county.
	AdministrativeDistrictLevel2 *string `json:"administrative_district_level_2,omitempty" url:"administrative_district_level_2,omitempty"`
	// A civil entity within the address's `administrative_district_level_2`,
	// if any.
	AdministrativeDistrictLevel3 *string `json:"administrative_district_level_3,omitempty" url:"administrative_district_level_3,omitempty"`
	// The address's postal code. For a full list of field meanings by country, see [Working with Addresses](https://developer.squareup.com/docs/build-basics/working-with-addresses).
	PostalCode *string  `json:"postal_code,omitempty" url:"postal_code,omitempty"`
	Country    *Country `json:"country,omitempty" url:"country,omitempty"`
	// Optional first name when it's representing recipient.
	FirstName *string `json:"first_name,omitempty" url:"first_name,omitempty"`
	// Optional last name when it's representing recipient.
	LastName *string `json:"last_name,omitempty" url:"last_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *Address) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *Address) UnmarshalJSON(data []byte) error {
	type unmarshaler Address
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = Address(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *Address) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Additional details about Afterpay payments.
type AfterpayDetails struct {
	// Email address on the buyer's Afterpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *AfterpayDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AfterpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler AfterpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AfterpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AfterpayDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Details about the application that took the payment.
type ApplicationDetails struct {
	SquareProduct *ApplicationDetailsExternalSquareProduct `json:"square_product,omitempty" url:"square_product,omitempty"`
	// The Square ID assigned to the application used to take the payment.
	// Application developers can use this information to identify payments that
	// their application processed.
	// For example, if a developer uses a custom application to process payments,
	// this field contains the application ID from the Developer Dashboard.
	// If a seller uses a [Square App Marketplace](https://developer.squareup.com/docs/app-marketplace)
	// application to process payments, the field contains the corresponding application ID.
	ApplicationId *string `json:"application_id,omitempty" url:"application_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (a *ApplicationDetails) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ApplicationDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ApplicationDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApplicationDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties

	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApplicationDetails) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// A list of products to return to external callers.
type ApplicationDetailsExternalSquareProduct string

const (
	ApplicationDetailsExternalSquareProductAppointments    ApplicationDetailsExternalSquareProduct = "APPOINTMENTS"
	ApplicationDetailsExternalSquareProductEcommerceApi    ApplicationDetailsExternalSquareProduct = "ECOMMERCE_API"
	ApplicationDetailsExternalSquareProductInvoices        ApplicationDetailsExternalSquareProduct = "INVOICES"
	ApplicationDetailsExternalSquareProductOnlineStore     ApplicationDetailsExternalSquareProduct = "ONLINE_STORE"
	ApplicationDetailsExternalSquareProductOther           ApplicationDetailsExternalSquareProduct = "OTHER"
	ApplicationDetailsExternalSquareProductRestaurants     ApplicationDetailsExternalSquareProduct = "RESTAURANTS"
	ApplicationDetailsExternalSquareProductRetail          ApplicationDetailsExternalSquareProduct = "RETAIL"
	ApplicationDetailsExternalSquareProductSquarePos       ApplicationDetailsExternalSquareProduct = "SQUARE_POS"
	ApplicationDetailsExternalSquareProductTerminalApi     ApplicationDetailsExternalSquareProduct = "TERMINAL_API"
	ApplicationDetailsExternalSquareProductVirtualTerminal ApplicationDetailsExternalSquareProduct = "VIRTUAL_TERMINAL"
)

func NewApplicationDetailsExternalSquareProductFromString(s string) (ApplicationDetailsExternalSquareProduct, error) {
	switch s {
	case "APPOINTMENTS":
		return ApplicationDetailsExternalSquareProductAppointments, nil
	case "ECOMMERCE_API":
		return ApplicationDetailsExternalSquareProductEcommerceApi, nil
	case "INVOICES":
		return ApplicationDetailsExternalSquareProductInvoices, nil
	case "ONLINE_STORE":
		return ApplicationDetailsExternalSquareProductOnlineStore, nil
	case "OTHER":
		return ApplicationDetailsExternalSquareProductOther, nil
	case "RESTAURANTS":
		return ApplicationDetailsExternalSquareProductRestaurants, nil
	case "RETAIL":
		return ApplicationDetailsExternalSquareProductRetail, nil
	case "SQUARE_POS":
		return ApplicationDetailsExternalSquareProductSquarePos, nil
	case "TERMINAL_API":
		return ApplicationDetailsExternalSquareProductTerminalApi, nil
	case "VIRTUAL_TERMINAL":
		return ApplicationDetailsExternalSquareProductVirtualTerminal, nil
	}
	var t ApplicationDetailsExternalSquareProduct
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ApplicationDetailsExternalSquareProduct) Ptr() *ApplicationDetailsExternalSquareProduct {
	return &a
}

// Additional details about BANK_ACCOUNT type payments.
type BankAccountPaymentDetails struct {
	// The name of the bank associated with the bank account.
	BankName *string `json:"bank_name,omitempty" url:"bank_name,omitempty"`
	// The type of the bank transfer. The type can be `ACH` or `UNKNOWN`.
	TransferType *string `json:"transfer_type,omitempty" url:"transfer_type,omitempty"`
	// The ownership type of the bank account performing the transfer.
	// The type can be `INDIVIDUAL`, `COMPANY`, or `UNKNOWN`.
	AccountOwnershipType *string `json:"account_ownership_type,omitempty" url:"account_ownership_type,omitempty"`
	// Uniquely identifies the bank account for this seller and can be used
	// to determine if payments are from the same bank account.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// The two-letter ISO code representing the country the bank account is located in.
	Country *string `json:"country,omitempty" url:"country,omitempty"`
	// The statement description as sent to the bank.
	StatementDescription *string     `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	AchDetails           *AchDetails `json:"ach_details,omitempty" url:"ach_details,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BankAccountPaymentDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BankAccountPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BankAccountPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BankAccountPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BankAccountPaymentDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Defines the fields that are included in the response body of
// a request to the `BatchRetrieveOrders` endpoint.
type BatchRetrieveOrdersResponse struct {
	// The requested orders. This will omit any requested orders that do not exist.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BatchRetrieveOrdersResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BatchRetrieveOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BatchRetrieveOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BatchRetrieveOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BatchRetrieveOrdersResponse) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// The hours of operation for a location.
type BusinessHours struct {
	// The list of time periods during which the business is open. There can be at most 10 periods per day.
	Periods []*BusinessHoursPeriod `json:"periods,omitempty" url:"periods,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHours) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHours) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHours
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHours(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHours) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents a period of time during which a business location is open.
type BusinessHoursPeriod struct {
	DayOfWeek *DayOfWeek `json:"day_of_week,omitempty" url:"day_of_week,omitempty"`
	// The start time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `8:30:00` for a period starting at 8:30 in the morning.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	StartLocalTime *string `json:"start_local_time,omitempty" url:"start_local_time,omitempty"`
	// The end time of a business hours period, specified in local time using partial-time
	// RFC 3339 format. For example, `21:00:00` for a period ending at 9:00 in the evening.
	// Note that the seconds value is always :00, but it is appended for conformance to the RFC.
	EndLocalTime *string `json:"end_local_time,omitempty" url:"end_local_time,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BusinessHoursPeriod) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BusinessHoursPeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler BusinessHoursPeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BusinessHoursPeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BusinessHoursPeriod) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Additional details about a Buy Now Pay Later payment type.
type BuyNowPayLaterDetails struct {
	// The brand used for the Buy Now Pay Later payment.
	// The brand can be `AFTERPAY`, `CLEARPAY` or `UNKNOWN`.
	Brand           *string          `json:"brand,omitempty" url:"brand,omitempty"`
	AfterpayDetails *AfterpayDetails `json:"afterpay_details,omitempty" url:"afterpay_details,omitempty"`
	ClearpayDetails *ClearpayDetails `json:"clearpay_details,omitempty" url:"clearpay_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BuyNowPayLaterDetails) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BuyNowPayLaterDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler BuyNowPayLaterDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BuyNowPayLaterDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BuyNowPayLaterDetails) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Represents the payment details of a card to be used for payments. These
// details are determined by the payment token generated by Web Payments SDK.
type Card struct {
	// Unique ID for this card. Generated by Square.
	Id        *string    `json:"id,omitempty" url:"id,omitempty"`
	CardBrand *CardBrand `json:"card_brand,omitempty" url:"card_brand,omitempty"`
	// The last 4 digits of the card number.
	Last4 *string `json:"last_4,omitempty" url:"last_4,omitempty"`
	// The expiration month of the associated card as an integer between 1 and 12.
	ExpMonth *int64 `json:"exp_month,omitempty" url:"exp_month,omitempty"`
	// The four-digit year of the card's expiration date.
	ExpYear *int64 `json:"exp_year,omitempty" url:"exp_year,omitempty"`
	// The name of the cardholder.
	CardholderName *string  `json:"cardholder_name,omitempty" url:"cardholder_name,omitempty"`
	BillingAddress *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	// Intended as a Square-assigned identifier, based
	// on the card number, to identify the card across multiple locations within a
	// single application.
	Fingerprint *string `json:"fingerprint,omitempty" url:"fingerprint,omitempty"`
	// **Required** The ID of a customer created using the Customers API to be associated with the card.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The ID of the merchant associated with the card.
	MerchantId *string `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	// An optional user-defined reference ID that associates this card with
	// another entity in an external system. For example, a customer ID from an
	// external customer management system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// Indicates whether or not a card can be used for payments.
	Enabled     *bool            `json:"enabled,omitempty" url:"enabled,omitempty"`
	CardType    *CardType        `json:"card_type,omitempty" url:"card_type,omitempty"`
	PrepaidType *CardPrepaidType `json:"prepaid_type,omitempty" url:"prepaid_type,omitempty"`
	// The first six digits of the card number, known as the Bank Identification Number (BIN). Only the Payments API
	// returns this field.
	Bin *string `json:"bin,omitempty" url:"bin,omitempty"`
	// Current version number of the card. Increments with each card update. Requests to update an
	// existing Card object will be rejected unless the version in the request matches the current
	// version for the Card.
	Version     *int64       `json:"version,omitempty" url:"version,omitempty"`
	CardCoBrand *CardCoBrand `json:"card_co_brand,omitempty" url:"card_co_brand,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Card) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Card) UnmarshalJSON(data []byte) error {
	type unmarshaler Card
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Card(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Card) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's brand, such as `VISA` or `MASTERCARD`.
type CardBrand string

const (
	CardBrandOtherBrand        CardBrand = "OTHER_BRAND"
	CardBrandVisa              CardBrand = "VISA"
	CardBrandMastercard        CardBrand = "MASTERCARD"
	CardBrandAmericanExpress   CardBrand = "AMERICAN_EXPRESS"
	CardBrandDiscover          CardBrand = "DISCOVER"
	CardBrandDiscoverDiners    CardBrand = "DISCOVER_DINERS"
	CardBrandJcb               CardBrand = "JCB"
	CardBrandChinaUnionpay     CardBrand = "CHINA_UNIONPAY"
	CardBrandSquareGiftCard    CardBrand = "SQUARE_GIFT_CARD"
	CardBrandSquareCapitalCard CardBrand = "SQUARE_CAPITAL_CARD"
	CardBrandInterac           CardBrand = "INTERAC"
	CardBrandEftpos            CardBrand = "EFTPOS"
	CardBrandFelica            CardBrand = "FELICA"
	CardBrandEbt               CardBrand = "EBT"
)

func NewCardBrandFromString(s string) (CardBrand, error) {
	switch s {
	case "OTHER_BRAND":
		return CardBrandOtherBrand, nil
	case "VISA":
		return CardBrandVisa, nil
	case "MASTERCARD":
		return CardBrandMastercard, nil
	case "AMERICAN_EXPRESS":
		return CardBrandAmericanExpress, nil
	case "DISCOVER":
		return CardBrandDiscover, nil
	case "DISCOVER_DINERS":
		return CardBrandDiscoverDiners, nil
	case "JCB":
		return CardBrandJcb, nil
	case "CHINA_UNIONPAY":
		return CardBrandChinaUnionpay, nil
	case "SQUARE_GIFT_CARD":
		return CardBrandSquareGiftCard, nil
	case "SQUARE_CAPITAL_CARD":
		return CardBrandSquareCapitalCard, nil
	case "INTERAC":
		return CardBrandInterac, nil
	case "EFTPOS":
		return CardBrandEftpos, nil
	case "FELICA":
		return CardBrandFelica, nil
	case "EBT":
		return CardBrandEbt, nil
	}
	var t CardBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardBrand) Ptr() *CardBrand {
	return &c
}

// Indicates the brand for a co-branded card.
type CardCoBrand string

const (
	CardCoBrandUnknown  CardCoBrand = "UNKNOWN"
	CardCoBrandAfterpay CardCoBrand = "AFTERPAY"
	CardCoBrandClearpay CardCoBrand = "CLEARPAY"
)

func NewCardCoBrandFromString(s string) (CardCoBrand, error) {
	switch s {
	case "UNKNOWN":
		return CardCoBrandUnknown, nil
	case "AFTERPAY":
		return CardCoBrandAfterpay, nil
	case "CLEARPAY":
		return CardCoBrandClearpay, nil
	}
	var t CardCoBrand
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardCoBrand) Ptr() *CardCoBrand {
	return &c
}

// Reflects the current status of a card payment. Contains only non-confidential information.
type CardPaymentDetails struct {
	// The card payment's current state. The state can be AUTHORIZED, CAPTURED, VOIDED, or
	// FAILED.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	Card   *Card   `json:"card,omitempty" url:"card,omitempty"`
	// The method used to enter the card's details for the payment. The method can be
	// `KEYED`, `SWIPED`, `EMV`, `ON_FILE`, or `CONTACTLESS`.
	EntryMethod *string `json:"entry_method,omitempty" url:"entry_method,omitempty"`
	// The status code returned from the Card Verification Value (CVV) check. The code can be
	// `CVV_ACCEPTED`, `CVV_REJECTED`, or `CVV_NOT_CHECKED`.
	CvvStatus *string `json:"cvv_status,omitempty" url:"cvv_status,omitempty"`
	// The status code returned from the Address Verification System (AVS) check. The code can be
	// `AVS_ACCEPTED`, `AVS_REJECTED`, or `AVS_NOT_CHECKED`.
	AvsStatus *string `json:"avs_status,omitempty" url:"avs_status,omitempty"`
	// The status code returned by the card issuer that describes the payment's
	// authorization status.
	AuthResultCode *string `json:"auth_result_code,omitempty" url:"auth_result_code,omitempty"`
	// For EMV payments, the application ID identifies the EMV application used for the payment.
	ApplicationIdentifier *string `json:"application_identifier,omitempty" url:"application_identifier,omitempty"`
	// For EMV payments, the human-readable name of the EMV application used for the payment.
	ApplicationName *string `json:"application_name,omitempty" url:"application_name,omitempty"`
	// For EMV payments, the cryptogram generated for the payment.
	ApplicationCryptogram *string `json:"application_cryptogram,omitempty" url:"application_cryptogram,omitempty"`
	// For EMV payments, the method used to verify the cardholder's identity. The method can be
	// `PIN`, `SIGNATURE`, `PIN_AND_SIGNATURE`, `ON_DEVICE`, or `NONE`.
	VerificationMethod *string `json:"verification_method,omitempty" url:"verification_method,omitempty"`
	// For EMV payments, the results of the cardholder verification. The result can be
	// `SUCCESS`, `FAILURE`, or `UNKNOWN`.
	VerificationResults *string `json:"verification_results,omitempty" url:"verification_results,omitempty"`
	// The statement description sent to the card networks.
	//
	// Note: The actual statement description varies and is likely to be truncated and appended with
	// additional information on a per issuer basis.
	StatementDescription *string              `json:"statement_description,omitempty" url:"statement_description,omitempty"`
	DeviceDetails        *DeviceDetails       `json:"device_details,omitempty" url:"device_details,omitempty"`
	CardPaymentTimeline  *CardPaymentTimeline `json:"card_payment_timeline,omitempty" url:"card_payment_timeline,omitempty"`
	// Whether the card must be physically present for the payment to
	// be refunded. If set to `true`, the card must be present.
	RefundRequiresCardPresence *bool `json:"refund_requires_card_presence,omitempty" url:"refund_requires_card_presence,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The timeline for card payments.
type CardPaymentTimeline struct {
	// The timestamp when the payment was authorized, in RFC 3339 format.
	AuthorizedAt *string `json:"authorized_at,omitempty" url:"authorized_at,omitempty"`
	// The timestamp when the payment was captured, in RFC 3339 format.
	CapturedAt *string `json:"captured_at,omitempty" url:"captured_at,omitempty"`
	// The timestamp when the payment was voided, in RFC 3339 format.
	VoidedAt *string `json:"voided_at,omitempty" url:"voided_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CardPaymentTimeline) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CardPaymentTimeline) UnmarshalJSON(data []byte) error {
	type unmarshaler CardPaymentTimeline
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CardPaymentTimeline(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CardPaymentTimeline) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates a card's prepaid type, such as `NOT_PREPAID` or `PREPAID`.
type CardPrepaidType string

const (
	CardPrepaidTypeUnknownPrepaidType CardPrepaidType = "UNKNOWN_PREPAID_TYPE"
	CardPrepaidTypeNotPrepaid         CardPrepaidType = "NOT_PREPAID"
	CardPrepaidTypePrepaid            CardPrepaidType = "PREPAID"
)

func NewCardPrepaidTypeFromString(s string) (CardPrepaidType, error) {
	switch s {
	case "UNKNOWN_PREPAID_TYPE":
		return CardPrepaidTypeUnknownPrepaidType, nil
	case "NOT_PREPAID":
		return CardPrepaidTypeNotPrepaid, nil
	case "PREPAID":
		return CardPrepaidTypePrepaid, nil
	}
	var t CardPrepaidType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardPrepaidType) Ptr() *CardPrepaidType {
	return &c
}

// Indicates a card's type, such as `CREDIT` or `DEBIT`.
type CardType string

const (
	CardTypeUnknownCardType CardType = "UNKNOWN_CARD_TYPE"
	CardTypeCredit          CardType = "CREDIT"
	CardTypeDebit           CardType = "DEBIT"
)

func NewCardTypeFromString(s string) (CardType, error) {
	switch s {
	case "UNKNOWN_CARD_TYPE":
		return CardTypeUnknownCardType, nil
	case "CREDIT":
		return CardTypeCredit, nil
	case "DEBIT":
		return CardTypeDebit, nil
	}
	var t CardType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CardType) Ptr() *CardType {
	return &c
}

// Additional details about `WALLET` type payments with the `brand` of `CASH_APP`.
type CashAppDetails struct {
	// The name of the Cash App account holder.
	BuyerFullName *string `json:"buyer_full_name,omitempty" url:"buyer_full_name,omitempty"`
	// The country of the Cash App account holder, in ISO 3166-1-alpha-2 format.
	//
	// For possible values, see [Country](entity:Country).
	BuyerCountryCode *string `json:"buyer_country_code,omitempty" url:"buyer_country_code,omitempty"`
	// $Cashtag of the Cash App account holder.
	BuyerCashtag *string `json:"buyer_cashtag,omitempty" url:"buyer_cashtag,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashAppDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashAppDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashAppDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashAppDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashAppDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Stores details about a cash payment. Contains only non-confidential information. For more information, see
// [Take Cash Payments](https://developer.squareup.com/docs/payments-api/take-payments/cash-payments).
type CashPaymentDetails struct {
	BuyerSuppliedMoney *Money `json:"buyer_supplied_money,omitempty" url:"buyer_supplied_money,omitempty"`
	ChangeBackMoney    *Money `json:"change_back_money,omitempty" url:"change_back_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CashPaymentDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CashPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler CashPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CashPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CashPaymentDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A category to which a `CatalogItem` instance belongs.
type CatalogCategory struct {
	// The category name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The IDs of images associated with this `CatalogCategory` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCategory) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCategory) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCategory
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCategory(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCategory) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Contains information defining a custom attribute. Custom attributes are
// intended to store additional information about a catalog object or to associate a
// catalog object with an entity in another system. Do not use custom attributes
// to store any sensitive information (personally identifiable information, card details, etc.).
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes)
type CatalogCustomAttributeDefinition struct {
	Type CatalogCustomAttributeDefinitionType `json:"type" url:"type"`
	// The name of this definition for API and seller-facing UI purposes.
	// The name must be unique within the (merchant, application) pair. Required.
	// May not be empty and may not exceed 255 characters. Can be modified after creation.
	Name string `json:"name" url:"name"`
	// Seller-oriented description of the meaning of this Custom Attribute,
	// any constraints that the seller should observe, etc. May be displayed as a tooltip in Square UIs.
	Description       *string            `json:"description,omitempty" url:"description,omitempty"`
	SourceApplication *SourceApplication `json:"source_application,omitempty" url:"source_application,omitempty"`
	// The set of Catalog Object Types that this Custom Attribute may be applied to.
	// Currently, only `ITEM` and `ITEM_VARIATION` are allowed. At least one type must be included.
	// See [CatalogObjectType](#type-catalogobjecttype) for possible values
	AllowedObjectTypes []CatalogObjectType                               `json:"allowed_object_types,omitempty" url:"allowed_object_types,omitempty"`
	SellerVisibility   *CatalogCustomAttributeDefinitionSellerVisibility `json:"seller_visibility,omitempty" url:"seller_visibility,omitempty"`
	AppVisibility      *CatalogCustomAttributeDefinitionAppVisibility    `json:"app_visibility,omitempty" url:"app_visibility,omitempty"`
	StringConfig       *CatalogCustomAttributeDefinitionStringConfig     `json:"string_config,omitempty" url:"string_config,omitempty"`
	NumberConfig       *CatalogCustomAttributeDefinitionNumberConfig     `json:"number_config,omitempty" url:"number_config,omitempty"`
	SelectionConfig    *CatalogCustomAttributeDefinitionSelectionConfig  `json:"selection_config,omitempty" url:"selection_config,omitempty"`
	// The number of custom attributes that reference this
	// custom attribute definition. Set by the server in response to a ListCatalog
	// request with `include_counts` set to `true`. If the actual count is greater
	// than 100, `custom_attribute_usage_count` will be set to `100`.
	CustomAttributeUsageCount *int `json:"custom_attribute_usage_count,omitempty" url:"custom_attribute_usage_count,omitempty"`
	// The name of the desired custom attribute key that can be used to access
	// the custom attribute value on catalog objects. Cannot be modified after the
	// custom attribute definition has been created.
	// Must be between 1 and 60 characters, and may only contain the characters `[a-zA-Z0-9_-]`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinition(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinition) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to applications other than their
// creating application.
type CatalogCustomAttributeDefinitionAppVisibility string

const (
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityDoNotUse        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_DO_NOT_USE"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden          CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly        CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_ONLY"
	CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues CatalogCustomAttributeDefinitionAppVisibility = "APP_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionAppVisibilityFromString(s string) (CatalogCustomAttributeDefinitionAppVisibility, error) {
	switch s {
	case "APP_VISIBILITY_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityDoNotUse, nil
	case "APP_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityHidden, nil
	case "APP_VISIBILITY_READ_ONLY":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadOnly, nil
	case "APP_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionAppVisibilityAppVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionAppVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionAppVisibility) Ptr() *CatalogCustomAttributeDefinitionAppVisibility {
	return &c
}

type CatalogCustomAttributeDefinitionNumberConfig struct {
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in number custom attribute values
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 5
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionNumberConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionNumberConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionNumberConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Configuration associated with `SELECTION`-type custom attribute definitions.
type CatalogCustomAttributeDefinitionSelectionConfig struct {
	// The maximum number of selections that can be set. The maximum value for this
	// attribute is 100. The default value is 1. The value can be modified, but changing the value will not
	// affect existing custom attribute values on objects. Clients need to
	// handle custom attributes with more selected values than allowed by this limit.
	MaxAllowedSelections *int `json:"max_allowed_selections,omitempty" url:"max_allowed_selections,omitempty"`
	// The set of valid `CatalogCustomAttributeSelections`. Up to a maximum of 100
	// selections can be defined. Can be modified.
	AllowedSelections []*CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection `json:"allowed_selections,omitempty" url:"allowed_selections,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A named selection for this `SELECTION`-type custom attribute definition.
type CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection struct {
	// Unique ID set by Square.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// Selection name, unique within `allowed_selections`.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionSelectionConfigCustomAttributeSelection) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the visibility of a custom attribute to sellers in Square
// client applications, Square APIs or in Square UIs (including Square Point
// of Sale applications and Square Dashboard).
type CatalogCustomAttributeDefinitionSellerVisibility string

const (
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityDoNotUse        CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_DO_NOT_USE"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden          CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_HIDDEN"
	CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues CatalogCustomAttributeDefinitionSellerVisibility = "SELLER_VISIBILITY_READ_WRITE_VALUES"
)

func NewCatalogCustomAttributeDefinitionSellerVisibilityFromString(s string) (CatalogCustomAttributeDefinitionSellerVisibility, error) {
	switch s {
	case "SELLER_VISIBILITY_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityDoNotUse, nil
	case "SELLER_VISIBILITY_HIDDEN":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityHidden, nil
	case "SELLER_VISIBILITY_READ_WRITE_VALUES":
		return CatalogCustomAttributeDefinitionSellerVisibilitySellerVisibilityReadWriteValues, nil
	}
	var t CatalogCustomAttributeDefinitionSellerVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionSellerVisibility) Ptr() *CatalogCustomAttributeDefinitionSellerVisibility {
	return &c
}

// Configuration associated with Custom Attribute Definitions of type `STRING`.
type CatalogCustomAttributeDefinitionStringConfig struct {
	// If true, each Custom Attribute instance associated with this Custom Attribute
	// Definition must have a unique value within the seller's catalog. For
	// example, this may be used for a value like a SKU that should not be
	// duplicated within a seller's catalog. May not be modified after the
	// definition has been created.
	EnforceUniqueness *bool `json:"enforce_uniqueness,omitempty" url:"enforce_uniqueness,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeDefinitionStringConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeDefinitionStringConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeDefinitionStringConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeDefinitionStringConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeDefinitionStringConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the possible types for a custom attribute.
type CatalogCustomAttributeDefinitionType string

const (
	CatalogCustomAttributeDefinitionTypeAttributeTypeDoNotUse CatalogCustomAttributeDefinitionType = "ATTRIBUTE_TYPE_DO_NOT_USE"
	CatalogCustomAttributeDefinitionTypeString                CatalogCustomAttributeDefinitionType = "STRING"
	CatalogCustomAttributeDefinitionTypeInteger               CatalogCustomAttributeDefinitionType = "INTEGER"
	CatalogCustomAttributeDefinitionTypeBoolean               CatalogCustomAttributeDefinitionType = "BOOLEAN"
	CatalogCustomAttributeDefinitionTypeNumber                CatalogCustomAttributeDefinitionType = "NUMBER"
	CatalogCustomAttributeDefinitionTypeSelection             CatalogCustomAttributeDefinitionType = "SELECTION"
	CatalogCustomAttributeDefinitionTypeStringInt             CatalogCustomAttributeDefinitionType = "STRING_INT"
	CatalogCustomAttributeDefinitionTypeTokenInt              CatalogCustomAttributeDefinitionType = "TOKEN_INT"
)

func NewCatalogCustomAttributeDefinitionTypeFromString(s string) (CatalogCustomAttributeDefinitionType, error) {
	switch s {
	case "ATTRIBUTE_TYPE_DO_NOT_USE":
		return CatalogCustomAttributeDefinitionTypeAttributeTypeDoNotUse, nil
	case "STRING":
		return CatalogCustomAttributeDefinitionTypeString, nil
	case "INTEGER":
		return CatalogCustomAttributeDefinitionTypeInteger, nil
	case "BOOLEAN":
		return CatalogCustomAttributeDefinitionTypeBoolean, nil
	case "NUMBER":
		return CatalogCustomAttributeDefinitionTypeNumber, nil
	case "SELECTION":
		return CatalogCustomAttributeDefinitionTypeSelection, nil
	case "STRING_INT":
		return CatalogCustomAttributeDefinitionTypeStringInt, nil
	case "TOKEN_INT":
		return CatalogCustomAttributeDefinitionTypeTokenInt, nil
	}
	var t CatalogCustomAttributeDefinitionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogCustomAttributeDefinitionType) Ptr() *CatalogCustomAttributeDefinitionType {
	return &c
}

// An instance of a custom attribute. Custom attributes can be defined and
// added to `ITEM` and `ITEM_VARIATION` type catalog objects.
// [Read more about custom attributes](https://developer.squareup.com/docs/catalog-api/add-custom-attributes).
type CatalogCustomAttributeValue struct {
	// The name of the custom attribute.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The string value of the custom attribute. Populated if `type` = `STRING`.
	StringValue *string `json:"string_value,omitempty" url:"string_value,omitempty"`
	// The id of the [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition) this value belongs to.
	CustomAttributeDefinitionId *string                               `json:"custom_attribute_definition_id,omitempty" url:"custom_attribute_definition_id,omitempty"`
	Type                        *CatalogCustomAttributeDefinitionType `json:"type,omitempty" url:"type,omitempty"`
	// Populated if `type` = `NUMBER`. Contains a string
	// representation of a decimal number, using a `.` as the decimal separator.
	NumberValue *string `json:"number_value,omitempty" url:"number_value,omitempty"`
	// A `true` or `false` value. Populated if `type` = `BOOLEAN`.
	BooleanValue *bool `json:"boolean_value,omitempty" url:"boolean_value,omitempty"`
	// One or more choices from `allowed_selections`. Populated if `type` = `SELECTION`.
	SelectionUidValues []string `json:"selection_uid_values,omitempty" url:"selection_uid_values,omitempty"`
	// A copy of key from the associated `CatalogCustomAttributeDefinition`.
	Key *string `json:"key,omitempty" url:"key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogCustomAttributeValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogCustomAttributeValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogCustomAttributeValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogCustomAttributeValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogCustomAttributeValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A discount applicable to items.
type CatalogDiscount struct {
	// The discount name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name         *string              `json:"name,omitempty" url:"name,omitempty"`
	DiscountType *CatalogDiscountType `json:"discount_type,omitempty" url:"discount_type,omitempty"`
	// The percentage of the discount as a string representation of a decimal number, using a `.` as the decimal
	// separator and without a `%` sign. A value of `7.5` corresponds to `7.5%`. Specify a percentage of `0` if `discount_type`
	// is `VARIABLE_PERCENTAGE`.
	//
	// Do not use this field for amount-based or variable discounts.
	Percentage  *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// Indicates whether a mobile staff member needs to enter their PIN to apply the
	// discount to a payment in the Square Point of Sale app.
	PinRequired *bool `json:"pin_required,omitempty" url:"pin_required,omitempty"`
	// The color of the discount display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor         *string                        `json:"label_color,omitempty" url:"label_color,omitempty"`
	ModifyTaxBasis     *CatalogDiscountModifyTaxBasis `json:"modify_tax_basis,omitempty" url:"modify_tax_basis,omitempty"`
	MaximumAmountMoney *Money                         `json:"maximum_amount_money,omitempty" url:"maximum_amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogDiscount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogDiscount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CatalogDiscountModifyTaxBasis string

const (
	CatalogDiscountModifyTaxBasisModifyTaxBasis      CatalogDiscountModifyTaxBasis = "MODIFY_TAX_BASIS"
	CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis CatalogDiscountModifyTaxBasis = "DO_NOT_MODIFY_TAX_BASIS"
)

func NewCatalogDiscountModifyTaxBasisFromString(s string) (CatalogDiscountModifyTaxBasis, error) {
	switch s {
	case "MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisModifyTaxBasis, nil
	case "DO_NOT_MODIFY_TAX_BASIS":
		return CatalogDiscountModifyTaxBasisDoNotModifyTaxBasis, nil
	}
	var t CatalogDiscountModifyTaxBasis
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountModifyTaxBasis) Ptr() *CatalogDiscountModifyTaxBasis {
	return &c
}

// How to apply a CatalogDiscount to a CatalogItem.
type CatalogDiscountType string

const (
	CatalogDiscountTypeFixedPercentage    CatalogDiscountType = "FIXED_PERCENTAGE"
	CatalogDiscountTypeFixedAmount        CatalogDiscountType = "FIXED_AMOUNT"
	CatalogDiscountTypeVariablePercentage CatalogDiscountType = "VARIABLE_PERCENTAGE"
	CatalogDiscountTypeVariableAmount     CatalogDiscountType = "VARIABLE_AMOUNT"
)

func NewCatalogDiscountTypeFromString(s string) (CatalogDiscountType, error) {
	switch s {
	case "FIXED_PERCENTAGE":
		return CatalogDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return CatalogDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return CatalogDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return CatalogDiscountTypeVariableAmount, nil
	}
	var t CatalogDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogDiscountType) Ptr() *CatalogDiscountType {
	return &c
}

// A mapping between a temporary client-supplied ID and a permanent server-generated ID.
//
// When calling [UpsertCatalogObject](api-endpoint:Catalog-UpsertCatalogObject) or
// [BatchUpsertCatalogObjects](api-endpoint:Catalog-BatchUpsertCatalogObjects) to
// create a [CatalogObject](entity:CatalogObject) instance, you can supply
// a temporary ID for the to-be-created object, especially when the object is to be referenced
// elsewhere in the same request body. This temporary ID can be any string unique within
// the call, but must be prefixed by "#".
//
// After the request is submitted and the object created, a permanent server-generated ID is assigned
// to the new object. The permanent ID is unique across the Square catalog.
type CatalogIdMapping struct {
	// The client-supplied temporary `#`-prefixed ID for a new `CatalogObject`.
	ClientObjectId *string `json:"client_object_id,omitempty" url:"client_object_id,omitempty"`
	// The permanent ID for the CatalogObject created by the server.
	ObjectId *string `json:"object_id,omitempty" url:"object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogIdMapping) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogIdMapping) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogIdMapping
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogIdMapping(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogIdMapping) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An image file to use in Square catalogs. It can be associated with
// `CatalogItem`, `CatalogItemVariation`, `CatalogCategory`, and `CatalogModifierList` objects.
// Only the images on items and item variations are exposed in Dashboard.
// Only the first image on an item is displayed in Square Point of Sale (SPOS).
// Images on items and variations are displayed through Square Online Store.
// Images on other object types are for use by 3rd party application developers.
type CatalogImage struct {
	// The internal name to identify this image in calls to the Square API.
	// This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	// It is not unique and should not be shown in a buyer facing context.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL of this image, generated by Square after an image is uploaded
	// using the [CreateCatalogImage](api-endpoint:Catalog-CreateCatalogImage) endpoint.
	// To modify the image, use the UpdateCatalogImage endpoint. Do not change the URL field.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// A caption that describes what is shown in the image. Displayed in the
	// Square Online Store. This is a searchable attribute for use in applicable query filters
	// using the [SearchCatalogObjects](api-endpoint:Catalog-SearchCatalogObjects).
	Caption *string `json:"caption,omitempty" url:"caption,omitempty"`
	// The immutable order ID for this image object created by the Photo Studio service in Square Online Store.
	PhotoStudioOrderId *string `json:"photo_studio_order_id,omitempty" url:"photo_studio_order_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogImage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogImage) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogImage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogImage(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogImage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A [CatalogObject](entity:CatalogObject) instance of the `ITEM` type, also referred to as an item, in the catalog.
type CatalogItem struct {
	// The item's name. This is a searchable attribute for use in applicable query filters, its value must not be empty, and the length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item's description. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	//
	// Deprecated at 2022-07-20, this field is planned to retire in 6 months. You should migrate to use `description_html` to set the description
	// of the [CatalogItem](entity:CatalogItem) instance. The `description` and `description_html` field values are kept in sync. If you try to
	// set the both fields, the `description_html` text value overwrites the `description` value. Updates in one field are also reflected in the other,
	// except for when you use an early version before Square API 2022-07-20 and `description_html` is set to blank, setting the `description` value to null
	// does not nullify `description_html`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The text of the item's display label in the Square Point of Sale app. Only up to the first five characters of the string are used.
	// This attribute is searchable, and its value length is of Unicode code points.
	Abbreviation *string `json:"abbreviation,omitempty" url:"abbreviation,omitempty"`
	// The color of the item's display label in the Square Point of Sale app. This must be a valid hex color code.
	LabelColor *string `json:"label_color,omitempty" url:"label_color,omitempty"`
	// If `true`, the item can be added to shipping orders from the merchant's online store.
	AvailableOnline *bool `json:"available_online,omitempty" url:"available_online,omitempty"`
	// If `true`, the item can be added to pickup orders from the merchant's online store.
	AvailableForPickup *bool `json:"available_for_pickup,omitempty" url:"available_for_pickup,omitempty"`
	// If `true`, the item can be added to electronically fulfilled orders from the merchant's online store.
	AvailableElectronically *bool `json:"available_electronically,omitempty" url:"available_electronically,omitempty"`
	// The ID of the item's category, if any.
	CategoryId *string `json:"category_id,omitempty" url:"category_id,omitempty"`
	// A set of IDs indicating the taxes enabled for
	// this item. When updating an item, any taxes listed here will be added to the item.
	// Taxes may also be added to or deleted from an item using `UpdateItemTaxes`.
	TaxIds []string `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`
	// A set of `CatalogItemModifierListInfo` objects
	// representing the modifier lists that apply to this item, along with the overrides and min
	// and max limits that are specific to this item. Modifier lists
	// may also be added to or deleted from an item using `UpdateItemModifierLists`.
	ModifierListInfo []*CatalogItemModifierListInfo `json:"modifier_list_info,omitempty" url:"modifier_list_info,omitempty"`
	// **Retired**. The URL of an image representing this item. Retired
	// in favor of `image_id` in [CatalogObject](entity:CatalogObject).
	ImageUrl *string `json:"image_url,omitempty" url:"image_url,omitempty"`
	// A list of [CatalogItemVariation](entity:CatalogItemVariation) objects for this item. An item must have
	// at least one variation.
	Variations  []*CatalogObject        `json:"variations,omitempty" url:"variations,omitempty"`
	ProductType *CatalogItemProductType `json:"product_type,omitempty" url:"product_type,omitempty"`
	// If `false`, the Square Point of Sale app will present the `CatalogItem`'s
	// details screen immediately, allowing the merchant to choose `CatalogModifier`s
	// before adding the item to the cart. This is the default behavior.
	//
	// If `true`, the Square Point of Sale app will immediately add the item to the cart with the pre-selected
	// modifiers, and merchants can edit modifiers by drilling down onto the item's details.
	//
	// Third-party clients are encouraged to implement similar behaviors.
	SkipModifierScreen *bool `json:"skip_modifier_screen,omitempty" url:"skip_modifier_screen,omitempty"`
	// List of item options IDs for this item. Used to manage and group item
	// variations in a specified order.
	//
	// Maximum: 6 item options.
	ItemOptions []*CatalogItemOptionForItem `json:"item_options,omitempty" url:"item_options,omitempty"`
	// hidden field
	EcomUri *string `json:"ecom_uri,omitempty" url:"ecom_uri,omitempty"`
	// hidden field
	EcomImageUris []string `json:"ecom_image_uris,omitempty" url:"ecom_image_uris,omitempty"`
	// hidden field
	EcomAvailable *bool `json:"ecom_available,omitempty" url:"ecom_available,omitempty"`
	// hidden field
	EcomVisibility *string `json:"ecom_visibility,omitempty" url:"ecom_visibility,omitempty"`
	// The IDs of images associated with this `CatalogItem` instance.
	// These images will be shown to customers in Square Online Store.
	// The first image will show up as the icon for this item in POS.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// A name to sort the item by. If this name is unspecified, namely, the `sort_name` field is absent, the regular `name` field is used for sorting.
	//
	// It is currently supported for sellers of the Japanese locale only.
	SortName *string `json:"sort_name,omitempty" url:"sort_name,omitempty"`
	// The item's description as expressed in valid HTML elements. The length of this field value, including those of HTML tags,
	// is of Unicode points. With application query filters, the text values of the HTML elements and attributes are searchable. Invalid or
	// unsupported HTML elements or attributes are ignored.
	//
	// Supported HTML elements include:
	//
	// - `a`: Link. Supports linking to website URLs, email address, and telephone numbers.
	// - `b`, `strong`: Bold text
	// - `br`: Line break
	// - `code`: Computer code
	// - `div`: Section
	// - `h1-h6`: Headings
	// - `i`, `em`: Italics
	// - `li`: List element
	// - `ol`: Numbered list
	// - `p`: Paragraph
	// - `ul`: Bullet list
	// - `u`: Underline
	//
	// Supported HTML attributes include:
	//
	// - `align`: Alignment of the text content
	// - `href`: Link destination
	// - `rel`: Relationship between link's target and source
	// - `target`: Place to open the linked document
	DescriptionHtml *string `json:"description_html,omitempty" url:"description_html,omitempty"`
	// A server-generated plaintext version of the `description_html` field, without formatting tags.
	DescriptionPlaintext *string `json:"description_plaintext,omitempty" url:"description_plaintext,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Options to control the properties of a `CatalogModifierList` applied to a `CatalogItem` instance.
type CatalogItemModifierListInfo struct {
	// The ID of the `CatalogModifierList` controlled by this `CatalogModifierListInfo`.
	ModifierListId string `json:"modifier_list_id" url:"modifier_list_id"`
	// A set of `CatalogModifierOverride` objects that override whether a given `CatalogModifier` is enabled by default.
	ModifierOverrides []*CatalogModifierOverride `json:"modifier_overrides,omitempty" url:"modifier_overrides,omitempty"`
	// If 0 or larger, the smallest number of `CatalogModifier`s that must be selected from this `CatalogModifierList`.
	MinSelectedModifiers *int `json:"min_selected_modifiers,omitempty" url:"min_selected_modifiers,omitempty"`
	// If 0 or larger, the largest number of `CatalogModifier`s that can be selected from this `CatalogModifierList`.
	MaxSelectedModifiers *int `json:"max_selected_modifiers,omitempty" url:"max_selected_modifiers,omitempty"`
	// If `true`, enable this `CatalogModifierList`. The default value is `true`.
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemModifierListInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemModifierListInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemModifierListInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemModifierListInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemModifierListInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A group of variations for a `CatalogItem`.
type CatalogItemOption struct {
	// The item option's display name for the seller. Must be unique across
	// all item options. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item option's display name for the customer. This is a searchable attribute for use in applicable query filters.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The item option's human-readable description. Displayed in the Square
	// Point of Sale app for the seller and in the Online Store or on receipts for
	// the buyer. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// If true, display colors for entries in `values` when present.
	ShowColors *bool `json:"show_colors,omitempty" url:"show_colors,omitempty"`
	// A list of CatalogObjects containing the
	// `CatalogItemOptionValue`s for this item.
	Values []*CatalogObject `json:"values,omitempty" url:"values,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOption) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOption) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOption(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOption) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An option that can be assigned to an item.
// For example, a t-shirt item may offer a color option or a size option.
type CatalogItemOptionForItem struct {
	// The unique id of the item option, used to form the dimensions of the item option matrix in a specified order.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionForItem) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionForItem) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionForItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionForItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionForItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// An enumerated value that can link a
// `CatalogItemVariation` to an item option as one of
// its item option values.
type CatalogItemOptionValue struct {
	// Unique ID of the associated item option.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// Name of this item option value. This is a searchable attribute for use in applicable query filters.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A human-readable description for the option value. This is a searchable attribute for use in applicable query filters.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The HTML-supported hex color for the item option (e.g., "#ff8d4e85").
	// Only displayed if `show_colors` is enabled on the parent `ItemOption`. When
	// left unset, `color` defaults to white ("#ffffff") when `show_colors` is
	// enabled on the parent `ItemOption`.
	Color *string `json:"color,omitempty" url:"color,omitempty"`
	// Determines where this option value appears in a list of option values.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValue) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValue) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValue(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A `CatalogItemOptionValue` links an item variation to an item option as
// an item option value. For example, a t-shirt item may offer a color option and
// a size option. An item option value would represent each variation of t-shirt:
// For example, "Color:Red, Size:Small" or "Color:Blue, Size:Medium".
type CatalogItemOptionValueForItemVariation struct {
	// The unique id of an item option.
	ItemOptionId *string `json:"item_option_id,omitempty" url:"item_option_id,omitempty"`
	// The unique id of the selected value for the item option.
	ItemOptionValueId *string `json:"item_option_value_id,omitempty" url:"item_option_value_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemOptionValueForItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemOptionValueForItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemOptionValueForItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemOptionValueForItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemOptionValueForItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of a CatalogItem. Connect V2 only allows the creation of `REGULAR` or `APPOINTMENTS_SERVICE` items.
type CatalogItemProductType string

const (
	CatalogItemProductTypeRegular             CatalogItemProductType = "REGULAR"
	CatalogItemProductTypeGiftCard            CatalogItemProductType = "GIFT_CARD"
	CatalogItemProductTypeAppointmentsService CatalogItemProductType = "APPOINTMENTS_SERVICE"
	CatalogItemProductTypeClassTicket         CatalogItemProductType = "CLASS_TICKET"
)

func NewCatalogItemProductTypeFromString(s string) (CatalogItemProductType, error) {
	switch s {
	case "REGULAR":
		return CatalogItemProductTypeRegular, nil
	case "GIFT_CARD":
		return CatalogItemProductTypeGiftCard, nil
	case "APPOINTMENTS_SERVICE":
		return CatalogItemProductTypeAppointmentsService, nil
	case "CLASS_TICKET":
		return CatalogItemProductTypeClassTicket, nil
	}
	var t CatalogItemProductType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogItemProductType) Ptr() *CatalogItemProductType {
	return &c
}

// An item variation, representing a product for sale, in the Catalog object model. Each [item](entity:CatalogItem) must have at least one
// item variation and can have at most 250 item variations.
//
// An item variation can be sellable, stockable, or both if it has a unit of measure for its count for the sold number of the variation, the stocked
// number of the variation, or both. For example, when a variation representing wine is stocked and sold by the bottle, the variation is both
// stockable and sellable. But when a variation of the wine is sold by the glass, the sold units cannot be used as a measure of the stocked units. This by-the-glass
// variation is sellable, but not stockable. To accurately keep track of the wine's inventory count at any time, the sellable count must be
// converted to stockable count. Typically, the seller defines this unit conversion. For example, 1 bottle equals 5 glasses. The Square API exposes
// the `stockable_conversion` property on the variation to specify the conversion. Thus, when two glasses of the wine are sold, the sellable count
// decreases by 2, and the stockable count automatically decreases by 0.4 bottle according to the conversion.
type CatalogItemVariation struct {
	// The ID of the `CatalogItem` associated with this item variation.
	ItemId *string `json:"item_id,omitempty" url:"item_id,omitempty"`
	// The item variation's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The item variation's SKU, if any. This is a searchable attribute for use in applicable query filters.
	Sku *string `json:"sku,omitempty" url:"sku,omitempty"`
	// The universal product code (UPC) of the item variation, if any. This is a searchable attribute for use in applicable query filters.
	//
	// The value of this attribute should be a number of 12-14 digits long. This restriction is enforced on the Square Seller Dashboard,
	// Square Point of Sale or Retail Point of Sale apps, where this attribute shows in the GTIN field. If a non-compliant UPC value is assigned
	// to this attribute using the API, the value is not editable on the Seller Dashboard, Square Point of Sale or Retail Point of Sale apps
	// unless it is updated to fit the expected format.
	Upc *string `json:"upc,omitempty" url:"upc,omitempty"`
	// The order in which this item variation should be displayed. This value is read-only. On writes, the ordinal
	// for each item variation within a parent `CatalogItem` is set according to the item variations's
	// position. On reads, the value is not guaranteed to be sequential or unique.
	Ordinal     *int                `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	PriceMoney  *Money              `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Per-location price and inventory overrides.
	LocationOverrides []*ItemVariationLocationOverrides `json:"location_overrides,omitempty" url:"location_overrides,omitempty"`
	// If `true`, inventory tracking is active for the variation.
	TrackInventory     *bool               `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Arbitrary user metadata to associate with the item variation. This attribute value length is of Unicode code points.
	UserData *string `json:"user_data,omitempty" url:"user_data,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, then this is the duration of the service in milliseconds. For
	// example, a 30 minute appointment would have the value `1800000`, which is equal to
	// 30 (minutes) _ 60 (seconds per minute) _ 1000 (milliseconds per second).
	ServiceDuration *int64 `json:"service_duration,omitempty" url:"service_duration,omitempty"`
	// If the `CatalogItem` that owns this item variation is of type
	// `APPOINTMENTS_SERVICE`, a bool representing whether this service is available for booking.
	AvailableForBooking *bool `json:"available_for_booking,omitempty" url:"available_for_booking,omitempty"`
	// List of item option values associated with this item variation. Listed
	// in the same order as the item options of the parent item.
	ItemOptionValues []*CatalogItemOptionValueForItemVariation `json:"item_option_values,omitempty" url:"item_option_values,omitempty"`
	// ID of the ‘CatalogMeasurementUnit’ that is used to measure the quantity
	// sold of this item variation. If left unset, the item will be sold in
	// whole quantities.
	MeasurementUnitId *string `json:"measurement_unit_id,omitempty" url:"measurement_unit_id,omitempty"`
	// Whether this variation can be sold. The inventory count of a sellable variation indicates
	// the number of units available for sale. When a variation is both stockable and sellable,
	// its sellable inventory count can be smaller than or equal to its stockable count.
	Sellable *bool `json:"sellable,omitempty" url:"sellable,omitempty"`
	// Whether stock is counted directly on this variation (TRUE) or only on its components (FALSE).
	// When a variation is both stockable and sellable, the inventory count of a stockable variation keeps track of the number of units of this variation in stock
	// and is not an indicator of the number of units of the variation that can be sold.
	Stockable *bool `json:"stockable,omitempty" url:"stockable,omitempty"`
	// The IDs of images associated with this `CatalogItemVariation` instance.
	// These images will be shown to customers in Square Online Store.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`
	// Tokens of employees that can perform the service represented by this variation. Only valid for
	// variations of type `APPOINTMENTS_SERVICE`.
	TeamMemberIds       []string                `json:"team_member_ids,omitempty" url:"team_member_ids,omitempty"`
	StockableConversion *CatalogStockConversion `json:"stockable_conversion,omitempty" url:"stockable_conversion,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogItemVariation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogItemVariation) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogItemVariation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogItemVariation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogItemVariation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the unit used to measure a `CatalogItemVariation` and
// specifies the precision for decimal quantities.
type CatalogMeasurementUnit struct {
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// An integer between 0 and 5 that represents the maximum number of
	// positions allowed after the decimal in quantities measured with this unit.
	// For example:
	//
	// - if the precision is 0, the quantity can be 1, 2, 3, etc.
	// - if the precision is 1, the quantity can be 0.1, 0.2, etc.
	// - if the precision is 2, the quantity can be 0.01, 0.12, etc.
	//
	// Default: 3
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogMeasurementUnit) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogMeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogMeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogMeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogMeasurementUnit) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A modifier applicable to items at the time of sale.
type CatalogModifier struct {
	// The modifier name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name       *string `json:"name,omitempty" url:"name,omitempty"`
	PriceMoney *Money  `json:"price_money,omitempty" url:"price_money,omitempty"`
	// Determines where this `CatalogModifier` appears in the `CatalogModifierList`.
	Ordinal *int `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	// The ID of the `CatalogModifierList` associated with this modifier.
	ModifierListId *string `json:"modifier_list_id,omitempty" url:"modifier_list_id,omitempty"`
	// The IDs of images associated with this `CatalogModifier` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifier) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifier) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A list of modifiers applicable to items at the time of sale.
//
// For example, a "Condiments" modifier list applicable to a "Hot Dog" item
// may contain "Ketchup", "Mustard", and "Relish" modifiers.
// Use the `selection_type` field to specify whether or not multiple selections from
// the modifier list are allowed.
type CatalogModifierList struct {
	// The name for the `CatalogModifierList` instance. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Determines where this modifier list appears in a list of `CatalogModifierList` values.
	Ordinal       *int                              `json:"ordinal,omitempty" url:"ordinal,omitempty"`
	SelectionType *CatalogModifierListSelectionType `json:"selection_type,omitempty" url:"selection_type,omitempty"`
	// The options included in the `CatalogModifierList`.
	// You must include at least one `CatalogModifier`.
	// Each CatalogObject must have type `MODIFIER` and contain
	// `CatalogModifier` data.
	Modifiers []*CatalogObject `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The IDs of images associated with this `CatalogModifierList` instance.
	// Currently these images are not displayed by Square, but are free to be displayed in 3rd party applications.
	ImageIds []string `json:"image_ids,omitempty" url:"image_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierList) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierList) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierList) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether a CatalogModifierList supports multiple selections.
type CatalogModifierListSelectionType string

const (
	CatalogModifierListSelectionTypeSingle   CatalogModifierListSelectionType = "SINGLE"
	CatalogModifierListSelectionTypeMultiple CatalogModifierListSelectionType = "MULTIPLE"
)

func NewCatalogModifierListSelectionTypeFromString(s string) (CatalogModifierListSelectionType, error) {
	switch s {
	case "SINGLE":
		return CatalogModifierListSelectionTypeSingle, nil
	case "MULTIPLE":
		return CatalogModifierListSelectionTypeMultiple, nil
	}
	var t CatalogModifierListSelectionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogModifierListSelectionType) Ptr() *CatalogModifierListSelectionType {
	return &c
}

// Options to control how to override the default behavior of the specified modifier.
type CatalogModifierOverride struct {
	// The ID of the `CatalogModifier` whose default behavior is being overridden.
	ModifierId string `json:"modifier_id" url:"modifier_id"`
	// If `true`, this `CatalogModifier` should be selected by default for this `CatalogItem`.
	OnByDefault *bool `json:"on_by_default,omitempty" url:"on_by_default,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogModifierOverride) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogModifierOverride) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogModifierOverride
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogModifierOverride(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogModifierOverride) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The wrapper object for the catalog entries of a given object type.
//
// Depending on the `type` attribute value, a `CatalogObject` instance assumes a type-specific data to yield the corresponding type of catalog object.
//
// For example, if `type=ITEM`, the `CatalogObject` instance must have the ITEM-specific data set on the `item_data` attribute. The resulting `CatalogObject` instance is also a `CatalogItem` instance.
//
// In general, if `type=<OBJECT_TYPE>`, the `CatalogObject` instance must have the `<OBJECT_TYPE>`-specific data set on the `<object_type>_data` attribute. The resulting `CatalogObject` instance is also a `Catalog<ObjectType>` instance.
//
// For a more detailed discussion of the Catalog data model, please see the
// [Design a Catalog](https://developer.squareup.com/docs/catalog-api/design-a-catalog) guide.
type CatalogObject struct {
	Type CatalogObjectType `json:"type" url:"type"`
	// An identifier to reference this object in the catalog. When a new `CatalogObject`
	// is inserted, the client should set the id to a temporary identifier starting with
	// a "`#`" character. Other objects being inserted or updated within the same request
	// may use this identifier to refer to the new object.
	//
	// When the server receives the new object, it will supply a unique identifier that
	// replaces the temporary identifier for all future references.
	Id string `json:"id" url:"id"`
	// Last modification [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates) in RFC 3339 format, e.g., `"2016-08-15T23:59:33.123Z"`
	// would indicate the UTC time (denoted by `Z`) of August 15, 2016 at 23:59:33 and 123 milliseconds.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The version of the object. When updating an object, the version supplied
	// must match the version in the database, otherwise the write will be rejected as conflicting.
	Version *int64 `json:"version,omitempty" url:"version,omitempty"`
	// If `true`, the object has been deleted from the database. Must be `false` for new objects
	// being inserted. When deleted, the `updated_at` field will equal the deletion time.
	IsDeleted *bool `json:"is_deleted,omitempty" url:"is_deleted,omitempty"`
	// A map (key-value pairs) of application-defined custom attribute values. The value of a key-value pair
	// is a [CatalogCustomAttributeValue](entity:CatalogCustomAttributeValue) object. The key is the `key` attribute
	// value defined in the associated [CatalogCustomAttributeDefinition](entity:CatalogCustomAttributeDefinition)
	// object defined by the application making the request.
	//
	// If the `CatalogCustomAttributeDefinition` object is
	// defined by another application, the `CatalogCustomAttributeDefinition`'s key attribute value is prefixed by
	// the defining application ID. For example, if the `CatalogCustomAttributeDefinition` has a `key` attribute of
	// `"cocoa_brand"` and the defining application ID is `"abcd1234"`, the key in the map is `"abcd1234:cocoa_brand"`
	// if the application making the request is different from the application defining the custom attribute definition.
	// Otherwise, the key used in the map is simply `"cocoa_brand"`.
	//
	// Application-defined custom attributes are set at a global (location-independent) level.
	// Custom attribute values are intended to store additional information about a catalog object
	// or associations with an entity in another system. Do not use custom attributes
	// to store any sensitive information (personally identifiable information, card details, etc.).
	CustomAttributeValues map[string]*CatalogCustomAttributeValue `json:"custom_attribute_values,omitempty" url:"custom_attribute_values,omitempty"`
	// The Connect v1 IDs for this object at each location where it is present, where they
	// differ from the object's Connect V2 ID. The field will only be present for objects that
	// have been created or modified by legacy APIs.
	CatalogV1Ids []*CatalogV1Id `json:"catalog_v1_ids,omitempty" url:"catalog_v1_ids,omitempty"`
	// If `true`, this object is present at all locations (including future locations), except where specified in
	// the `absent_at_location_ids` field. If `false`, this object is not present at any locations (including future locations),
	// except where specified in the `present_at_location_ids` field. If not specified, defaults to `true`.
	PresentAtAllLocations *bool `json:"present_at_all_locations,omitempty" url:"present_at_all_locations,omitempty"`
	// A list of locations where the object is present, even if `present_at_all_locations` is `false`.
	// This can include locations that are deactivated.
	PresentAtLocationIds []string `json:"present_at_location_ids,omitempty" url:"present_at_location_ids,omitempty"`
	// A list of locations where the object is not present, even if `present_at_all_locations` is `true`.
	// This can include locations that are deactivated.
	AbsentAtLocationIds []string `json:"absent_at_location_ids,omitempty" url:"absent_at_location_ids,omitempty"`
	// Identifies the `CatalogImage` attached to this `CatalogObject`.
	ImageId                       *string                           `json:"image_id,omitempty" url:"image_id,omitempty"`
	ItemData                      *CatalogItem                      `json:"item_data,omitempty" url:"item_data,omitempty"`
	CategoryData                  *CatalogCategory                  `json:"category_data,omitempty" url:"category_data,omitempty"`
	ItemVariationData             *CatalogItemVariation             `json:"item_variation_data,omitempty" url:"item_variation_data,omitempty"`
	TaxData                       *CatalogTax                       `json:"tax_data,omitempty" url:"tax_data,omitempty"`
	DiscountData                  *CatalogDiscount                  `json:"discount_data,omitempty" url:"discount_data,omitempty"`
	ModifierListData              *CatalogModifierList              `json:"modifier_list_data,omitempty" url:"modifier_list_data,omitempty"`
	ModifierData                  *CatalogModifier                  `json:"modifier_data,omitempty" url:"modifier_data,omitempty"`
	TimePeriodData                *CatalogTimePeriod                `json:"time_period_data,omitempty" url:"time_period_data,omitempty"`
	ProductSetData                *CatalogProductSet                `json:"product_set_data,omitempty" url:"product_set_data,omitempty"`
	PricingRuleData               *CatalogPricingRule               `json:"pricing_rule_data,omitempty" url:"pricing_rule_data,omitempty"`
	ImageData                     *CatalogImage                     `json:"image_data,omitempty" url:"image_data,omitempty"`
	MeasurementUnitData           *CatalogMeasurementUnit           `json:"measurement_unit_data,omitempty" url:"measurement_unit_data,omitempty"`
	SubscriptionPlanData          *CatalogSubscriptionPlan          `json:"subscription_plan_data,omitempty" url:"subscription_plan_data,omitempty"`
	ItemOptionData                *CatalogItemOption                `json:"item_option_data,omitempty" url:"item_option_data,omitempty"`
	ItemOptionValueData           *CatalogItemOptionValue           `json:"item_option_value_data,omitempty" url:"item_option_value_data,omitempty"`
	CustomAttributeDefinitionData *CatalogCustomAttributeDefinition `json:"custom_attribute_definition_data,omitempty" url:"custom_attribute_definition_data,omitempty"`
	QuickAmountsSettingsData      *CatalogQuickAmountsSettings      `json:"quick_amounts_settings_data,omitempty" url:"quick_amounts_settings_data,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogObject) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogObject) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogObject
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogObject(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogObject) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Possible types of CatalogObjects returned from the catalog, each
// containing type-specific properties in the `*_data` field corresponding to the specfied object type.
type CatalogObjectType string

const (
	CatalogObjectTypeCatalogObjectTypeDoNotUse CatalogObjectType = "CATALOG_OBJECT_TYPE_DO_NOT_USE"
	CatalogObjectTypeItem                      CatalogObjectType = "ITEM"
	CatalogObjectTypeImage                     CatalogObjectType = "IMAGE"
	CatalogObjectTypeCategory                  CatalogObjectType = "CATEGORY"
	CatalogObjectTypeItemVariation             CatalogObjectType = "ITEM_VARIATION"
	CatalogObjectTypeTax                       CatalogObjectType = "TAX"
	CatalogObjectTypeDiscount                  CatalogObjectType = "DISCOUNT"
	CatalogObjectTypeModifierList              CatalogObjectType = "MODIFIER_LIST"
	CatalogObjectTypeModifier                  CatalogObjectType = "MODIFIER"
	CatalogObjectTypeDiningOption              CatalogObjectType = "DINING_OPTION"
	CatalogObjectTypeTaxExemption              CatalogObjectType = "TAX_EXEMPTION"
	CatalogObjectTypeServiceCharge             CatalogObjectType = "SERVICE_CHARGE"
	CatalogObjectTypePricingRule               CatalogObjectType = "PRICING_RULE"
	CatalogObjectTypeProductSet                CatalogObjectType = "PRODUCT_SET"
	CatalogObjectTypeTimePeriod                CatalogObjectType = "TIME_PERIOD"
	CatalogObjectTypeMeasurementUnit           CatalogObjectType = "MEASUREMENT_UNIT"
	CatalogObjectTypeSubscriptionPlan          CatalogObjectType = "SUBSCRIPTION_PLAN"
	CatalogObjectTypeItemOption                CatalogObjectType = "ITEM_OPTION"
	CatalogObjectTypeItemOptionVal             CatalogObjectType = "ITEM_OPTION_VAL"
	CatalogObjectTypeCustomAttributeDefinition CatalogObjectType = "CUSTOM_ATTRIBUTE_DEFINITION"
	CatalogObjectTypeQuickAmountsSettings      CatalogObjectType = "QUICK_AMOUNTS_SETTINGS"
	CatalogObjectTypeComponent                 CatalogObjectType = "COMPONENT"
	CatalogObjectTypeComposition               CatalogObjectType = "COMPOSITION"
	CatalogObjectTypeResource                  CatalogObjectType = "RESOURCE"
	CatalogObjectTypeCheckoutLink              CatalogObjectType = "CHECKOUT_LINK"
	CatalogObjectTypeAddress                   CatalogObjectType = "ADDRESS"
	CatalogObjectTypeSubscriptionProduct       CatalogObjectType = "SUBSCRIPTION_PRODUCT"
)

func NewCatalogObjectTypeFromString(s string) (CatalogObjectType, error) {
	switch s {
	case "CATALOG_OBJECT_TYPE_DO_NOT_USE":
		return CatalogObjectTypeCatalogObjectTypeDoNotUse, nil
	case "ITEM":
		return CatalogObjectTypeItem, nil
	case "IMAGE":
		return CatalogObjectTypeImage, nil
	case "CATEGORY":
		return CatalogObjectTypeCategory, nil
	case "ITEM_VARIATION":
		return CatalogObjectTypeItemVariation, nil
	case "TAX":
		return CatalogObjectTypeTax, nil
	case "DISCOUNT":
		return CatalogObjectTypeDiscount, nil
	case "MODIFIER_LIST":
		return CatalogObjectTypeModifierList, nil
	case "MODIFIER":
		return CatalogObjectTypeModifier, nil
	case "DINING_OPTION":
		return CatalogObjectTypeDiningOption, nil
	case "TAX_EXEMPTION":
		return CatalogObjectTypeTaxExemption, nil
	case "SERVICE_CHARGE":
		return CatalogObjectTypeServiceCharge, nil
	case "PRICING_RULE":
		return CatalogObjectTypePricingRule, nil
	case "PRODUCT_SET":
		return CatalogObjectTypeProductSet, nil
	case "TIME_PERIOD":
		return CatalogObjectTypeTimePeriod, nil
	case "MEASUREMENT_UNIT":
		return CatalogObjectTypeMeasurementUnit, nil
	case "SUBSCRIPTION_PLAN":
		return CatalogObjectTypeSubscriptionPlan, nil
	case "ITEM_OPTION":
		return CatalogObjectTypeItemOption, nil
	case "ITEM_OPTION_VAL":
		return CatalogObjectTypeItemOptionVal, nil
	case "CUSTOM_ATTRIBUTE_DEFINITION":
		return CatalogObjectTypeCustomAttributeDefinition, nil
	case "QUICK_AMOUNTS_SETTINGS":
		return CatalogObjectTypeQuickAmountsSettings, nil
	case "COMPONENT":
		return CatalogObjectTypeComponent, nil
	case "COMPOSITION":
		return CatalogObjectTypeComposition, nil
	case "RESOURCE":
		return CatalogObjectTypeResource, nil
	case "CHECKOUT_LINK":
		return CatalogObjectTypeCheckoutLink, nil
	case "ADDRESS":
		return CatalogObjectTypeAddress, nil
	case "SUBSCRIPTION_PRODUCT":
		return CatalogObjectTypeSubscriptionProduct, nil
	}
	var t CatalogObjectType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogObjectType) Ptr() *CatalogObjectType {
	return &c
}

// Defines how discounts are automatically applied to a set of items that match the pricing rule
// during the active time period.
type CatalogPricingRule struct {
	// User-defined name for the pricing rule. For example, "Buy one get one
	// free" or "10% off".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// A list of unique IDs for the catalog time periods when
	// this pricing rule is in effect. If left unset, the pricing rule is always
	// in effect.
	TimePeriodIds []string `json:"time_period_ids,omitempty" url:"time_period_ids,omitempty"`
	// Unique ID for the `CatalogDiscount` to take off
	// the price of all matched items.
	DiscountId *string `json:"discount_id,omitempty" url:"discount_id,omitempty"`
	// Unique ID for the `CatalogProductSet` that will be matched by this rule. A match rule
	// matches within the entire cart, and can match multiple times. This field will always be set.
	MatchProductsId *string `json:"match_products_id,omitempty" url:"match_products_id,omitempty"`
	// **Deprecated**: Please use the `exclude_products_id` field to apply
	// an exclude set instead. Exclude sets allow better control over quantity
	// ranges and offer more flexibility for which matched items receive a discount.
	//
	// `CatalogProductSet` to apply the pricing to.
	// An apply rule matches within the subset of the cart that fits the match rules (the match set).
	// An apply rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ApplyProductsId *string `json:"apply_products_id,omitempty" url:"apply_products_id,omitempty"`
	// `CatalogProductSet` to exclude from the pricing rule.
	// An exclude rule matches within the subset of the cart that fits the match rules (the match set).
	// An exclude rule can only match once in the match set.
	// If not supplied, the pricing will be applied to all products in the match set.
	// Other products retain their base price, or a price generated by other rules.
	ExcludeProductsId *string `json:"exclude_products_id,omitempty" url:"exclude_products_id,omitempty"`
	// Represents the date the Pricing Rule is valid from. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidFromDate *string `json:"valid_from_date,omitempty" url:"valid_from_date,omitempty"`
	// Represents the local time the pricing rule should be valid from. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidFromLocalTime *string `json:"valid_from_local_time,omitempty" url:"valid_from_local_time,omitempty"`
	// Represents the date the Pricing Rule is valid until. Represented in RFC 3339 full-date format (YYYY-MM-DD).
	ValidUntilDate *string `json:"valid_until_date,omitempty" url:"valid_until_date,omitempty"`
	// Represents the local time the pricing rule should be valid until. Represented in RFC 3339 partial-time format
	// (HH:MM:SS). Partial seconds will be truncated.
	ValidUntilLocalTime       *string          `json:"valid_until_local_time,omitempty" url:"valid_until_local_time,omitempty"`
	ExcludeStrategy           *ExcludeStrategy `json:"exclude_strategy,omitempty" url:"exclude_strategy,omitempty"`
	MinimumOrderSubtotalMoney *Money           `json:"minimum_order_subtotal_money,omitempty" url:"minimum_order_subtotal_money,omitempty"`
	// A list of IDs of customer groups, the members of which are eligible for discounts specified in this pricing rule.
	// Notice that a group ID is generated by the Customers API.
	// If this field is not set, the specified discount applies to matched products sold to anyone whether the buyer
	// has a customer profile created or not. If this `customer_group_ids_any` field is set, the specified discount
	// applies only to matched products sold to customers belonging to the specified customer groups.
	CustomerGroupIdsAny []string `json:"customer_group_ids_any,omitempty" url:"customer_group_ids_any,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogPricingRule) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogPricingRule) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogPricingRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogPricingRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogPricingRule) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates whether the price of a CatalogItemVariation should be entered manually at the time of sale.
type CatalogPricingType string

const (
	CatalogPricingTypeFixedPricing    CatalogPricingType = "FIXED_PRICING"
	CatalogPricingTypeVariablePricing CatalogPricingType = "VARIABLE_PRICING"
)

func NewCatalogPricingTypeFromString(s string) (CatalogPricingType, error) {
	switch s {
	case "FIXED_PRICING":
		return CatalogPricingTypeFixedPricing, nil
	case "VARIABLE_PRICING":
		return CatalogPricingTypeVariablePricing, nil
	}
	var t CatalogPricingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogPricingType) Ptr() *CatalogPricingType {
	return &c
}

// Represents a collection of catalog objects for the purpose of applying a
// `PricingRule`. Including a catalog object will include all of its subtypes.
// For example, including a category in a product set will include all of its
// items and associated item variations in the product set. Including an item in
// a product set will also include its item variations.
type CatalogProductSet struct {
	// User-defined name for the product set. For example, "Clearance Items"
	// or "Winter Sale Items".
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set. Any
	// number of these catalog objects can be in an order for a pricing rule to apply.
	//
	// This can be used with `product_ids_all` in a parent `CatalogProductSet` to
	// match groups of products for a bulk discount, such as a discount for an
	// entree and side combo.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIdsAny []string `json:"product_ids_any,omitempty" url:"product_ids_any,omitempty"`
	// Unique IDs for any `CatalogObject` included in this product set.
	// All objects in this set must be included in an order for a pricing rule to apply.
	//
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	//
	// Max: 500 catalog object IDs.
	ProductIdsAll []string `json:"product_ids_all,omitempty" url:"product_ids_all,omitempty"`
	// If set, there must be exactly this many items from `products_any` or `products_all`
	// in the cart for the discount to apply.
	//
	// Cannot be combined with either `quantity_min` or `quantity_max`.
	QuantityExact *int64 `json:"quantity_exact,omitempty" url:"quantity_exact,omitempty"`
	// If set, there must be at least this many items from `products_any` or `products_all`
	// in a cart for the discount to apply. See `quantity_exact`. Defaults to 0 if
	// `quantity_exact`, `quantity_min` and `quantity_max` are all unspecified.
	QuantityMin *int64 `json:"quantity_min,omitempty" url:"quantity_min,omitempty"`
	// If set, the pricing rule will apply to a maximum of this many items from
	// `products_any` or `products_all`.
	QuantityMax *int64 `json:"quantity_max,omitempty" url:"quantity_max,omitempty"`
	// If set to `true`, the product set will include every item in the catalog.
	// Only one of `product_ids_all`, `product_ids_any`, or `all_products` can be set.
	AllProducts *bool `json:"all_products,omitempty" url:"all_products,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogProductSet) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogProductSet) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogProductSet
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogProductSet(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogProductSet) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a Quick Amount in the Catalog.
type CatalogQuickAmount struct {
	Type   CatalogQuickAmountType `json:"type" url:"type"`
	Amount *Money                 `json:"amount,omitempty" url:"amount,omitempty"`
	// Describes the ranking of the Quick Amount provided by machine learning model, in the range [0, 100].
	// MANUAL type amount will always have score = 100.
	Score *int64 `json:"score,omitempty" url:"score,omitempty"`
	// The order in which this Quick Amount should be displayed.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmount) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmount) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines the type of a specific Quick Amount.
type CatalogQuickAmountType string

const (
	CatalogQuickAmountTypeQuickAmountTypeDoNotUse CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_DO_NOT_USE"
	CatalogQuickAmountTypeQuickAmountTypeManual   CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_MANUAL"
	CatalogQuickAmountTypeQuickAmountTypeAuto     CatalogQuickAmountType = "QUICK_AMOUNT_TYPE_AUTO"
)

func NewCatalogQuickAmountTypeFromString(s string) (CatalogQuickAmountType, error) {
	switch s {
	case "QUICK_AMOUNT_TYPE_DO_NOT_USE":
		return CatalogQuickAmountTypeQuickAmountTypeDoNotUse, nil
	case "QUICK_AMOUNT_TYPE_MANUAL":
		return CatalogQuickAmountTypeQuickAmountTypeManual, nil
	case "QUICK_AMOUNT_TYPE_AUTO":
		return CatalogQuickAmountTypeQuickAmountTypeAuto, nil
	}
	var t CatalogQuickAmountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountType) Ptr() *CatalogQuickAmountType {
	return &c
}

// A parent Catalog Object model represents a set of Quick Amounts and the settings control the amounts.
type CatalogQuickAmountsSettings struct {
	Option CatalogQuickAmountsSettingsOption `json:"option" url:"option"`
	// Represents location's eligibility for auto amounts
	// The boolean should be consistent with whether there are AUTO amounts in the `amounts`.
	EligibleForAutoAmounts *bool `json:"eligible_for_auto_amounts,omitempty" url:"eligible_for_auto_amounts,omitempty"`
	// Represents a set of Quick Amounts at this location.
	Amounts []*CatalogQuickAmount `json:"amounts,omitempty" url:"amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogQuickAmountsSettings) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogQuickAmountsSettings) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogQuickAmountsSettings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogQuickAmountsSettings(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogQuickAmountsSettings) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Determines a seller's option on Quick Amounts feature.
type CatalogQuickAmountsSettingsOption string

const (
	CatalogQuickAmountsSettingsOptionQuickAmountsSettingsOptionDoNotUse CatalogQuickAmountsSettingsOption = "QUICK_AMOUNTS_SETTINGS_OPTION_DO_NOT_USE"
	CatalogQuickAmountsSettingsOptionDisabled                           CatalogQuickAmountsSettingsOption = "DISABLED"
	CatalogQuickAmountsSettingsOptionManual                             CatalogQuickAmountsSettingsOption = "MANUAL"
	CatalogQuickAmountsSettingsOptionAuto                               CatalogQuickAmountsSettingsOption = "AUTO"
)

func NewCatalogQuickAmountsSettingsOptionFromString(s string) (CatalogQuickAmountsSettingsOption, error) {
	switch s {
	case "QUICK_AMOUNTS_SETTINGS_OPTION_DO_NOT_USE":
		return CatalogQuickAmountsSettingsOptionQuickAmountsSettingsOptionDoNotUse, nil
	case "DISABLED":
		return CatalogQuickAmountsSettingsOptionDisabled, nil
	case "MANUAL":
		return CatalogQuickAmountsSettingsOptionManual, nil
	case "AUTO":
		return CatalogQuickAmountsSettingsOptionAuto, nil
	}
	var t CatalogQuickAmountsSettingsOption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CatalogQuickAmountsSettingsOption) Ptr() *CatalogQuickAmountsSettingsOption {
	return &c
}

// Represents the rule of conversion between a stockable [CatalogItemVariation](entity:CatalogItemVariation)
// and a non-stockable sell-by or receive-by `CatalogItemVariation` that
// share the same underlying stock.
type CatalogStockConversion struct {
	// References to the stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// for this stock conversion. Selling, receiving or recounting the non-stockable `CatalogItemVariation`
	// defined with a stock conversion results in adjustments of this stockable `CatalogItemVariation`.
	// This immutable field must reference a stockable `CatalogItemVariation`
	// that shares the parent [CatalogItem](entity:CatalogItem) of the converted `CatalogItemVariation.`
	StockableItemVariationId string `json:"stockable_item_variation_id" url:"stockable_item_variation_id"`
	// The quantity of the stockable item variation (as identified by `stockable_item_variation_id`)
	// equivalent to the non-stockable item variation quantity (as specified in `nonstockable_quantity`)
	// as defined by this stock conversion. It accepts a decimal number in a string format that can take
	// up to 10 digits before the decimal point and up to 5 digits after the decimal point.
	StockableQuantity string `json:"stockable_quantity" url:"stockable_quantity"`
	// The converted equivalent quantity of the non-stockable [CatalogItemVariation](entity:CatalogItemVariation)
	// in its measurement unit. The `stockable_quantity` value and this `nonstockable_quantity` value together
	// define the conversion ratio between stockable item variation and the non-stockable item variation.
	// It accepts a decimal number in a string format that can take up to 10 digits before the decimal point
	// and up to 5 digits after the decimal point.
	NonstockableQuantity string `json:"nonstockable_quantity" url:"nonstockable_quantity"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogStockConversion) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogStockConversion) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogStockConversion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogStockConversion(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogStockConversion) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Describes a subscription plan. For more information, see
// [Set Up and Manage a Subscription Plan](https://developer.squareup.com/docs/subscriptions-api/setup-plan).
type CatalogSubscriptionPlan struct {
	// The name of the plan.
	Name string `json:"name" url:"name"`
	// A list of SubscriptionPhase containing the [SubscriptionPhase](entity:SubscriptionPhase) for this plan.
	Phases []*SubscriptionPhase `json:"phases,omitempty" url:"phases,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogSubscriptionPlan) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogSubscriptionPlan) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogSubscriptionPlan
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogSubscriptionPlan(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogSubscriptionPlan) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A tax applicable to an item.
type CatalogTax struct {
	// The tax's name. This is a searchable attribute for use in applicable query filters, and its value length is of Unicode code points.
	Name             *string              `json:"name,omitempty" url:"name,omitempty"`
	CalculationPhase *TaxCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	InclusionType    *TaxInclusionType    `json:"inclusion_type,omitempty" url:"inclusion_type,omitempty"`
	// The percentage of the tax in decimal form, using a `'.'` as the decimal separator and without a `'%'` sign.
	// A value of `7.5` corresponds to 7.5%. For a location-specific tax rate, contact the tax authority of the location or a tax consultant.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// If `true`, the fee applies to custom amounts entered into the Square Point of Sale
	// app that are not associated with a particular `CatalogItem`.
	AppliesToCustomAmounts *bool `json:"applies_to_custom_amounts,omitempty" url:"applies_to_custom_amounts,omitempty"`
	// A Boolean flag to indicate whether the tax is displayed as enabled (`true`) in the Square Point of Sale app or not (`false`).
	Enabled *bool `json:"enabled,omitempty" url:"enabled,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTax) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTax) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents a time period - either a single period or a repeating period.
type CatalogTimePeriod struct {
	// An iCalendar (RFC 5545) [event](https://tools.ietf.org/html/rfc5545#section-3.6.1), which
	// specifies the name, timing, duration and recurrence of this time period.
	//
	// Example:
	//
	// ```
	// DTSTART:20190707T180000
	// DURATION:P2H
	// RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR
	// ```
	//
	// Only `SUMMARY`, `DTSTART`, `DURATION` and `RRULE` fields are supported.
	// `DTSTART` must be in local (unzoned) time format. Note that while `BEGIN:VEVENT`
	// and `END:VEVENT` is not required in the request. The response will always
	// include them.
	Event *string `json:"event,omitempty" url:"event,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogTimePeriod) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogTimePeriod) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogTimePeriod
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogTimePeriod(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogTimePeriod) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// A Square API V1 identifier of an item, including the object ID and its associated location ID.
type CatalogV1Id struct {
	// The ID for an object used in the Square API V1, if the object ID differs from the Square API V2 object ID.
	CatalogV1Id *string `json:"catalog_v1_id,omitempty" url:"catalog_v1_id,omitempty"`
	// The ID of the `Location` this Connect V1 ID is associated with.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CatalogV1Id) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CatalogV1Id) UnmarshalJSON(data []byte) error {
	type unmarshaler CatalogV1Id
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CatalogV1Id(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CatalogV1Id) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Additional details about Clearpay payments.
type ClearpayDetails struct {
	// Email address on the buyer's Clearpay account.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ClearpayDetails) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ClearpayDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ClearpayDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClearpayDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClearpayDetails) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Latitude and longitude coordinates.
type Coordinates struct {
	// The latitude of the coordinate expressed in degrees.
	Latitude *float64 `json:"latitude,omitempty" url:"latitude,omitempty"`
	// The longitude of the coordinate expressed in degrees.
	Longitude *float64 `json:"longitude,omitempty" url:"longitude,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Coordinates) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Coordinates) UnmarshalJSON(data []byte) error {
	type unmarshaler Coordinates
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Coordinates(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Coordinates) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the country associated with another entity, such as a business.
// Values are in [ISO 3166-1-alpha-2 format](http://www.iso.org/iso/home/standards/country_codes.htm).
type Country string

const (
	CountryZz Country = "ZZ"
	CountryAd Country = "AD"
	CountryAe Country = "AE"
	CountryAf Country = "AF"
	CountryAg Country = "AG"
	CountryAi Country = "AI"
	CountryAl Country = "AL"
	CountryAm Country = "AM"
	CountryAo Country = "AO"
	CountryAq Country = "AQ"
	CountryAr Country = "AR"
	CountryAs Country = "AS"
	CountryAt Country = "AT"
	CountryAu Country = "AU"
	CountryAw Country = "AW"
	CountryAx Country = "AX"
	CountryAz Country = "AZ"
	CountryBa Country = "BA"
	CountryBb Country = "BB"
	CountryBd Country = "BD"
	CountryBe Country = "BE"
	CountryBf Country = "BF"
	CountryBg Country = "BG"
	CountryBh Country = "BH"
	CountryBi Country = "BI"
	CountryBj Country = "BJ"
	CountryBl Country = "BL"
	CountryBm Country = "BM"
	CountryBn Country = "BN"
	CountryBo Country = "BO"
	CountryBq Country = "BQ"
	CountryBr Country = "BR"
	CountryBs Country = "BS"
	CountryBt Country = "BT"
	CountryBv Country = "BV"
	CountryBw Country = "BW"
	CountryBy Country = "BY"
	CountryBz Country = "BZ"
	CountryCa Country = "CA"
	CountryCc Country = "CC"
	CountryCd Country = "CD"
	CountryCf Country = "CF"
	CountryCg Country = "CG"
	CountryCh Country = "CH"
	CountryCi Country = "CI"
	CountryCk Country = "CK"
	CountryCl Country = "CL"
	CountryCm Country = "CM"
	CountryCn Country = "CN"
	CountryCo Country = "CO"
	CountryCr Country = "CR"
	CountryCu Country = "CU"
	CountryCv Country = "CV"
	CountryCw Country = "CW"
	CountryCx Country = "CX"
	CountryCy Country = "CY"
	CountryCz Country = "CZ"
	CountryDe Country = "DE"
	CountryDj Country = "DJ"
	CountryDk Country = "DK"
	CountryDm Country = "DM"
	CountryDo Country = "DO"
	CountryDz Country = "DZ"
	CountryEc Country = "EC"
	CountryEe Country = "EE"
	CountryEg Country = "EG"
	CountryEh Country = "EH"
	CountryEr Country = "ER"
	CountryEs Country = "ES"
	CountryEt Country = "ET"
	CountryFi Country = "FI"
	CountryFj Country = "FJ"
	CountryFk Country = "FK"
	CountryFm Country = "FM"
	CountryFo Country = "FO"
	CountryFr Country = "FR"
	CountryGa Country = "GA"
	CountryGb Country = "GB"
	CountryGd Country = "GD"
	CountryGe Country = "GE"
	CountryGf Country = "GF"
	CountryGg Country = "GG"
	CountryGh Country = "GH"
	CountryGi Country = "GI"
	CountryGl Country = "GL"
	CountryGm Country = "GM"
	CountryGn Country = "GN"
	CountryGp Country = "GP"
	CountryGq Country = "GQ"
	CountryGr Country = "GR"
	CountryGs Country = "GS"
	CountryGt Country = "GT"
	CountryGu Country = "GU"
	CountryGw Country = "GW"
	CountryGy Country = "GY"
	CountryHk Country = "HK"
	CountryHm Country = "HM"
	CountryHn Country = "HN"
	CountryHr Country = "HR"
	CountryHt Country = "HT"
	CountryHu Country = "HU"
	CountryId Country = "ID"
	CountryIe Country = "IE"
	CountryIl Country = "IL"
	CountryIm Country = "IM"
	CountryIn Country = "IN"
	CountryIo Country = "IO"
	CountryIq Country = "IQ"
	CountryIr Country = "IR"
	CountryIs Country = "IS"
	CountryIt Country = "IT"
	CountryJe Country = "JE"
	CountryJm Country = "JM"
	CountryJo Country = "JO"
	CountryJp Country = "JP"
	CountryKe Country = "KE"
	CountryKg Country = "KG"
	CountryKh Country = "KH"
	CountryKi Country = "KI"
	CountryKm Country = "KM"
	CountryKn Country = "KN"
	CountryKp Country = "KP"
	CountryKr Country = "KR"
	CountryKw Country = "KW"
	CountryKy Country = "KY"
	CountryKz Country = "KZ"
	CountryLa Country = "LA"
	CountryLb Country = "LB"
	CountryLc Country = "LC"
	CountryLi Country = "LI"
	CountryLk Country = "LK"
	CountryLr Country = "LR"
	CountryLs Country = "LS"
	CountryLt Country = "LT"
	CountryLu Country = "LU"
	CountryLv Country = "LV"
	CountryLy Country = "LY"
	CountryMa Country = "MA"
	CountryMc Country = "MC"
	CountryMd Country = "MD"
	CountryMe Country = "ME"
	CountryMf Country = "MF"
	CountryMg Country = "MG"
	CountryMh Country = "MH"
	CountryMk Country = "MK"
	CountryMl Country = "ML"
	CountryMm Country = "MM"
	CountryMn Country = "MN"
	CountryMo Country = "MO"
	CountryMp Country = "MP"
	CountryMq Country = "MQ"
	CountryMr Country = "MR"
	CountryMs Country = "MS"
	CountryMt Country = "MT"
	CountryMu Country = "MU"
	CountryMv Country = "MV"
	CountryMw Country = "MW"
	CountryMx Country = "MX"
	CountryMy Country = "MY"
	CountryMz Country = "MZ"
	CountryNa Country = "NA"
	CountryNc Country = "NC"
	CountryNe Country = "NE"
	CountryNf Country = "NF"
	CountryNg Country = "NG"
	CountryNi Country = "NI"
	CountryNl Country = "NL"
	CountryNo Country = "NO"
	CountryNp Country = "NP"
	CountryNr Country = "NR"
	CountryNu Country = "NU"
	CountryNz Country = "NZ"
	CountryOm Country = "OM"
	CountryPa Country = "PA"
	CountryPe Country = "PE"
	CountryPf Country = "PF"
	CountryPg Country = "PG"
	CountryPh Country = "PH"
	CountryPk Country = "PK"
	CountryPl Country = "PL"
	CountryPm Country = "PM"
	CountryPn Country = "PN"
	CountryPr Country = "PR"
	CountryPs Country = "PS"
	CountryPt Country = "PT"
	CountryPw Country = "PW"
	CountryPy Country = "PY"
	CountryQa Country = "QA"
	CountryRe Country = "RE"
	CountryRo Country = "RO"
	CountryRs Country = "RS"
	CountryRu Country = "RU"
	CountryRw Country = "RW"
	CountrySa Country = "SA"
	CountrySb Country = "SB"
	CountrySc Country = "SC"
	CountrySd Country = "SD"
	CountrySe Country = "SE"
	CountrySg Country = "SG"
	CountrySh Country = "SH"
	CountrySi Country = "SI"
	CountrySj Country = "SJ"
	CountrySk Country = "SK"
	CountrySl Country = "SL"
	CountrySm Country = "SM"
	CountrySn Country = "SN"
	CountrySo Country = "SO"
	CountrySr Country = "SR"
	CountrySs Country = "SS"
	CountrySt Country = "ST"
	CountrySv Country = "SV"
	CountrySx Country = "SX"
	CountrySy Country = "SY"
	CountrySz Country = "SZ"
	CountryTc Country = "TC"
	CountryTd Country = "TD"
	CountryTf Country = "TF"
	CountryTg Country = "TG"
	CountryTh Country = "TH"
	CountryTj Country = "TJ"
	CountryTk Country = "TK"
	CountryTl Country = "TL"
	CountryTm Country = "TM"
	CountryTn Country = "TN"
	CountryTo Country = "TO"
	CountryTr Country = "TR"
	CountryTt Country = "TT"
	CountryTv Country = "TV"
	CountryTw Country = "TW"
	CountryTz Country = "TZ"
	CountryUa Country = "UA"
	CountryUg Country = "UG"
	CountryUm Country = "UM"
	CountryUs Country = "US"
	CountryUy Country = "UY"
	CountryUz Country = "UZ"
	CountryVa Country = "VA"
	CountryVc Country = "VC"
	CountryVe Country = "VE"
	CountryVg Country = "VG"
	CountryVi Country = "VI"
	CountryVn Country = "VN"
	CountryVu Country = "VU"
	CountryWf Country = "WF"
	CountryWs Country = "WS"
	CountryYe Country = "YE"
	CountryYt Country = "YT"
	CountryZa Country = "ZA"
	CountryZm Country = "ZM"
	CountryZw Country = "ZW"
)

func NewCountryFromString(s string) (Country, error) {
	switch s {
	case "ZZ":
		return CountryZz, nil
	case "AD":
		return CountryAd, nil
	case "AE":
		return CountryAe, nil
	case "AF":
		return CountryAf, nil
	case "AG":
		return CountryAg, nil
	case "AI":
		return CountryAi, nil
	case "AL":
		return CountryAl, nil
	case "AM":
		return CountryAm, nil
	case "AO":
		return CountryAo, nil
	case "AQ":
		return CountryAq, nil
	case "AR":
		return CountryAr, nil
	case "AS":
		return CountryAs, nil
	case "AT":
		return CountryAt, nil
	case "AU":
		return CountryAu, nil
	case "AW":
		return CountryAw, nil
	case "AX":
		return CountryAx, nil
	case "AZ":
		return CountryAz, nil
	case "BA":
		return CountryBa, nil
	case "BB":
		return CountryBb, nil
	case "BD":
		return CountryBd, nil
	case "BE":
		return CountryBe, nil
	case "BF":
		return CountryBf, nil
	case "BG":
		return CountryBg, nil
	case "BH":
		return CountryBh, nil
	case "BI":
		return CountryBi, nil
	case "BJ":
		return CountryBj, nil
	case "BL":
		return CountryBl, nil
	case "BM":
		return CountryBm, nil
	case "BN":
		return CountryBn, nil
	case "BO":
		return CountryBo, nil
	case "BQ":
		return CountryBq, nil
	case "BR":
		return CountryBr, nil
	case "BS":
		return CountryBs, nil
	case "BT":
		return CountryBt, nil
	case "BV":
		return CountryBv, nil
	case "BW":
		return CountryBw, nil
	case "BY":
		return CountryBy, nil
	case "BZ":
		return CountryBz, nil
	case "CA":
		return CountryCa, nil
	case "CC":
		return CountryCc, nil
	case "CD":
		return CountryCd, nil
	case "CF":
		return CountryCf, nil
	case "CG":
		return CountryCg, nil
	case "CH":
		return CountryCh, nil
	case "CI":
		return CountryCi, nil
	case "CK":
		return CountryCk, nil
	case "CL":
		return CountryCl, nil
	case "CM":
		return CountryCm, nil
	case "CN":
		return CountryCn, nil
	case "CO":
		return CountryCo, nil
	case "CR":
		return CountryCr, nil
	case "CU":
		return CountryCu, nil
	case "CV":
		return CountryCv, nil
	case "CW":
		return CountryCw, nil
	case "CX":
		return CountryCx, nil
	case "CY":
		return CountryCy, nil
	case "CZ":
		return CountryCz, nil
	case "DE":
		return CountryDe, nil
	case "DJ":
		return CountryDj, nil
	case "DK":
		return CountryDk, nil
	case "DM":
		return CountryDm, nil
	case "DO":
		return CountryDo, nil
	case "DZ":
		return CountryDz, nil
	case "EC":
		return CountryEc, nil
	case "EE":
		return CountryEe, nil
	case "EG":
		return CountryEg, nil
	case "EH":
		return CountryEh, nil
	case "ER":
		return CountryEr, nil
	case "ES":
		return CountryEs, nil
	case "ET":
		return CountryEt, nil
	case "FI":
		return CountryFi, nil
	case "FJ":
		return CountryFj, nil
	case "FK":
		return CountryFk, nil
	case "FM":
		return CountryFm, nil
	case "FO":
		return CountryFo, nil
	case "FR":
		return CountryFr, nil
	case "GA":
		return CountryGa, nil
	case "GB":
		return CountryGb, nil
	case "GD":
		return CountryGd, nil
	case "GE":
		return CountryGe, nil
	case "GF":
		return CountryGf, nil
	case "GG":
		return CountryGg, nil
	case "GH":
		return CountryGh, nil
	case "GI":
		return CountryGi, nil
	case "GL":
		return CountryGl, nil
	case "GM":
		return CountryGm, nil
	case "GN":
		return CountryGn, nil
	case "GP":
		return CountryGp, nil
	case "GQ":
		return CountryGq, nil
	case "GR":
		return CountryGr, nil
	case "GS":
		return CountryGs, nil
	case "GT":
		return CountryGt, nil
	case "GU":
		return CountryGu, nil
	case "GW":
		return CountryGw, nil
	case "GY":
		return CountryGy, nil
	case "HK":
		return CountryHk, nil
	case "HM":
		return CountryHm, nil
	case "HN":
		return CountryHn, nil
	case "HR":
		return CountryHr, nil
	case "HT":
		return CountryHt, nil
	case "HU":
		return CountryHu, nil
	case "ID":
		return CountryId, nil
	case "IE":
		return CountryIe, nil
	case "IL":
		return CountryIl, nil
	case "IM":
		return CountryIm, nil
	case "IN":
		return CountryIn, nil
	case "IO":
		return CountryIo, nil
	case "IQ":
		return CountryIq, nil
	case "IR":
		return CountryIr, nil
	case "IS":
		return CountryIs, nil
	case "IT":
		return CountryIt, nil
	case "JE":
		return CountryJe, nil
	case "JM":
		return CountryJm, nil
	case "JO":
		return CountryJo, nil
	case "JP":
		return CountryJp, nil
	case "KE":
		return CountryKe, nil
	case "KG":
		return CountryKg, nil
	case "KH":
		return CountryKh, nil
	case "KI":
		return CountryKi, nil
	case "KM":
		return CountryKm, nil
	case "KN":
		return CountryKn, nil
	case "KP":
		return CountryKp, nil
	case "KR":
		return CountryKr, nil
	case "KW":
		return CountryKw, nil
	case "KY":
		return CountryKy, nil
	case "KZ":
		return CountryKz, nil
	case "LA":
		return CountryLa, nil
	case "LB":
		return CountryLb, nil
	case "LC":
		return CountryLc, nil
	case "LI":
		return CountryLi, nil
	case "LK":
		return CountryLk, nil
	case "LR":
		return CountryLr, nil
	case "LS":
		return CountryLs, nil
	case "LT":
		return CountryLt, nil
	case "LU":
		return CountryLu, nil
	case "LV":
		return CountryLv, nil
	case "LY":
		return CountryLy, nil
	case "MA":
		return CountryMa, nil
	case "MC":
		return CountryMc, nil
	case "MD":
		return CountryMd, nil
	case "ME":
		return CountryMe, nil
	case "MF":
		return CountryMf, nil
	case "MG":
		return CountryMg, nil
	case "MH":
		return CountryMh, nil
	case "MK":
		return CountryMk, nil
	case "ML":
		return CountryMl, nil
	case "MM":
		return CountryMm, nil
	case "MN":
		return CountryMn, nil
	case "MO":
		return CountryMo, nil
	case "MP":
		return CountryMp, nil
	case "MQ":
		return CountryMq, nil
	case "MR":
		return CountryMr, nil
	case "MS":
		return CountryMs, nil
	case "MT":
		return CountryMt, nil
	case "MU":
		return CountryMu, nil
	case "MV":
		return CountryMv, nil
	case "MW":
		return CountryMw, nil
	case "MX":
		return CountryMx, nil
	case "MY":
		return CountryMy, nil
	case "MZ":
		return CountryMz, nil
	case "NA":
		return CountryNa, nil
	case "NC":
		return CountryNc, nil
	case "NE":
		return CountryNe, nil
	case "NF":
		return CountryNf, nil
	case "NG":
		return CountryNg, nil
	case "NI":
		return CountryNi, nil
	case "NL":
		return CountryNl, nil
	case "NO":
		return CountryNo, nil
	case "NP":
		return CountryNp, nil
	case "NR":
		return CountryNr, nil
	case "NU":
		return CountryNu, nil
	case "NZ":
		return CountryNz, nil
	case "OM":
		return CountryOm, nil
	case "PA":
		return CountryPa, nil
	case "PE":
		return CountryPe, nil
	case "PF":
		return CountryPf, nil
	case "PG":
		return CountryPg, nil
	case "PH":
		return CountryPh, nil
	case "PK":
		return CountryPk, nil
	case "PL":
		return CountryPl, nil
	case "PM":
		return CountryPm, nil
	case "PN":
		return CountryPn, nil
	case "PR":
		return CountryPr, nil
	case "PS":
		return CountryPs, nil
	case "PT":
		return CountryPt, nil
	case "PW":
		return CountryPw, nil
	case "PY":
		return CountryPy, nil
	case "QA":
		return CountryQa, nil
	case "RE":
		return CountryRe, nil
	case "RO":
		return CountryRo, nil
	case "RS":
		return CountryRs, nil
	case "RU":
		return CountryRu, nil
	case "RW":
		return CountryRw, nil
	case "SA":
		return CountrySa, nil
	case "SB":
		return CountrySb, nil
	case "SC":
		return CountrySc, nil
	case "SD":
		return CountrySd, nil
	case "SE":
		return CountrySe, nil
	case "SG":
		return CountrySg, nil
	case "SH":
		return CountrySh, nil
	case "SI":
		return CountrySi, nil
	case "SJ":
		return CountrySj, nil
	case "SK":
		return CountrySk, nil
	case "SL":
		return CountrySl, nil
	case "SM":
		return CountrySm, nil
	case "SN":
		return CountrySn, nil
	case "SO":
		return CountrySo, nil
	case "SR":
		return CountrySr, nil
	case "SS":
		return CountrySs, nil
	case "ST":
		return CountrySt, nil
	case "SV":
		return CountrySv, nil
	case "SX":
		return CountrySx, nil
	case "SY":
		return CountrySy, nil
	case "SZ":
		return CountrySz, nil
	case "TC":
		return CountryTc, nil
	case "TD":
		return CountryTd, nil
	case "TF":
		return CountryTf, nil
	case "TG":
		return CountryTg, nil
	case "TH":
		return CountryTh, nil
	case "TJ":
		return CountryTj, nil
	case "TK":
		return CountryTk, nil
	case "TL":
		return CountryTl, nil
	case "TM":
		return CountryTm, nil
	case "TN":
		return CountryTn, nil
	case "TO":
		return CountryTo, nil
	case "TR":
		return CountryTr, nil
	case "TT":
		return CountryTt, nil
	case "TV":
		return CountryTv, nil
	case "TW":
		return CountryTw, nil
	case "TZ":
		return CountryTz, nil
	case "UA":
		return CountryUa, nil
	case "UG":
		return CountryUg, nil
	case "UM":
		return CountryUm, nil
	case "US":
		return CountryUs, nil
	case "UY":
		return CountryUy, nil
	case "UZ":
		return CountryUz, nil
	case "VA":
		return CountryVa, nil
	case "VC":
		return CountryVc, nil
	case "VE":
		return CountryVe, nil
	case "VG":
		return CountryVg, nil
	case "VI":
		return CountryVi, nil
	case "VN":
		return CountryVn, nil
	case "VU":
		return CountryVu, nil
	case "WF":
		return CountryWf, nil
	case "WS":
		return CountryWs, nil
	case "YE":
		return CountryYe, nil
	case "YT":
		return CountryYt, nil
	case "ZA":
		return CountryZa, nil
	case "ZM":
		return CountryZm, nil
	case "ZW":
		return CountryZw, nil
	}
	var t Country
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Country) Ptr() *Country {
	return &c
}

// The response object returned by the [CreateLocation](api-endpoint:Locations-CreateLocation) endpoint.
type CreateLocationResponse struct {
	// Information about [errors](https://developer.squareup.com/docs/build-basics/handling-errors) encountered during the request.
	Errors   []*Error  `json:"errors,omitempty" url:"errors,omitempty"`
	Location *Location `json:"location,omitempty" url:"location,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateLocationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateLocationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateLocationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateLocationResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateLocationResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the fields that are included in the response body of
// a request to the `CreateOrder` endpoint.
//
// Either `errors` or `order` is present in a given response, but never both.
type CreateOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreateOrderResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateOrderResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the response returned by [CreatePayment](api-endpoint:Payments-CreatePayment).
//
// If there are errors processing the request, the `payment` field might not be
// present, or it might be present with a status of `FAILED`.
type CreatePaymentResponse struct {
	// Information about errors encountered during the request.
	Errors  []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CreatePaymentResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreatePaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreatePaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreatePaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreatePaymentResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the associated currency for an amount of money. Values correspond
// to [ISO 4217](https://wikipedia.org/wiki/ISO_4217).
type Currency string

const (
	CurrencyUnknownCurrency Currency = "UNKNOWN_CURRENCY"
	CurrencyAed             Currency = "AED"
	CurrencyAfn             Currency = "AFN"
	CurrencyAll             Currency = "ALL"
	CurrencyAmd             Currency = "AMD"
	CurrencyAng             Currency = "ANG"
	CurrencyAoa             Currency = "AOA"
	CurrencyArs             Currency = "ARS"
	CurrencyAud             Currency = "AUD"
	CurrencyAwg             Currency = "AWG"
	CurrencyAzn             Currency = "AZN"
	CurrencyBam             Currency = "BAM"
	CurrencyBbd             Currency = "BBD"
	CurrencyBdt             Currency = "BDT"
	CurrencyBgn             Currency = "BGN"
	CurrencyBhd             Currency = "BHD"
	CurrencyBif             Currency = "BIF"
	CurrencyBmd             Currency = "BMD"
	CurrencyBnd             Currency = "BND"
	CurrencyBob             Currency = "BOB"
	CurrencyBov             Currency = "BOV"
	CurrencyBrl             Currency = "BRL"
	CurrencyBsd             Currency = "BSD"
	CurrencyBtn             Currency = "BTN"
	CurrencyBwp             Currency = "BWP"
	CurrencyByr             Currency = "BYR"
	CurrencyBzd             Currency = "BZD"
	CurrencyCad             Currency = "CAD"
	CurrencyCdf             Currency = "CDF"
	CurrencyChe             Currency = "CHE"
	CurrencyChf             Currency = "CHF"
	CurrencyChw             Currency = "CHW"
	CurrencyClf             Currency = "CLF"
	CurrencyClp             Currency = "CLP"
	CurrencyCny             Currency = "CNY"
	CurrencyCop             Currency = "COP"
	CurrencyCou             Currency = "COU"
	CurrencyCrc             Currency = "CRC"
	CurrencyCuc             Currency = "CUC"
	CurrencyCup             Currency = "CUP"
	CurrencyCve             Currency = "CVE"
	CurrencyCzk             Currency = "CZK"
	CurrencyDjf             Currency = "DJF"
	CurrencyDkk             Currency = "DKK"
	CurrencyDop             Currency = "DOP"
	CurrencyDzd             Currency = "DZD"
	CurrencyEgp             Currency = "EGP"
	CurrencyErn             Currency = "ERN"
	CurrencyEtb             Currency = "ETB"
	CurrencyEur             Currency = "EUR"
	CurrencyFjd             Currency = "FJD"
	CurrencyFkp             Currency = "FKP"
	CurrencyGbp             Currency = "GBP"
	CurrencyGel             Currency = "GEL"
	CurrencyGhs             Currency = "GHS"
	CurrencyGip             Currency = "GIP"
	CurrencyGmd             Currency = "GMD"
	CurrencyGnf             Currency = "GNF"
	CurrencyGtq             Currency = "GTQ"
	CurrencyGyd             Currency = "GYD"
	CurrencyHkd             Currency = "HKD"
	CurrencyHnl             Currency = "HNL"
	CurrencyHrk             Currency = "HRK"
	CurrencyHtg             Currency = "HTG"
	CurrencyHuf             Currency = "HUF"
	CurrencyIdr             Currency = "IDR"
	CurrencyIls             Currency = "ILS"
	CurrencyInr             Currency = "INR"
	CurrencyIqd             Currency = "IQD"
	CurrencyIrr             Currency = "IRR"
	CurrencyIsk             Currency = "ISK"
	CurrencyJmd             Currency = "JMD"
	CurrencyJod             Currency = "JOD"
	CurrencyJpy             Currency = "JPY"
	CurrencyKes             Currency = "KES"
	CurrencyKgs             Currency = "KGS"
	CurrencyKhr             Currency = "KHR"
	CurrencyKmf             Currency = "KMF"
	CurrencyKpw             Currency = "KPW"
	CurrencyKrw             Currency = "KRW"
	CurrencyKwd             Currency = "KWD"
	CurrencyKyd             Currency = "KYD"
	CurrencyKzt             Currency = "KZT"
	CurrencyLak             Currency = "LAK"
	CurrencyLbp             Currency = "LBP"
	CurrencyLkr             Currency = "LKR"
	CurrencyLrd             Currency = "LRD"
	CurrencyLsl             Currency = "LSL"
	CurrencyLtl             Currency = "LTL"
	CurrencyLvl             Currency = "LVL"
	CurrencyLyd             Currency = "LYD"
	CurrencyMad             Currency = "MAD"
	CurrencyMdl             Currency = "MDL"
	CurrencyMga             Currency = "MGA"
	CurrencyMkd             Currency = "MKD"
	CurrencyMmk             Currency = "MMK"
	CurrencyMnt             Currency = "MNT"
	CurrencyMop             Currency = "MOP"
	CurrencyMro             Currency = "MRO"
	CurrencyMur             Currency = "MUR"
	CurrencyMvr             Currency = "MVR"
	CurrencyMwk             Currency = "MWK"
	CurrencyMxn             Currency = "MXN"
	CurrencyMxv             Currency = "MXV"
	CurrencyMyr             Currency = "MYR"
	CurrencyMzn             Currency = "MZN"
	CurrencyNad             Currency = "NAD"
	CurrencyNgn             Currency = "NGN"
	CurrencyNio             Currency = "NIO"
	CurrencyNok             Currency = "NOK"
	CurrencyNpr             Currency = "NPR"
	CurrencyNzd             Currency = "NZD"
	CurrencyOmr             Currency = "OMR"
	CurrencyPab             Currency = "PAB"
	CurrencyPen             Currency = "PEN"
	CurrencyPgk             Currency = "PGK"
	CurrencyPhp             Currency = "PHP"
	CurrencyPkr             Currency = "PKR"
	CurrencyPln             Currency = "PLN"
	CurrencyPyg             Currency = "PYG"
	CurrencyQar             Currency = "QAR"
	CurrencyRon             Currency = "RON"
	CurrencyRsd             Currency = "RSD"
	CurrencyRub             Currency = "RUB"
	CurrencyRwf             Currency = "RWF"
	CurrencySar             Currency = "SAR"
	CurrencySbd             Currency = "SBD"
	CurrencyScr             Currency = "SCR"
	CurrencySdg             Currency = "SDG"
	CurrencySek             Currency = "SEK"
	CurrencySgd             Currency = "SGD"
	CurrencyShp             Currency = "SHP"
	CurrencySll             Currency = "SLL"
	CurrencySos             Currency = "SOS"
	CurrencySrd             Currency = "SRD"
	CurrencySsp             Currency = "SSP"
	CurrencyStd             Currency = "STD"
	CurrencySvc             Currency = "SVC"
	CurrencySyp             Currency = "SYP"
	CurrencySzl             Currency = "SZL"
	CurrencyThb             Currency = "THB"
	CurrencyTjs             Currency = "TJS"
	CurrencyTmt             Currency = "TMT"
	CurrencyTnd             Currency = "TND"
	CurrencyTop             Currency = "TOP"
	CurrencyTry             Currency = "TRY"
	CurrencyTtd             Currency = "TTD"
	CurrencyTwd             Currency = "TWD"
	CurrencyTzs             Currency = "TZS"
	CurrencyUah             Currency = "UAH"
	CurrencyUgx             Currency = "UGX"
	CurrencyUsd             Currency = "USD"
	CurrencyUsn             Currency = "USN"
	CurrencyUss             Currency = "USS"
	CurrencyUyi             Currency = "UYI"
	CurrencyUyu             Currency = "UYU"
	CurrencyUzs             Currency = "UZS"
	CurrencyVef             Currency = "VEF"
	CurrencyVnd             Currency = "VND"
	CurrencyVuv             Currency = "VUV"
	CurrencyWst             Currency = "WST"
	CurrencyXaf             Currency = "XAF"
	CurrencyXag             Currency = "XAG"
	CurrencyXau             Currency = "XAU"
	CurrencyXba             Currency = "XBA"
	CurrencyXbb             Currency = "XBB"
	CurrencyXbc             Currency = "XBC"
	CurrencyXbd             Currency = "XBD"
	CurrencyXcd             Currency = "XCD"
	CurrencyXdr             Currency = "XDR"
	CurrencyXof             Currency = "XOF"
	CurrencyXpd             Currency = "XPD"
	CurrencyXpf             Currency = "XPF"
	CurrencyXpt             Currency = "XPT"
	CurrencyXts             Currency = "XTS"
	CurrencyXxx             Currency = "XXX"
	CurrencyYer             Currency = "YER"
	CurrencyZar             Currency = "ZAR"
	CurrencyZmk             Currency = "ZMK"
	CurrencyZmw             Currency = "ZMW"
	CurrencyBtc             Currency = "BTC"
)

func NewCurrencyFromString(s string) (Currency, error) {
	switch s {
	case "UNKNOWN_CURRENCY":
		return CurrencyUnknownCurrency, nil
	case "AED":
		return CurrencyAed, nil
	case "AFN":
		return CurrencyAfn, nil
	case "ALL":
		return CurrencyAll, nil
	case "AMD":
		return CurrencyAmd, nil
	case "ANG":
		return CurrencyAng, nil
	case "AOA":
		return CurrencyAoa, nil
	case "ARS":
		return CurrencyArs, nil
	case "AUD":
		return CurrencyAud, nil
	case "AWG":
		return CurrencyAwg, nil
	case "AZN":
		return CurrencyAzn, nil
	case "BAM":
		return CurrencyBam, nil
	case "BBD":
		return CurrencyBbd, nil
	case "BDT":
		return CurrencyBdt, nil
	case "BGN":
		return CurrencyBgn, nil
	case "BHD":
		return CurrencyBhd, nil
	case "BIF":
		return CurrencyBif, nil
	case "BMD":
		return CurrencyBmd, nil
	case "BND":
		return CurrencyBnd, nil
	case "BOB":
		return CurrencyBob, nil
	case "BOV":
		return CurrencyBov, nil
	case "BRL":
		return CurrencyBrl, nil
	case "BSD":
		return CurrencyBsd, nil
	case "BTN":
		return CurrencyBtn, nil
	case "BWP":
		return CurrencyBwp, nil
	case "BYR":
		return CurrencyByr, nil
	case "BZD":
		return CurrencyBzd, nil
	case "CAD":
		return CurrencyCad, nil
	case "CDF":
		return CurrencyCdf, nil
	case "CHE":
		return CurrencyChe, nil
	case "CHF":
		return CurrencyChf, nil
	case "CHW":
		return CurrencyChw, nil
	case "CLF":
		return CurrencyClf, nil
	case "CLP":
		return CurrencyClp, nil
	case "CNY":
		return CurrencyCny, nil
	case "COP":
		return CurrencyCop, nil
	case "COU":
		return CurrencyCou, nil
	case "CRC":
		return CurrencyCrc, nil
	case "CUC":
		return CurrencyCuc, nil
	case "CUP":
		return CurrencyCup, nil
	case "CVE":
		return CurrencyCve, nil
	case "CZK":
		return CurrencyCzk, nil
	case "DJF":
		return CurrencyDjf, nil
	case "DKK":
		return CurrencyDkk, nil
	case "DOP":
		return CurrencyDop, nil
	case "DZD":
		return CurrencyDzd, nil
	case "EGP":
		return CurrencyEgp, nil
	case "ERN":
		return CurrencyErn, nil
	case "ETB":
		return CurrencyEtb, nil
	case "EUR":
		return CurrencyEur, nil
	case "FJD":
		return CurrencyFjd, nil
	case "FKP":
		return CurrencyFkp, nil
	case "GBP":
		return CurrencyGbp, nil
	case "GEL":
		return CurrencyGel, nil
	case "GHS":
		return CurrencyGhs, nil
	case "GIP":
		return CurrencyGip, nil
	case "GMD":
		return CurrencyGmd, nil
	case "GNF":
		return CurrencyGnf, nil
	case "GTQ":
		return CurrencyGtq, nil
	case "GYD":
		return CurrencyGyd, nil
	case "HKD":
		return CurrencyHkd, nil
	case "HNL":
		return CurrencyHnl, nil
	case "HRK":
		return CurrencyHrk, nil
	case "HTG":
		return CurrencyHtg, nil
	case "HUF":
		return CurrencyHuf, nil
	case "IDR":
		return CurrencyIdr, nil
	case "ILS":
		return CurrencyIls, nil
	case "INR":
		return CurrencyInr, nil
	case "IQD":
		return CurrencyIqd, nil
	case "IRR":
		return CurrencyIrr, nil
	case "ISK":
		return CurrencyIsk, nil
	case "JMD":
		return CurrencyJmd, nil
	case "JOD":
		return CurrencyJod, nil
	case "JPY":
		return CurrencyJpy, nil
	case "KES":
		return CurrencyKes, nil
	case "KGS":
		return CurrencyKgs, nil
	case "KHR":
		return CurrencyKhr, nil
	case "KMF":
		return CurrencyKmf, nil
	case "KPW":
		return CurrencyKpw, nil
	case "KRW":
		return CurrencyKrw, nil
	case "KWD":
		return CurrencyKwd, nil
	case "KYD":
		return CurrencyKyd, nil
	case "KZT":
		return CurrencyKzt, nil
	case "LAK":
		return CurrencyLak, nil
	case "LBP":
		return CurrencyLbp, nil
	case "LKR":
		return CurrencyLkr, nil
	case "LRD":
		return CurrencyLrd, nil
	case "LSL":
		return CurrencyLsl, nil
	case "LTL":
		return CurrencyLtl, nil
	case "LVL":
		return CurrencyLvl, nil
	case "LYD":
		return CurrencyLyd, nil
	case "MAD":
		return CurrencyMad, nil
	case "MDL":
		return CurrencyMdl, nil
	case "MGA":
		return CurrencyMga, nil
	case "MKD":
		return CurrencyMkd, nil
	case "MMK":
		return CurrencyMmk, nil
	case "MNT":
		return CurrencyMnt, nil
	case "MOP":
		return CurrencyMop, nil
	case "MRO":
		return CurrencyMro, nil
	case "MUR":
		return CurrencyMur, nil
	case "MVR":
		return CurrencyMvr, nil
	case "MWK":
		return CurrencyMwk, nil
	case "MXN":
		return CurrencyMxn, nil
	case "MXV":
		return CurrencyMxv, nil
	case "MYR":
		return CurrencyMyr, nil
	case "MZN":
		return CurrencyMzn, nil
	case "NAD":
		return CurrencyNad, nil
	case "NGN":
		return CurrencyNgn, nil
	case "NIO":
		return CurrencyNio, nil
	case "NOK":
		return CurrencyNok, nil
	case "NPR":
		return CurrencyNpr, nil
	case "NZD":
		return CurrencyNzd, nil
	case "OMR":
		return CurrencyOmr, nil
	case "PAB":
		return CurrencyPab, nil
	case "PEN":
		return CurrencyPen, nil
	case "PGK":
		return CurrencyPgk, nil
	case "PHP":
		return CurrencyPhp, nil
	case "PKR":
		return CurrencyPkr, nil
	case "PLN":
		return CurrencyPln, nil
	case "PYG":
		return CurrencyPyg, nil
	case "QAR":
		return CurrencyQar, nil
	case "RON":
		return CurrencyRon, nil
	case "RSD":
		return CurrencyRsd, nil
	case "RUB":
		return CurrencyRub, nil
	case "RWF":
		return CurrencyRwf, nil
	case "SAR":
		return CurrencySar, nil
	case "SBD":
		return CurrencySbd, nil
	case "SCR":
		return CurrencyScr, nil
	case "SDG":
		return CurrencySdg, nil
	case "SEK":
		return CurrencySek, nil
	case "SGD":
		return CurrencySgd, nil
	case "SHP":
		return CurrencyShp, nil
	case "SLL":
		return CurrencySll, nil
	case "SOS":
		return CurrencySos, nil
	case "SRD":
		return CurrencySrd, nil
	case "SSP":
		return CurrencySsp, nil
	case "STD":
		return CurrencyStd, nil
	case "SVC":
		return CurrencySvc, nil
	case "SYP":
		return CurrencySyp, nil
	case "SZL":
		return CurrencySzl, nil
	case "THB":
		return CurrencyThb, nil
	case "TJS":
		return CurrencyTjs, nil
	case "TMT":
		return CurrencyTmt, nil
	case "TND":
		return CurrencyTnd, nil
	case "TOP":
		return CurrencyTop, nil
	case "TRY":
		return CurrencyTry, nil
	case "TTD":
		return CurrencyTtd, nil
	case "TWD":
		return CurrencyTwd, nil
	case "TZS":
		return CurrencyTzs, nil
	case "UAH":
		return CurrencyUah, nil
	case "UGX":
		return CurrencyUgx, nil
	case "USD":
		return CurrencyUsd, nil
	case "USN":
		return CurrencyUsn, nil
	case "USS":
		return CurrencyUss, nil
	case "UYI":
		return CurrencyUyi, nil
	case "UYU":
		return CurrencyUyu, nil
	case "UZS":
		return CurrencyUzs, nil
	case "VEF":
		return CurrencyVef, nil
	case "VND":
		return CurrencyVnd, nil
	case "VUV":
		return CurrencyVuv, nil
	case "WST":
		return CurrencyWst, nil
	case "XAF":
		return CurrencyXaf, nil
	case "XAG":
		return CurrencyXag, nil
	case "XAU":
		return CurrencyXau, nil
	case "XBA":
		return CurrencyXba, nil
	case "XBB":
		return CurrencyXbb, nil
	case "XBC":
		return CurrencyXbc, nil
	case "XBD":
		return CurrencyXbd, nil
	case "XCD":
		return CurrencyXcd, nil
	case "XDR":
		return CurrencyXdr, nil
	case "XOF":
		return CurrencyXof, nil
	case "XPD":
		return CurrencyXpd, nil
	case "XPF":
		return CurrencyXpf, nil
	case "XPT":
		return CurrencyXpt, nil
	case "XTS":
		return CurrencyXts, nil
	case "XXX":
		return CurrencyXxx, nil
	case "YER":
		return CurrencyYer, nil
	case "ZAR":
		return CurrencyZar, nil
	case "ZMK":
		return CurrencyZmk, nil
	case "ZMW":
		return CurrencyZmw, nil
	case "BTC":
		return CurrencyBtc, nil
	}
	var t Currency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Currency) Ptr() *Currency {
	return &c
}

// Represents a Square customer profile in the Customer Directory of a Square seller.
type Customer struct {
	// A unique Square-assigned ID for the customer profile.
	//
	// If you need this ID for an API request, use the ID returned when you created the customer profile or call the [SearchCustomers](api-endpoint:Customers-SearchCustomers)
	// or [ListCustomers](api-endpoint:Customers-ListCustomers) endpoint.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp when the customer profile was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp when the customer profile was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// Payment details of the credit, debit, and gift cards stored on file for the customer profile.
	//
	// DEPRECATED at version 2021-06-16. Replaced by calling [ListCards](api-endpoint:Cards-ListCards) (for credit and debit cards on file)
	// or [ListGiftCards](api-endpoint:GiftCards-ListGiftCards) (for gift cards on file) and including the `customer_id` query parameter.
	// For more information, see [Migration notes](https://developer.squareup.com/docs/customers-api/what-it-does#migrate-customer-cards).
	Cards []*Card `json:"cards,omitempty" url:"cards,omitempty"`
	// The given name (that is, the first name) associated with the customer profile.
	GivenName *string `json:"given_name,omitempty" url:"given_name,omitempty"`
	// The family name (that is, the last name) associated with the customer profile.
	FamilyName *string `json:"family_name,omitempty" url:"family_name,omitempty"`
	// A nickname for the customer profile.
	Nickname *string `json:"nickname,omitempty" url:"nickname,omitempty"`
	// A business name associated with the customer profile.
	CompanyName *string `json:"company_name,omitempty" url:"company_name,omitempty"`
	// The email address associated with the customer profile.
	EmailAddress *string  `json:"email_address,omitempty" url:"email_address,omitempty"`
	Address      *Address `json:"address,omitempty" url:"address,omitempty"`
	// The phone number associated with the customer profile. A phone number can contain 9–16 digits, with an optional `+` prefix.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The birthday associated with the customer profile, in RFC 3339 format. The year is optional. The timezone and time are not allowed.
	// For example, `0000-09-21T00:00:00-00:00` represents a birthday on September 21 and `1998-09-21T00:00:00-00:00` represents a birthday on September 21, 1998.
	Birthday *string `json:"birthday,omitempty" url:"birthday,omitempty"`
	// An optional second ID used to associate the customer profile with an
	// entity in another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// A custom note associated with the customer profile.
	Note        *string              `json:"note,omitempty" url:"note,omitempty"`
	Preferences *CustomerPreferences `json:"preferences,omitempty" url:"preferences,omitempty"`
	// The customer groups and segments the customer belongs to. This deprecated field has been replaced with the dedicated `group_ids` for customer groups and the dedicated `segment_ids` field for customer segments. You can retrieve information about a given customer group and segment respectively using the Customer Groups API and Customer Segments API.
	Groups         []*CustomerGroupInfo    `json:"groups,omitempty" url:"groups,omitempty"`
	CreationSource *CustomerCreationSource `json:"creation_source,omitempty" url:"creation_source,omitempty"`
	// The IDs of customer groups the customer belongs to.
	GroupIds []string `json:"group_ids,omitempty" url:"group_ids,omitempty"`
	// The IDs of segments the customer belongs to.
	SegmentIds []string `json:"segment_ids,omitempty" url:"segment_ids,omitempty"`
	// The Square-assigned version number of the customer profile. The version number is incremented each time an update is committed to the customer profile, except for changes to customer segment membership and cards on file.
	Version *int64          `json:"version,omitempty" url:"version,omitempty"`
	TaxIds  *CustomerTaxIds `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Customer) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Customer) UnmarshalJSON(data []byte) error {
	type unmarshaler Customer
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Customer(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Customer) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the method used to create the customer profile.
type CustomerCreationSource string

const (
	CustomerCreationSourceOther            CustomerCreationSource = "OTHER"
	CustomerCreationSourceAppointments     CustomerCreationSource = "APPOINTMENTS"
	CustomerCreationSourceCoupon           CustomerCreationSource = "COUPON"
	CustomerCreationSourceDeletionRecovery CustomerCreationSource = "DELETION_RECOVERY"
	CustomerCreationSourceDirectory        CustomerCreationSource = "DIRECTORY"
	CustomerCreationSourceEgifting         CustomerCreationSource = "EGIFTING"
	CustomerCreationSourceEmailCollection  CustomerCreationSource = "EMAIL_COLLECTION"
	CustomerCreationSourceFeedback         CustomerCreationSource = "FEEDBACK"
	CustomerCreationSourceImport           CustomerCreationSource = "IMPORT"
	CustomerCreationSourceInvoices         CustomerCreationSource = "INVOICES"
	CustomerCreationSourceLoyalty          CustomerCreationSource = "LOYALTY"
	CustomerCreationSourceMarketing        CustomerCreationSource = "MARKETING"
	CustomerCreationSourceMerge            CustomerCreationSource = "MERGE"
	CustomerCreationSourceOnlineStore      CustomerCreationSource = "ONLINE_STORE"
	CustomerCreationSourceInstantProfile   CustomerCreationSource = "INSTANT_PROFILE"
	CustomerCreationSourceTerminal         CustomerCreationSource = "TERMINAL"
	CustomerCreationSourceThirdParty       CustomerCreationSource = "THIRD_PARTY"
	CustomerCreationSourceThirdPartyImport CustomerCreationSource = "THIRD_PARTY_IMPORT"
	CustomerCreationSourceUnmergeRecovery  CustomerCreationSource = "UNMERGE_RECOVERY"
)

func NewCustomerCreationSourceFromString(s string) (CustomerCreationSource, error) {
	switch s {
	case "OTHER":
		return CustomerCreationSourceOther, nil
	case "APPOINTMENTS":
		return CustomerCreationSourceAppointments, nil
	case "COUPON":
		return CustomerCreationSourceCoupon, nil
	case "DELETION_RECOVERY":
		return CustomerCreationSourceDeletionRecovery, nil
	case "DIRECTORY":
		return CustomerCreationSourceDirectory, nil
	case "EGIFTING":
		return CustomerCreationSourceEgifting, nil
	case "EMAIL_COLLECTION":
		return CustomerCreationSourceEmailCollection, nil
	case "FEEDBACK":
		return CustomerCreationSourceFeedback, nil
	case "IMPORT":
		return CustomerCreationSourceImport, nil
	case "INVOICES":
		return CustomerCreationSourceInvoices, nil
	case "LOYALTY":
		return CustomerCreationSourceLoyalty, nil
	case "MARKETING":
		return CustomerCreationSourceMarketing, nil
	case "MERGE":
		return CustomerCreationSourceMerge, nil
	case "ONLINE_STORE":
		return CustomerCreationSourceOnlineStore, nil
	case "INSTANT_PROFILE":
		return CustomerCreationSourceInstantProfile, nil
	case "TERMINAL":
		return CustomerCreationSourceTerminal, nil
	case "THIRD_PARTY":
		return CustomerCreationSourceThirdParty, nil
	case "THIRD_PARTY_IMPORT":
		return CustomerCreationSourceThirdPartyImport, nil
	case "UNMERGE_RECOVERY":
		return CustomerCreationSourceUnmergeRecovery, nil
	}
	var t CustomerCreationSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CustomerCreationSource) Ptr() *CustomerCreationSource {
	return &c
}

// Contains some brief information about a Customer Group with its identifier included.
type CustomerGroupInfo struct {
	// The ID of the Customer Group.
	Id string `json:"id" url:"id"`
	// The name of the Customer Group.
	Name string `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerGroupInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerGroupInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerGroupInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerGroupInfo(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerGroupInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents communication preferences for the customer profile.
type CustomerPreferences struct {
	// Indicates whether the customer has unsubscribed from marketing campaign emails. A value of `true` means that the customer chose to opt out of email marketing from the current Square seller or from all Square sellers. This value is read-only from the Customers API.
	EmailUnsubscribed *bool `json:"email_unsubscribed,omitempty" url:"email_unsubscribed,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerPreferences) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerPreferences) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerPreferences
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerPreferences(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerPreferences) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Represents the tax ID associated with a [customer profile](entity:Customer). The corresponding `tax_ids` field is available only for customers of sellers in EU countries or the United Kingdom.
// For more information, see [Customer tax IDs](https://developer.squareup.com/docs/customers-api/what-it-does#customer-tax-ids).
type CustomerTaxIds struct {
	// The EU VAT identification number for the customer. For example, `IE3426675K`. The ID can contain alphanumeric characters only.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CustomerTaxIds) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CustomerTaxIds) UnmarshalJSON(data []byte) error {
	type unmarshaler CustomerTaxIds
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CustomerTaxIds(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CustomerTaxIds) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Indicates the specific day of the week.
type DayOfWeek string

const (
	DayOfWeekSun DayOfWeek = "SUN"
	DayOfWeekMon DayOfWeek = "MON"
	DayOfWeekTue DayOfWeek = "TUE"
	DayOfWeekWed DayOfWeek = "WED"
	DayOfWeekThu DayOfWeek = "THU"
	DayOfWeekFri DayOfWeek = "FRI"
	DayOfWeekSat DayOfWeek = "SAT"
)

func NewDayOfWeekFromString(s string) (DayOfWeek, error) {
	switch s {
	case "SUN":
		return DayOfWeekSun, nil
	case "MON":
		return DayOfWeekMon, nil
	case "TUE":
		return DayOfWeekTue, nil
	case "WED":
		return DayOfWeekWed, nil
	case "THU":
		return DayOfWeekThu, nil
	case "FRI":
		return DayOfWeekFri, nil
	case "SAT":
		return DayOfWeekSat, nil
	}
	var t DayOfWeek
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DayOfWeek) Ptr() *DayOfWeek {
	return &d
}

type DeleteCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The IDs of all catalog objects deleted by this request.
	// Multiple IDs may be returned when associated objects are also deleted, for example
	// a catalog item variation will be deleted (and its ID included in this field)
	// when its parent catalog item is deleted.
	DeletedObjectIds []string `json:"deleted_object_ids,omitempty" url:"deleted_object_ids,omitempty"`
	// The database [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// of this deletion in RFC 3339 format, e.g., `2016-09-04T23:59:33.123Z`.
	DeletedAt *string `json:"deleted_at,omitempty" url:"deleted_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCatalogObjectResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Defines the fields that are included in the response body of
// a request to the `DeleteCustomer` endpoint.
type DeleteCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeleteCustomerResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeleteCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeleteCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeleteCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeleteCustomerResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Information about the destination against which the payout was made.
type Destination struct {
	Type *DestinationType `json:"type,omitempty" url:"type,omitempty"`
	// Square issued unique ID (also known as the instrument ID) associated with this destination.
	Id *string `json:"id,omitempty" url:"id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *Destination) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *Destination) UnmarshalJSON(data []byte) error {
	type unmarshaler Destination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = Destination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Destination) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// List of possible destinations against which a payout can be made.
type DestinationType string

const (
	DestinationTypeUnknownDestinationTypeDoNotUse DestinationType = "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE"
	DestinationTypeBankAccount                    DestinationType = "BANK_ACCOUNT"
	DestinationTypeCard                           DestinationType = "CARD"
	DestinationTypeSquareBalance                  DestinationType = "SQUARE_BALANCE"
	DestinationTypeSquareStoredBalance            DestinationType = "SQUARE_STORED_BALANCE"
)

func NewDestinationTypeFromString(s string) (DestinationType, error) {
	switch s {
	case "UNKNOWN_DESTINATION_TYPE_DO_NOT_USE":
		return DestinationTypeUnknownDestinationTypeDoNotUse, nil
	case "BANK_ACCOUNT":
		return DestinationTypeBankAccount, nil
	case "CARD":
		return DestinationTypeCard, nil
	case "SQUARE_BALANCE":
		return DestinationTypeSquareBalance, nil
	case "SQUARE_STORED_BALANCE":
		return DestinationTypeSquareStoredBalance, nil
	}
	var t DestinationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationType) Ptr() *DestinationType {
	return &d
}

// Details about the device that took the payment.
type DeviceDetails struct {
	// The Square-issued ID of the device.
	DeviceId *string `json:"device_id,omitempty" url:"device_id,omitempty"`
	// The Square-issued installation ID for the device.
	DeviceInstallationId *string `json:"device_installation_id,omitempty" url:"device_installation_id,omitempty"`
	// The name of the device set by the seller.
	DeviceName *string `json:"device_name,omitempty" url:"device_name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DeviceDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Additional details about `WALLET` type payments. Contains only non-confidential information.
type DigitalWalletDetails struct {
	// The status of the `WALLET` payment. The status can be `AUTHORIZED`, `CAPTURED`, `VOIDED`, or
	// `FAILED`.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The brand used for the `WALLET` payment. The brand can be `CASH_APP`, `PAYPAY` or `UNKNOWN`.
	Brand          *string         `json:"brand,omitempty" url:"brand,omitempty"`
	CashAppDetails *CashAppDetails `json:"cash_app_details,omitempty" url:"cash_app_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DigitalWalletDetails) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DigitalWalletDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler DigitalWalletDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DigitalWalletDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DigitalWalletDetails) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// Represents an error encountered during a request to the Connect API.
//
// See [Handling errors](https://developer.squareup.com/docs/build-basics/handling-errors) for more information.
type Error struct {
	Category ErrorCategory `json:"category" url:"category"`
	Code     ErrorCode     `json:"code" url:"code"`
	// A human-readable description of the error for debugging purposes.
	Detail *string `json:"detail,omitempty" url:"detail,omitempty"`
	// The name of the field provided in the original request (if any) that
	// the error pertains to.
	Field *string `json:"field,omitempty" url:"field,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Indicates which high-level category of error has occurred during a
// request to the Connect API.
type ErrorCategory string

const (
	ErrorCategoryApiError                  ErrorCategory = "API_ERROR"
	ErrorCategoryAuthenticationError       ErrorCategory = "AUTHENTICATION_ERROR"
	ErrorCategoryInvalidRequestError       ErrorCategory = "INVALID_REQUEST_ERROR"
	ErrorCategoryRateLimitError            ErrorCategory = "RATE_LIMIT_ERROR"
	ErrorCategoryPaymentMethodError        ErrorCategory = "PAYMENT_METHOD_ERROR"
	ErrorCategoryRefundError               ErrorCategory = "REFUND_ERROR"
	ErrorCategoryMerchantSubscriptionError ErrorCategory = "MERCHANT_SUBSCRIPTION_ERROR"
)

func NewErrorCategoryFromString(s string) (ErrorCategory, error) {
	switch s {
	case "API_ERROR":
		return ErrorCategoryApiError, nil
	case "AUTHENTICATION_ERROR":
		return ErrorCategoryAuthenticationError, nil
	case "INVALID_REQUEST_ERROR":
		return ErrorCategoryInvalidRequestError, nil
	case "RATE_LIMIT_ERROR":
		return ErrorCategoryRateLimitError, nil
	case "PAYMENT_METHOD_ERROR":
		return ErrorCategoryPaymentMethodError, nil
	case "REFUND_ERROR":
		return ErrorCategoryRefundError, nil
	case "MERCHANT_SUBSCRIPTION_ERROR":
		return ErrorCategoryMerchantSubscriptionError, nil
	}
	var t ErrorCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCategory) Ptr() *ErrorCategory {
	return &e
}

// Indicates the specific error that occurred during a request to a
// Square API.
type ErrorCode string

const (
	ErrorCodeInternalServerError                                 ErrorCode = "INTERNAL_SERVER_ERROR"
	ErrorCodeUnauthorized                                        ErrorCode = "UNAUTHORIZED"
	ErrorCodeAccessTokenExpired                                  ErrorCode = "ACCESS_TOKEN_EXPIRED"
	ErrorCodeAccessTokenRevoked                                  ErrorCode = "ACCESS_TOKEN_REVOKED"
	ErrorCodeClientDisabled                                      ErrorCode = "CLIENT_DISABLED"
	ErrorCodeForbidden                                           ErrorCode = "FORBIDDEN"
	ErrorCodeInsufficientScopes                                  ErrorCode = "INSUFFICIENT_SCOPES"
	ErrorCodeApplicationDisabled                                 ErrorCode = "APPLICATION_DISABLED"
	ErrorCodeV1Application                                       ErrorCode = "V1_APPLICATION"
	ErrorCodeV1AccessToken                                       ErrorCode = "V1_ACCESS_TOKEN"
	ErrorCodeCardProcessingNotEnabled                            ErrorCode = "CARD_PROCESSING_NOT_ENABLED"
	ErrorCodeMerchantSubscriptionNotFound                        ErrorCode = "MERCHANT_SUBSCRIPTION_NOT_FOUND"
	ErrorCodeBadRequest                                          ErrorCode = "BAD_REQUEST"
	ErrorCodeMissingRequiredParameter                            ErrorCode = "MISSING_REQUIRED_PARAMETER"
	ErrorCodeIncorrectType                                       ErrorCode = "INCORRECT_TYPE"
	ErrorCodeInvalidTime                                         ErrorCode = "INVALID_TIME"
	ErrorCodeInvalidTimeRange                                    ErrorCode = "INVALID_TIME_RANGE"
	ErrorCodeInvalidValue                                        ErrorCode = "INVALID_VALUE"
	ErrorCodeInvalidCursor                                       ErrorCode = "INVALID_CURSOR"
	ErrorCodeUnknownQueryParameter                               ErrorCode = "UNKNOWN_QUERY_PARAMETER"
	ErrorCodeConflictingParameters                               ErrorCode = "CONFLICTING_PARAMETERS"
	ErrorCodeExpectedJsonBody                                    ErrorCode = "EXPECTED_JSON_BODY"
	ErrorCodeInvalidSortOrder                                    ErrorCode = "INVALID_SORT_ORDER"
	ErrorCodeValueRegexMismatch                                  ErrorCode = "VALUE_REGEX_MISMATCH"
	ErrorCodeValueTooShort                                       ErrorCode = "VALUE_TOO_SHORT"
	ErrorCodeValueTooLong                                        ErrorCode = "VALUE_TOO_LONG"
	ErrorCodeValueTooLow                                         ErrorCode = "VALUE_TOO_LOW"
	ErrorCodeValueTooHigh                                        ErrorCode = "VALUE_TOO_HIGH"
	ErrorCodeValueEmpty                                          ErrorCode = "VALUE_EMPTY"
	ErrorCodeArrayLengthTooLong                                  ErrorCode = "ARRAY_LENGTH_TOO_LONG"
	ErrorCodeArrayLengthTooShort                                 ErrorCode = "ARRAY_LENGTH_TOO_SHORT"
	ErrorCodeArrayEmpty                                          ErrorCode = "ARRAY_EMPTY"
	ErrorCodeExpectedBoolean                                     ErrorCode = "EXPECTED_BOOLEAN"
	ErrorCodeExpectedInteger                                     ErrorCode = "EXPECTED_INTEGER"
	ErrorCodeExpectedFloat                                       ErrorCode = "EXPECTED_FLOAT"
	ErrorCodeExpectedString                                      ErrorCode = "EXPECTED_STRING"
	ErrorCodeExpectedObject                                      ErrorCode = "EXPECTED_OBJECT"
	ErrorCodeExpectedArray                                       ErrorCode = "EXPECTED_ARRAY"
	ErrorCodeExpectedMap                                         ErrorCode = "EXPECTED_MAP"
	ErrorCodeExpectedBase64EncodedByteArray                      ErrorCode = "EXPECTED_BASE64_ENCODED_BYTE_ARRAY"
	ErrorCodeInvalidArrayValue                                   ErrorCode = "INVALID_ARRAY_VALUE"
	ErrorCodeInvalidEnumValue                                    ErrorCode = "INVALID_ENUM_VALUE"
	ErrorCodeInvalidContentType                                  ErrorCode = "INVALID_CONTENT_TYPE"
	ErrorCodeInvalidFormValue                                    ErrorCode = "INVALID_FORM_VALUE"
	ErrorCodeCustomerNotFound                                    ErrorCode = "CUSTOMER_NOT_FOUND"
	ErrorCodeBuyerNotFound                                       ErrorCode = "BUYER_NOT_FOUND"
	ErrorCodeOneInstrumentExpected                               ErrorCode = "ONE_INSTRUMENT_EXPECTED"
	ErrorCodeNoFieldsSet                                         ErrorCode = "NO_FIELDS_SET"
	ErrorCodeDeprecatedFieldSet                                  ErrorCode = "DEPRECATED_FIELD_SET"
	ErrorCodeRetiredFieldSet                                     ErrorCode = "RETIRED_FIELD_SET"
	ErrorCodeTooManyMapEntries                                   ErrorCode = "TOO_MANY_MAP_ENTRIES"
	ErrorCodeMapKeyLengthTooShort                                ErrorCode = "MAP_KEY_LENGTH_TOO_SHORT"
	ErrorCodeMapKeyLengthTooLong                                 ErrorCode = "MAP_KEY_LENGTH_TOO_LONG"
	ErrorCodeCustomerMissingName                                 ErrorCode = "CUSTOMER_MISSING_NAME"
	ErrorCodeCustomerMissingEmail                                ErrorCode = "CUSTOMER_MISSING_EMAIL"
	ErrorCodeInvalidPauseLength                                  ErrorCode = "INVALID_PAUSE_LENGTH"
	ErrorCodeInvalidDate                                         ErrorCode = "INVALID_DATE"
	ErrorCodeJobTemplateNameTaken                                ErrorCode = "JOB_TEMPLATE_NAME_TAKEN"
	ErrorCodeClientNotSupported                                  ErrorCode = "CLIENT_NOT_SUPPORTED"
	ErrorCodeCardExpired                                         ErrorCode = "CARD_EXPIRED"
	ErrorCodeInvalidExpiration                                   ErrorCode = "INVALID_EXPIRATION"
	ErrorCodeInvalidExpirationYear                               ErrorCode = "INVALID_EXPIRATION_YEAR"
	ErrorCodeInvalidExpirationDate                               ErrorCode = "INVALID_EXPIRATION_DATE"
	ErrorCodeUnsupportedCardBrand                                ErrorCode = "UNSUPPORTED_CARD_BRAND"
	ErrorCodeUnsupportedEntryMethod                              ErrorCode = "UNSUPPORTED_ENTRY_METHOD"
	ErrorCodeInvalidEncryptedCard                                ErrorCode = "INVALID_ENCRYPTED_CARD"
	ErrorCodeInvalidCard                                         ErrorCode = "INVALID_CARD"
	ErrorCodePaymentAmountMismatch                               ErrorCode = "PAYMENT_AMOUNT_MISMATCH"
	ErrorCodeGenericDecline                                      ErrorCode = "GENERIC_DECLINE"
	ErrorCodeCvvFailure                                          ErrorCode = "CVV_FAILURE"
	ErrorCodeAddressVerificationFailure                          ErrorCode = "ADDRESS_VERIFICATION_FAILURE"
	ErrorCodeInvalidAccount                                      ErrorCode = "INVALID_ACCOUNT"
	ErrorCodeCurrencyMismatch                                    ErrorCode = "CURRENCY_MISMATCH"
	ErrorCodeInsufficientFunds                                   ErrorCode = "INSUFFICIENT_FUNDS"
	ErrorCodeInsufficientPermissions                             ErrorCode = "INSUFFICIENT_PERMISSIONS"
	ErrorCodeCardholderInsufficientPermissions                   ErrorCode = "CARDHOLDER_INSUFFICIENT_PERMISSIONS"
	ErrorCodeInvalidLocation                                     ErrorCode = "INVALID_LOCATION"
	ErrorCodeTransactionLimit                                    ErrorCode = "TRANSACTION_LIMIT"
	ErrorCodeVoiceFailure                                        ErrorCode = "VOICE_FAILURE"
	ErrorCodePanFailure                                          ErrorCode = "PAN_FAILURE"
	ErrorCodeExpirationFailure                                   ErrorCode = "EXPIRATION_FAILURE"
	ErrorCodeCardNotSupported                                    ErrorCode = "CARD_NOT_SUPPORTED"
	ErrorCodeInvalidPin                                          ErrorCode = "INVALID_PIN"
	ErrorCodeMissingPin                                          ErrorCode = "MISSING_PIN"
	ErrorCodeMissingAccountType                                  ErrorCode = "MISSING_ACCOUNT_TYPE"
	ErrorCodeInvalidPostalCode                                   ErrorCode = "INVALID_POSTAL_CODE"
	ErrorCodeInvalidFees                                         ErrorCode = "INVALID_FEES"
	ErrorCodeManuallyEnteredPaymentNotSupported                  ErrorCode = "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED"
	ErrorCodePaymentLimitExceeded                                ErrorCode = "PAYMENT_LIMIT_EXCEEDED"
	ErrorCodeGiftCardAvailableAmount                             ErrorCode = "GIFT_CARD_AVAILABLE_AMOUNT"
	ErrorCodeGiftCardBuyerDailyLimitReached                      ErrorCode = "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED"
	ErrorCodeGiftCardInvalidAmount                               ErrorCode = "GIFT_CARD_INVALID_AMOUNT"
	ErrorCodeGiftCardMaxValueReached                             ErrorCode = "GIFT_CARD_MAX_VALUE_REACHED"
	ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached        ErrorCode = "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED"
	ErrorCodeGiftCardValueAdditionLimitReached                   ErrorCode = "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED"
	ErrorCodeAccountUnusable                                     ErrorCode = "ACCOUNT_UNUSABLE"
	ErrorCodeBuyerRefusedPayment                                 ErrorCode = "BUYER_REFUSED_PAYMENT"
	ErrorCodeDelayedTransactionExpired                           ErrorCode = "DELAYED_TRANSACTION_EXPIRED"
	ErrorCodeDelayedTransactionCanceled                          ErrorCode = "DELAYED_TRANSACTION_CANCELED"
	ErrorCodeDelayedTransactionCaptured                          ErrorCode = "DELAYED_TRANSACTION_CAPTURED"
	ErrorCodeDelayedTransactionFailed                            ErrorCode = "DELAYED_TRANSACTION_FAILED"
	ErrorCodeCardTokenExpired                                    ErrorCode = "CARD_TOKEN_EXPIRED"
	ErrorCodeCardTokenUsed                                       ErrorCode = "CARD_TOKEN_USED"
	ErrorCodeAmountTooHigh                                       ErrorCode = "AMOUNT_TOO_HIGH"
	ErrorCodeUnsupportedInstrumentType                           ErrorCode = "UNSUPPORTED_INSTRUMENT_TYPE"
	ErrorCodeRefundAmountInvalid                                 ErrorCode = "REFUND_AMOUNT_INVALID"
	ErrorCodeRefundAlreadyPending                                ErrorCode = "REFUND_ALREADY_PENDING"
	ErrorCodePaymentNotRefundable                                ErrorCode = "PAYMENT_NOT_REFUNDABLE"
	ErrorCodeRefundDeclined                                      ErrorCode = "REFUND_DECLINED"
	ErrorCodeInvalidCardData                                     ErrorCode = "INVALID_CARD_DATA"
	ErrorCodeSourceUsed                                          ErrorCode = "SOURCE_USED"
	ErrorCodeSourceExpired                                       ErrorCode = "SOURCE_EXPIRED"
	ErrorCodeUnsupportedLoyaltyRewardTier                        ErrorCode = "UNSUPPORTED_LOYALTY_REWARD_TIER"
	ErrorCodeLocationMismatch                                    ErrorCode = "LOCATION_MISMATCH"
	ErrorCodeOrderExpired                                        ErrorCode = "ORDER_EXPIRED"
	ErrorCodeOrderAlreadyUsed                                    ErrorCode = "ORDER_ALREADY_USED"
	ErrorCodeOrderTooManyCatalogObjects                          ErrorCode = "ORDER_TOO_MANY_CATALOG_OBJECTS"
	ErrorCodeInsufficientInventory                               ErrorCode = "INSUFFICIENT_INVENTORY"
	ErrorCodePriceMismatch                                       ErrorCode = "PRICE_MISMATCH"
	ErrorCodeVersionMismatch                                     ErrorCode = "VERSION_MISMATCH"
	ErrorCodeIdempotencyKeyReused                                ErrorCode = "IDEMPOTENCY_KEY_REUSED"
	ErrorCodeUnexpectedValue                                     ErrorCode = "UNEXPECTED_VALUE"
	ErrorCodeSandboxNotSupported                                 ErrorCode = "SANDBOX_NOT_SUPPORTED"
	ErrorCodeInvalidEmailAddress                                 ErrorCode = "INVALID_EMAIL_ADDRESS"
	ErrorCodeInvalidPhoneNumber                                  ErrorCode = "INVALID_PHONE_NUMBER"
	ErrorCodeCheckoutExpired                                     ErrorCode = "CHECKOUT_EXPIRED"
	ErrorCodeBadCertificate                                      ErrorCode = "BAD_CERTIFICATE"
	ErrorCodeInvalidSquareVersionFormat                          ErrorCode = "INVALID_SQUARE_VERSION_FORMAT"
	ErrorCodeApiVersionIncompatible                              ErrorCode = "API_VERSION_INCOMPATIBLE"
	ErrorCodeInvalidUrl                                          ErrorCode = "INVALID_URL"
	ErrorCodeHttpsOnly                                           ErrorCode = "HTTPS_ONLY"
	ErrorCodeUnreachableUrl                                      ErrorCode = "UNREACHABLE_URL"
	ErrorCodeSessionExpired                                      ErrorCode = "SESSION_EXPIRED"
	ErrorCodeInvalidVerificationCode                             ErrorCode = "INVALID_VERIFICATION_CODE"
	ErrorCodeCardDeclined                                        ErrorCode = "CARD_DECLINED"
	ErrorCodeVerifyCvvFailure                                    ErrorCode = "VERIFY_CVV_FAILURE"
	ErrorCodeVerifyAvsFailure                                    ErrorCode = "VERIFY_AVS_FAILURE"
	ErrorCodeCardDeclinedCallIssuer                              ErrorCode = "CARD_DECLINED_CALL_ISSUER"
	ErrorCodeCardDeclinedVerificationRequired                    ErrorCode = "CARD_DECLINED_VERIFICATION_REQUIRED"
	ErrorCodeBadExpiration                                       ErrorCode = "BAD_EXPIRATION"
	ErrorCodeChipInsertionRequired                               ErrorCode = "CHIP_INSERTION_REQUIRED"
	ErrorCodeAllowablePinTriesExceeded                           ErrorCode = "ALLOWABLE_PIN_TRIES_EXCEEDED"
	ErrorCodeReservationDeclined                                 ErrorCode = "RESERVATION_DECLINED"
	ErrorCodeBlockedByBlocklist                                  ErrorCode = "BLOCKED_BY_BLOCKLIST"
	ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique       ErrorCode = "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE"
	ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime     ErrorCode = "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME"
	ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed ErrorCode = "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED"
	ErrorCodeFulfillmentPreferencesAssignmentIsImmutable         ErrorCode = "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE"
	ErrorCodeInvalidTimezone                                     ErrorCode = "INVALID_TIMEZONE"
	ErrorCodeUnknownBodyParameter                                ErrorCode = "UNKNOWN_BODY_PARAMETER"
	ErrorCodeFulfillmentPreferencesConflictingAssignmentType     ErrorCode = "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE"
	ErrorCodeNotFound                                            ErrorCode = "NOT_FOUND"
	ErrorCodeApplePaymentProcessingCertificateHashNotFound       ErrorCode = "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND"
	ErrorCodeMethodNotAllowed                                    ErrorCode = "METHOD_NOT_ALLOWED"
	ErrorCodeNotAcceptable                                       ErrorCode = "NOT_ACCEPTABLE"
	ErrorCodeRequestTimeout                                      ErrorCode = "REQUEST_TIMEOUT"
	ErrorCodeConflict                                            ErrorCode = "CONFLICT"
	ErrorCodeGone                                                ErrorCode = "GONE"
	ErrorCodeRequestEntityTooLarge                               ErrorCode = "REQUEST_ENTITY_TOO_LARGE"
	ErrorCodeUnsupportedMediaType                                ErrorCode = "UNSUPPORTED_MEDIA_TYPE"
	ErrorCodeUnprocessableEntity                                 ErrorCode = "UNPROCESSABLE_ENTITY"
	ErrorCodeRateLimited                                         ErrorCode = "RATE_LIMITED"
	ErrorCodeClientClosedRequest                                 ErrorCode = "CLIENT_CLOSED_REQUEST"
	ErrorCodeNotImplemented                                      ErrorCode = "NOT_IMPLEMENTED"
	ErrorCodeBadGateway                                          ErrorCode = "BAD_GATEWAY"
	ErrorCodeServiceUnavailable                                  ErrorCode = "SERVICE_UNAVAILABLE"
	ErrorCodeTemporaryError                                      ErrorCode = "TEMPORARY_ERROR"
	ErrorCodeGatewayTimeout                                      ErrorCode = "GATEWAY_TIMEOUT"
)

func NewErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "INTERNAL_SERVER_ERROR":
		return ErrorCodeInternalServerError, nil
	case "UNAUTHORIZED":
		return ErrorCodeUnauthorized, nil
	case "ACCESS_TOKEN_EXPIRED":
		return ErrorCodeAccessTokenExpired, nil
	case "ACCESS_TOKEN_REVOKED":
		return ErrorCodeAccessTokenRevoked, nil
	case "CLIENT_DISABLED":
		return ErrorCodeClientDisabled, nil
	case "FORBIDDEN":
		return ErrorCodeForbidden, nil
	case "INSUFFICIENT_SCOPES":
		return ErrorCodeInsufficientScopes, nil
	case "APPLICATION_DISABLED":
		return ErrorCodeApplicationDisabled, nil
	case "V1_APPLICATION":
		return ErrorCodeV1Application, nil
	case "V1_ACCESS_TOKEN":
		return ErrorCodeV1AccessToken, nil
	case "CARD_PROCESSING_NOT_ENABLED":
		return ErrorCodeCardProcessingNotEnabled, nil
	case "MERCHANT_SUBSCRIPTION_NOT_FOUND":
		return ErrorCodeMerchantSubscriptionNotFound, nil
	case "BAD_REQUEST":
		return ErrorCodeBadRequest, nil
	case "MISSING_REQUIRED_PARAMETER":
		return ErrorCodeMissingRequiredParameter, nil
	case "INCORRECT_TYPE":
		return ErrorCodeIncorrectType, nil
	case "INVALID_TIME":
		return ErrorCodeInvalidTime, nil
	case "INVALID_TIME_RANGE":
		return ErrorCodeInvalidTimeRange, nil
	case "INVALID_VALUE":
		return ErrorCodeInvalidValue, nil
	case "INVALID_CURSOR":
		return ErrorCodeInvalidCursor, nil
	case "UNKNOWN_QUERY_PARAMETER":
		return ErrorCodeUnknownQueryParameter, nil
	case "CONFLICTING_PARAMETERS":
		return ErrorCodeConflictingParameters, nil
	case "EXPECTED_JSON_BODY":
		return ErrorCodeExpectedJsonBody, nil
	case "INVALID_SORT_ORDER":
		return ErrorCodeInvalidSortOrder, nil
	case "VALUE_REGEX_MISMATCH":
		return ErrorCodeValueRegexMismatch, nil
	case "VALUE_TOO_SHORT":
		return ErrorCodeValueTooShort, nil
	case "VALUE_TOO_LONG":
		return ErrorCodeValueTooLong, nil
	case "VALUE_TOO_LOW":
		return ErrorCodeValueTooLow, nil
	case "VALUE_TOO_HIGH":
		return ErrorCodeValueTooHigh, nil
	case "VALUE_EMPTY":
		return ErrorCodeValueEmpty, nil
	case "ARRAY_LENGTH_TOO_LONG":
		return ErrorCodeArrayLengthTooLong, nil
	case "ARRAY_LENGTH_TOO_SHORT":
		return ErrorCodeArrayLengthTooShort, nil
	case "ARRAY_EMPTY":
		return ErrorCodeArrayEmpty, nil
	case "EXPECTED_BOOLEAN":
		return ErrorCodeExpectedBoolean, nil
	case "EXPECTED_INTEGER":
		return ErrorCodeExpectedInteger, nil
	case "EXPECTED_FLOAT":
		return ErrorCodeExpectedFloat, nil
	case "EXPECTED_STRING":
		return ErrorCodeExpectedString, nil
	case "EXPECTED_OBJECT":
		return ErrorCodeExpectedObject, nil
	case "EXPECTED_ARRAY":
		return ErrorCodeExpectedArray, nil
	case "EXPECTED_MAP":
		return ErrorCodeExpectedMap, nil
	case "EXPECTED_BASE64_ENCODED_BYTE_ARRAY":
		return ErrorCodeExpectedBase64EncodedByteArray, nil
	case "INVALID_ARRAY_VALUE":
		return ErrorCodeInvalidArrayValue, nil
	case "INVALID_ENUM_VALUE":
		return ErrorCodeInvalidEnumValue, nil
	case "INVALID_CONTENT_TYPE":
		return ErrorCodeInvalidContentType, nil
	case "INVALID_FORM_VALUE":
		return ErrorCodeInvalidFormValue, nil
	case "CUSTOMER_NOT_FOUND":
		return ErrorCodeCustomerNotFound, nil
	case "BUYER_NOT_FOUND":
		return ErrorCodeBuyerNotFound, nil
	case "ONE_INSTRUMENT_EXPECTED":
		return ErrorCodeOneInstrumentExpected, nil
	case "NO_FIELDS_SET":
		return ErrorCodeNoFieldsSet, nil
	case "DEPRECATED_FIELD_SET":
		return ErrorCodeDeprecatedFieldSet, nil
	case "RETIRED_FIELD_SET":
		return ErrorCodeRetiredFieldSet, nil
	case "TOO_MANY_MAP_ENTRIES":
		return ErrorCodeTooManyMapEntries, nil
	case "MAP_KEY_LENGTH_TOO_SHORT":
		return ErrorCodeMapKeyLengthTooShort, nil
	case "MAP_KEY_LENGTH_TOO_LONG":
		return ErrorCodeMapKeyLengthTooLong, nil
	case "CUSTOMER_MISSING_NAME":
		return ErrorCodeCustomerMissingName, nil
	case "CUSTOMER_MISSING_EMAIL":
		return ErrorCodeCustomerMissingEmail, nil
	case "INVALID_PAUSE_LENGTH":
		return ErrorCodeInvalidPauseLength, nil
	case "INVALID_DATE":
		return ErrorCodeInvalidDate, nil
	case "JOB_TEMPLATE_NAME_TAKEN":
		return ErrorCodeJobTemplateNameTaken, nil
	case "CLIENT_NOT_SUPPORTED":
		return ErrorCodeClientNotSupported, nil
	case "CARD_EXPIRED":
		return ErrorCodeCardExpired, nil
	case "INVALID_EXPIRATION":
		return ErrorCodeInvalidExpiration, nil
	case "INVALID_EXPIRATION_YEAR":
		return ErrorCodeInvalidExpirationYear, nil
	case "INVALID_EXPIRATION_DATE":
		return ErrorCodeInvalidExpirationDate, nil
	case "UNSUPPORTED_CARD_BRAND":
		return ErrorCodeUnsupportedCardBrand, nil
	case "UNSUPPORTED_ENTRY_METHOD":
		return ErrorCodeUnsupportedEntryMethod, nil
	case "INVALID_ENCRYPTED_CARD":
		return ErrorCodeInvalidEncryptedCard, nil
	case "INVALID_CARD":
		return ErrorCodeInvalidCard, nil
	case "PAYMENT_AMOUNT_MISMATCH":
		return ErrorCodePaymentAmountMismatch, nil
	case "GENERIC_DECLINE":
		return ErrorCodeGenericDecline, nil
	case "CVV_FAILURE":
		return ErrorCodeCvvFailure, nil
	case "ADDRESS_VERIFICATION_FAILURE":
		return ErrorCodeAddressVerificationFailure, nil
	case "INVALID_ACCOUNT":
		return ErrorCodeInvalidAccount, nil
	case "CURRENCY_MISMATCH":
		return ErrorCodeCurrencyMismatch, nil
	case "INSUFFICIENT_FUNDS":
		return ErrorCodeInsufficientFunds, nil
	case "INSUFFICIENT_PERMISSIONS":
		return ErrorCodeInsufficientPermissions, nil
	case "CARDHOLDER_INSUFFICIENT_PERMISSIONS":
		return ErrorCodeCardholderInsufficientPermissions, nil
	case "INVALID_LOCATION":
		return ErrorCodeInvalidLocation, nil
	case "TRANSACTION_LIMIT":
		return ErrorCodeTransactionLimit, nil
	case "VOICE_FAILURE":
		return ErrorCodeVoiceFailure, nil
	case "PAN_FAILURE":
		return ErrorCodePanFailure, nil
	case "EXPIRATION_FAILURE":
		return ErrorCodeExpirationFailure, nil
	case "CARD_NOT_SUPPORTED":
		return ErrorCodeCardNotSupported, nil
	case "INVALID_PIN":
		return ErrorCodeInvalidPin, nil
	case "MISSING_PIN":
		return ErrorCodeMissingPin, nil
	case "MISSING_ACCOUNT_TYPE":
		return ErrorCodeMissingAccountType, nil
	case "INVALID_POSTAL_CODE":
		return ErrorCodeInvalidPostalCode, nil
	case "INVALID_FEES":
		return ErrorCodeInvalidFees, nil
	case "MANUALLY_ENTERED_PAYMENT_NOT_SUPPORTED":
		return ErrorCodeManuallyEnteredPaymentNotSupported, nil
	case "PAYMENT_LIMIT_EXCEEDED":
		return ErrorCodePaymentLimitExceeded, nil
	case "GIFT_CARD_AVAILABLE_AMOUNT":
		return ErrorCodeGiftCardAvailableAmount, nil
	case "GIFT_CARD_BUYER_DAILY_LIMIT_REACHED":
		return ErrorCodeGiftCardBuyerDailyLimitReached, nil
	case "GIFT_CARD_INVALID_AMOUNT":
		return ErrorCodeGiftCardInvalidAmount, nil
	case "GIFT_CARD_MAX_VALUE_REACHED":
		return ErrorCodeGiftCardMaxValueReached, nil
	case "GIFT_CARD_MERCHANT_MAX_OUTSTANDING_BALANCE_REACHED":
		return ErrorCodeGiftCardMerchantMaxOutstandingBalanceReached, nil
	case "GIFT_CARD_VALUE_ADDITION_LIMIT_REACHED":
		return ErrorCodeGiftCardValueAdditionLimitReached, nil
	case "ACCOUNT_UNUSABLE":
		return ErrorCodeAccountUnusable, nil
	case "BUYER_REFUSED_PAYMENT":
		return ErrorCodeBuyerRefusedPayment, nil
	case "DELAYED_TRANSACTION_EXPIRED":
		return ErrorCodeDelayedTransactionExpired, nil
	case "DELAYED_TRANSACTION_CANCELED":
		return ErrorCodeDelayedTransactionCanceled, nil
	case "DELAYED_TRANSACTION_CAPTURED":
		return ErrorCodeDelayedTransactionCaptured, nil
	case "DELAYED_TRANSACTION_FAILED":
		return ErrorCodeDelayedTransactionFailed, nil
	case "CARD_TOKEN_EXPIRED":
		return ErrorCodeCardTokenExpired, nil
	case "CARD_TOKEN_USED":
		return ErrorCodeCardTokenUsed, nil
	case "AMOUNT_TOO_HIGH":
		return ErrorCodeAmountTooHigh, nil
	case "UNSUPPORTED_INSTRUMENT_TYPE":
		return ErrorCodeUnsupportedInstrumentType, nil
	case "REFUND_AMOUNT_INVALID":
		return ErrorCodeRefundAmountInvalid, nil
	case "REFUND_ALREADY_PENDING":
		return ErrorCodeRefundAlreadyPending, nil
	case "PAYMENT_NOT_REFUNDABLE":
		return ErrorCodePaymentNotRefundable, nil
	case "REFUND_DECLINED":
		return ErrorCodeRefundDeclined, nil
	case "INVALID_CARD_DATA":
		return ErrorCodeInvalidCardData, nil
	case "SOURCE_USED":
		return ErrorCodeSourceUsed, nil
	case "SOURCE_EXPIRED":
		return ErrorCodeSourceExpired, nil
	case "UNSUPPORTED_LOYALTY_REWARD_TIER":
		return ErrorCodeUnsupportedLoyaltyRewardTier, nil
	case "LOCATION_MISMATCH":
		return ErrorCodeLocationMismatch, nil
	case "ORDER_EXPIRED":
		return ErrorCodeOrderExpired, nil
	case "ORDER_ALREADY_USED":
		return ErrorCodeOrderAlreadyUsed, nil
	case "ORDER_TOO_MANY_CATALOG_OBJECTS":
		return ErrorCodeOrderTooManyCatalogObjects, nil
	case "INSUFFICIENT_INVENTORY":
		return ErrorCodeInsufficientInventory, nil
	case "PRICE_MISMATCH":
		return ErrorCodePriceMismatch, nil
	case "VERSION_MISMATCH":
		return ErrorCodeVersionMismatch, nil
	case "IDEMPOTENCY_KEY_REUSED":
		return ErrorCodeIdempotencyKeyReused, nil
	case "UNEXPECTED_VALUE":
		return ErrorCodeUnexpectedValue, nil
	case "SANDBOX_NOT_SUPPORTED":
		return ErrorCodeSandboxNotSupported, nil
	case "INVALID_EMAIL_ADDRESS":
		return ErrorCodeInvalidEmailAddress, nil
	case "INVALID_PHONE_NUMBER":
		return ErrorCodeInvalidPhoneNumber, nil
	case "CHECKOUT_EXPIRED":
		return ErrorCodeCheckoutExpired, nil
	case "BAD_CERTIFICATE":
		return ErrorCodeBadCertificate, nil
	case "INVALID_SQUARE_VERSION_FORMAT":
		return ErrorCodeInvalidSquareVersionFormat, nil
	case "API_VERSION_INCOMPATIBLE":
		return ErrorCodeApiVersionIncompatible, nil
	case "INVALID_URL":
		return ErrorCodeInvalidUrl, nil
	case "HTTPS_ONLY":
		return ErrorCodeHttpsOnly, nil
	case "UNREACHABLE_URL":
		return ErrorCodeUnreachableUrl, nil
	case "SESSION_EXPIRED":
		return ErrorCodeSessionExpired, nil
	case "INVALID_VERIFICATION_CODE":
		return ErrorCodeInvalidVerificationCode, nil
	case "CARD_DECLINED":
		return ErrorCodeCardDeclined, nil
	case "VERIFY_CVV_FAILURE":
		return ErrorCodeVerifyCvvFailure, nil
	case "VERIFY_AVS_FAILURE":
		return ErrorCodeVerifyAvsFailure, nil
	case "CARD_DECLINED_CALL_ISSUER":
		return ErrorCodeCardDeclinedCallIssuer, nil
	case "CARD_DECLINED_VERIFICATION_REQUIRED":
		return ErrorCodeCardDeclinedVerificationRequired, nil
	case "BAD_EXPIRATION":
		return ErrorCodeBadExpiration, nil
	case "CHIP_INSERTION_REQUIRED":
		return ErrorCodeChipInsertionRequired, nil
	case "ALLOWABLE_PIN_TRIES_EXCEEDED":
		return ErrorCodeAllowablePinTriesExceeded, nil
	case "RESERVATION_DECLINED":
		return ErrorCodeReservationDeclined, nil
	case "BLOCKED_BY_BLOCKLIST":
		return ErrorCodeBlockedByBlocklist, nil
	case "FULFILLMENT_PREFERENCES_RESTRICTED_DATE_NOT_UNIQUE":
		return ErrorCodeFulfillmentPreferencesRestrictedDateNotUnique, nil
	case "FULFILLMENT_PREFERENCES_INVALID_SCHEDULING_DATETIME":
		return ErrorCodeFulfillmentPreferencesInvalidSchedulingDatetime, nil
	case "FULFILLMENT_PREFERENCES_FULFILLMENT_SCHEDULE_NOT_ALLOWED":
		return ErrorCodeFulfillmentPreferencesFulfillmentScheduleNotAllowed, nil
	case "FULFILLMENT_PREFERENCES_ASSIGNMENT_IS_IMMUTABLE":
		return ErrorCodeFulfillmentPreferencesAssignmentIsImmutable, nil
	case "INVALID_TIMEZONE":
		return ErrorCodeInvalidTimezone, nil
	case "UNKNOWN_BODY_PARAMETER":
		return ErrorCodeUnknownBodyParameter, nil
	case "FULFILLMENT_PREFERENCES_CONFLICTING_ASSIGNMENT_TYPE":
		return ErrorCodeFulfillmentPreferencesConflictingAssignmentType, nil
	case "NOT_FOUND":
		return ErrorCodeNotFound, nil
	case "APPLE_PAYMENT_PROCESSING_CERTIFICATE_HASH_NOT_FOUND":
		return ErrorCodeApplePaymentProcessingCertificateHashNotFound, nil
	case "METHOD_NOT_ALLOWED":
		return ErrorCodeMethodNotAllowed, nil
	case "NOT_ACCEPTABLE":
		return ErrorCodeNotAcceptable, nil
	case "REQUEST_TIMEOUT":
		return ErrorCodeRequestTimeout, nil
	case "CONFLICT":
		return ErrorCodeConflict, nil
	case "GONE":
		return ErrorCodeGone, nil
	case "REQUEST_ENTITY_TOO_LARGE":
		return ErrorCodeRequestEntityTooLarge, nil
	case "UNSUPPORTED_MEDIA_TYPE":
		return ErrorCodeUnsupportedMediaType, nil
	case "UNPROCESSABLE_ENTITY":
		return ErrorCodeUnprocessableEntity, nil
	case "RATE_LIMITED":
		return ErrorCodeRateLimited, nil
	case "CLIENT_CLOSED_REQUEST":
		return ErrorCodeClientClosedRequest, nil
	case "NOT_IMPLEMENTED":
		return ErrorCodeNotImplemented, nil
	case "BAD_GATEWAY":
		return ErrorCodeBadGateway, nil
	case "SERVICE_UNAVAILABLE":
		return ErrorCodeServiceUnavailable, nil
	case "TEMPORARY_ERROR":
		return ErrorCodeTemporaryError, nil
	case "GATEWAY_TIMEOUT":
		return ErrorCodeGatewayTimeout, nil
	}
	var t ErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorCode) Ptr() *ErrorCode {
	return &e
}

// Indicates which products matched by a CatalogPricingRule
// will be excluded if the pricing rule uses an exclude set.
type ExcludeStrategy string

const (
	ExcludeStrategyExcludeStrategyDoNotUse ExcludeStrategy = "EXCLUDE_STRATEGY_DO_NOT_USE"
	ExcludeStrategyLeastExpensive          ExcludeStrategy = "LEAST_EXPENSIVE"
	ExcludeStrategyMostExpensive           ExcludeStrategy = "MOST_EXPENSIVE"
)

func NewExcludeStrategyFromString(s string) (ExcludeStrategy, error) {
	switch s {
	case "EXCLUDE_STRATEGY_DO_NOT_USE":
		return ExcludeStrategyExcludeStrategyDoNotUse, nil
	case "LEAST_EXPENSIVE":
		return ExcludeStrategyLeastExpensive, nil
	case "MOST_EXPENSIVE":
		return ExcludeStrategyMostExpensive, nil
	}
	var t ExcludeStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ExcludeStrategy) Ptr() *ExcludeStrategy {
	return &e
}

// Stores details about an external payment. Contains only non-confidential information.
// For more information, see
// [Take External Payments](https://developer.squareup.com/docs/payments-api/take-payments/external-payments).
type ExternalPaymentDetails struct {
	// The type of external payment the seller received. It can be one of the following:
	//
	// - CHECK - Paid using a physical check.
	// - BANK_TRANSFER - Paid using external bank transfer.
	// - OTHER_GIFT_CARD - Paid using a non-Square gift card.
	// - CRYPTO - Paid using a crypto currency.
	// - SQUARE_CASH - Paid using Square Cash App.
	// - SOCIAL - Paid using peer-to-peer payment applications.
	// - EXTERNAL - A third-party application gathered this payment outside of Square.
	// - EMONEY - Paid using an E-money provider.
	// - CARD - A credit or debit card that Square does not support.
	// - STORED_BALANCE - Use for house accounts, store credit, and so forth.
	// - FOOD_VOUCHER - Restaurant voucher provided by employers to employees to pay for meals
	// - OTHER - A type not listed here.
	Type string `json:"type" url:"type"`
	// A description of the external payment source. For example,
	// "Food Delivery Service".
	Source string `json:"source" url:"source"`
	// An ID to associate the payment to its originating source.
	SourceId       *string `json:"source_id,omitempty" url:"source_id,omitempty"`
	SourceFeeMoney *Money  `json:"source_fee_money,omitempty" url:"source_fee_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalPaymentDetails) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalPaymentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalPaymentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalPaymentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalPaymentDetails) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines the response returned by [GetRefund](api-endpoint:Refunds-GetPaymentRefund).
//
// Note: If there are errors processing the request, the refund field might not be
// present or it might be present in a FAILED state.
type GetPaymentRefundResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error       `json:"errors,omitempty" url:"errors,omitempty"`
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentRefundResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentRefundResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentRefundResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentRefundResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentRefundResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Defines the response returned by [GetPayment](api-endpoint:Payments-GetPayment).
type GetPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors  []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPaymentResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPaymentResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetPayoutResponse struct {
	Payout *Payout `json:"payout,omitempty" url:"payout,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GetPayoutResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetPayoutResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetPayoutResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetPayoutResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetPayoutResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Indicates whether Square should alert the merchant when the inventory quantity of a CatalogItemVariation is low.
type InventoryAlertType string

const (
	InventoryAlertTypeInventoryAlertTypeDoNotUse InventoryAlertType = "INVENTORY_ALERT_TYPE_DO_NOT_USE"
	InventoryAlertTypeNone                       InventoryAlertType = "NONE"
	InventoryAlertTypeLowQuantity                InventoryAlertType = "LOW_QUANTITY"
)

func NewInventoryAlertTypeFromString(s string) (InventoryAlertType, error) {
	switch s {
	case "INVENTORY_ALERT_TYPE_DO_NOT_USE":
		return InventoryAlertTypeInventoryAlertTypeDoNotUse, nil
	case "NONE":
		return InventoryAlertTypeNone, nil
	case "LOW_QUANTITY":
		return InventoryAlertTypeLowQuantity, nil
	}
	var t InventoryAlertType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InventoryAlertType) Ptr() *InventoryAlertType {
	return &i
}

// Price and inventory alerting overrides for a `CatalogItemVariation` at a specific `Location`.
type ItemVariationLocationOverrides struct {
	// The ID of the `Location`. This can include locations that are deactivated.
	LocationId  *string             `json:"location_id,omitempty" url:"location_id,omitempty"`
	PriceMoney  *Money              `json:"price_money,omitempty" url:"price_money,omitempty"`
	PricingType *CatalogPricingType `json:"pricing_type,omitempty" url:"pricing_type,omitempty"`
	// If `true`, inventory tracking is active for the `CatalogItemVariation` at this `Location`.
	TrackInventory     *bool               `json:"track_inventory,omitempty" url:"track_inventory,omitempty"`
	InventoryAlertType *InventoryAlertType `json:"inventory_alert_type,omitempty" url:"inventory_alert_type,omitempty"`
	// If the inventory quantity for the variation is less than or equal to this value and `inventory_alert_type`
	// is `LOW_QUANTITY`, the variation displays an alert in the merchant dashboard.
	//
	// This value is always an integer.
	InventoryAlertThreshold *int64 `json:"inventory_alert_threshold,omitempty" url:"inventory_alert_threshold,omitempty"`
	// Indicates whether the overridden item variation is sold out at the specified location.
	//
	// When inventory tracking is enabled on the item variation either globally or at the specified location,
	// the item variation is automatically marked as sold out when its inventory count reaches zero. The seller
	// can manually set the item variation as sold out even when the inventory count is greater than zero.
	// Attempts by an application to set this attribute are ignored. Regardless how the sold-out status is set,
	// applications should treat its inventory count as zero when this attribute value is `true`.
	SoldOut *bool `json:"sold_out,omitempty" url:"sold_out,omitempty"`
	// The seller-assigned timestamp, of the RFC 3339 format, to indicate when this sold-out variation
	// becomes available again at the specified location. Attempts by an application to set this attribute are ignored.
	// When the current time is later than this attribute value, the affected item variation is no longer sold out.
	SoldOutValidUntil *string `json:"sold_out_valid_until,omitempty" url:"sold_out_valid_until,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *ItemVariationLocationOverrides) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ItemVariationLocationOverrides) UnmarshalJSON(data []byte) error {
	type unmarshaler ItemVariationLocationOverrides
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ItemVariationLocationOverrides(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *ItemVariationLocationOverrides) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Defines the fields that are included in the response body of a request
// to the [ListLocations](api-endpoint:Locations-ListLocations) endpoint.
//
// Either `errors` or `locations` is present in a given response (never both).
type ListLocationsResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The business locations.
	Locations []*Location `json:"locations,omitempty" url:"locations,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListLocationsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListLocationsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListLocationsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListLocationsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListLocationsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the response returned by [ListPaymentRefunds](api-endpoint:Refunds-ListPaymentRefunds).
//
// Either `errors` or `refunds` is present in a given response (never both).
type ListPaymentRefundsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The list of requested refunds.
	Refunds []*PaymentRefund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentRefundsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentRefundsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentRefundsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentRefundsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentRefundsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Defines the response returned by [ListPayments](api-endpoint:Payments-ListPayments).
type ListPaymentsResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	// The requested list of payments.
	Payments []*Payment `json:"payments,omitempty" url:"payments,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty,
	// this is the final response.
	//
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPaymentsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPaymentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPaymentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPaymentsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPaymentsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The response to retrieve payout records entries.
type ListPayoutsResponse struct {
	// The requested list of payouts.
	Payouts []*Payout `json:"payouts,omitempty" url:"payouts,omitempty"`
	// The pagination cursor to be used in a subsequent request. If empty, this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// Information about errors encountered during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *ListPayoutsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListPayoutsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListPayoutsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListPayoutsResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListPayoutsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents one of a business' [locations](https://developer.squareup.com/docs/locations-api).
type Location struct {
	// A short generated string of letters and numbers that uniquely identifies this location instance.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the location.
	// This information appears in the Seller Dashboard as the nickname.
	// A location name must be unique within a seller account.
	Name    *string  `json:"name,omitempty" url:"name,omitempty"`
	Address *Address `json:"address,omitempty" url:"address,omitempty"`
	// The [IANA time zone](https://www.iana.org/time-zones) identifier for
	// the time zone of the location. For example, `America/Los_Angeles`.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// The Square features that are enabled for the location.
	// See [LocationCapability](entity:LocationCapability) for possible values.
	// See [LocationCapability](#type-locationcapability) for possible values
	Capabilities []LocationCapability `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	Status       *LocationStatus      `json:"status,omitempty" url:"status,omitempty"`
	// The time when the location was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The ID of the merchant that owns the location.
	MerchantId *string  `json:"merchant_id,omitempty" url:"merchant_id,omitempty"`
	Country    *Country `json:"country,omitempty" url:"country,omitempty"`
	// The language associated with the location, in
	// [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A).
	// For more information, see [Language Preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences).
	LanguageCode *string   `json:"language_code,omitempty" url:"language_code,omitempty"`
	Currency     *Currency `json:"currency,omitempty" url:"currency,omitempty"`
	// The phone number of the location. For example, `+1 855-700-6000`.
	PhoneNumber *string `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	// The name of the location's overall business. This name is present on receipts and other customer-facing branding.
	BusinessName *string       `json:"business_name,omitempty" url:"business_name,omitempty"`
	Type         *LocationType `json:"type,omitempty" url:"type,omitempty"`
	// The website URL of the location. For example, `https://squareup.com`.
	WebsiteUrl    *string        `json:"website_url,omitempty" url:"website_url,omitempty"`
	BusinessHours *BusinessHours `json:"business_hours,omitempty" url:"business_hours,omitempty"`
	// The email address of the location. This can be unique to the location and is not always the email address for the business owner or administrator.
	BusinessEmail *string `json:"business_email,omitempty" url:"business_email,omitempty"`
	// The description of the location. For example, `Main Street location`.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The Twitter username of the location without the '@' symbol. For example, `Square`.
	TwitterUsername *string `json:"twitter_username,omitempty" url:"twitter_username,omitempty"`
	// The Instagram username of the location without the '@' symbol. For example, `square`.
	InstagramUsername *string `json:"instagram_username,omitempty" url:"instagram_username,omitempty"`
	// The Facebook profile URL of the location. The URL should begin with 'facebook.com/'. For example, `https://www.facebook.com/square`.
	FacebookUrl *string      `json:"facebook_url,omitempty" url:"facebook_url,omitempty"`
	Coordinates *Coordinates `json:"coordinates,omitempty" url:"coordinates,omitempty"`
	// The URL of the logo image for the location. When configured in the Seller
	// Dashboard (Receipts section), the logo appears on transactions (such as receipts and invoices) that Square generates on behalf of the seller.
	// This image should have a roughly square (1:1) aspect ratio and should be at least 200x200 pixels.
	LogoUrl *string `json:"logo_url,omitempty" url:"logo_url,omitempty"`
	// The URL of the Point of Sale background image for the location.
	PosBackgroundUrl *string `json:"pos_background_url,omitempty" url:"pos_background_url,omitempty"`
	// A four-digit number that describes the kind of goods or services sold at the location.
	// The [merchant category code (MCC)](https://developer.squareup.com/docs/locations-api#initialize-a-merchant-category-code) of the location as standardized by ISO 18245.
	// For example, `5045`, for a location that sells computer goods and software.
	Mcc *string `json:"mcc,omitempty" url:"mcc,omitempty"`
	// The URL of a full-format logo image for the location. When configured in the Seller
	// Dashboard (Receipts section), the logo appears on transactions (such as receipts and invoices) that Square generates on behalf of the seller.
	// This image can be wider than it is tall and should be at least 1280x648 pixels.
	FullFormatLogoUrl *string `json:"full_format_logo_url,omitempty" url:"full_format_logo_url,omitempty"`
	TaxIds            *TaxIds `json:"tax_ids,omitempty" url:"tax_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Location) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Location) UnmarshalJSON(data []byte) error {
	type unmarshaler Location
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Location(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Location) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// The capabilities a location might have.
type LocationCapability string

const (
	LocationCapabilityCreditCardProcessing LocationCapability = "CREDIT_CARD_PROCESSING"
	LocationCapabilityAutomaticTransfers   LocationCapability = "AUTOMATIC_TRANSFERS"
)

func NewLocationCapabilityFromString(s string) (LocationCapability, error) {
	switch s {
	case "CREDIT_CARD_PROCESSING":
		return LocationCapabilityCreditCardProcessing, nil
	case "AUTOMATIC_TRANSFERS":
		return LocationCapabilityAutomaticTransfers, nil
	}
	var t LocationCapability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationCapability) Ptr() *LocationCapability {
	return &l
}

// A location's status.
type LocationStatus string

const (
	LocationStatusActive   LocationStatus = "ACTIVE"
	LocationStatusInactive LocationStatus = "INACTIVE"
)

func NewLocationStatusFromString(s string) (LocationStatus, error) {
	switch s {
	case "ACTIVE":
		return LocationStatusActive, nil
	case "INACTIVE":
		return LocationStatusInactive, nil
	}
	var t LocationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationStatus) Ptr() *LocationStatus {
	return &l
}

// A location's type.
type LocationType string

const (
	LocationTypePhysical LocationType = "PHYSICAL"
	LocationTypeMobile   LocationType = "MOBILE"
)

func NewLocationTypeFromString(s string) (LocationType, error) {
	switch s {
	case "PHYSICAL":
		return LocationTypePhysical, nil
	case "MOBILE":
		return LocationTypeMobile, nil
	}
	var t LocationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LocationType) Ptr() *LocationType {
	return &l
}

// Represents a unit of measurement to use with a quantity, such as ounces
// or inches. Exactly one of the following fields are required: `custom_unit`,
// `area_unit`, `length_unit`, `volume_unit`, and `weight_unit`.
type MeasurementUnit struct {
	CustomUnit  *MeasurementUnitCustom   `json:"custom_unit,omitempty" url:"custom_unit,omitempty"`
	AreaUnit    *MeasurementUnitArea     `json:"area_unit,omitempty" url:"area_unit,omitempty"`
	LengthUnit  *MeasurementUnitLength   `json:"length_unit,omitempty" url:"length_unit,omitempty"`
	VolumeUnit  *MeasurementUnitVolume   `json:"volume_unit,omitempty" url:"volume_unit,omitempty"`
	WeightUnit  *MeasurementUnitWeight   `json:"weight_unit,omitempty" url:"weight_unit,omitempty"`
	GenericUnit *MeasurementUnitGeneric  `json:"generic_unit,omitempty" url:"generic_unit,omitempty"`
	TimeUnit    *MeasurementUnitTime     `json:"time_unit,omitempty" url:"time_unit,omitempty"`
	Type        *MeasurementUnitUnitType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnit) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnit) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// Unit of area used to measure a quantity.
type MeasurementUnitArea string

const (
	MeasurementUnitAreaInvalidArea            MeasurementUnitArea = "INVALID_AREA"
	MeasurementUnitAreaImperialAcre           MeasurementUnitArea = "IMPERIAL_ACRE"
	MeasurementUnitAreaImperialSquareInch     MeasurementUnitArea = "IMPERIAL_SQUARE_INCH"
	MeasurementUnitAreaImperialSquareFoot     MeasurementUnitArea = "IMPERIAL_SQUARE_FOOT"
	MeasurementUnitAreaImperialSquareYard     MeasurementUnitArea = "IMPERIAL_SQUARE_YARD"
	MeasurementUnitAreaImperialSquareMile     MeasurementUnitArea = "IMPERIAL_SQUARE_MILE"
	MeasurementUnitAreaMetricSquareCentimeter MeasurementUnitArea = "METRIC_SQUARE_CENTIMETER"
	MeasurementUnitAreaMetricSquareMeter      MeasurementUnitArea = "METRIC_SQUARE_METER"
	MeasurementUnitAreaMetricSquareKilometer  MeasurementUnitArea = "METRIC_SQUARE_KILOMETER"
)

func NewMeasurementUnitAreaFromString(s string) (MeasurementUnitArea, error) {
	switch s {
	case "INVALID_AREA":
		return MeasurementUnitAreaInvalidArea, nil
	case "IMPERIAL_ACRE":
		return MeasurementUnitAreaImperialAcre, nil
	case "IMPERIAL_SQUARE_INCH":
		return MeasurementUnitAreaImperialSquareInch, nil
	case "IMPERIAL_SQUARE_FOOT":
		return MeasurementUnitAreaImperialSquareFoot, nil
	case "IMPERIAL_SQUARE_YARD":
		return MeasurementUnitAreaImperialSquareYard, nil
	case "IMPERIAL_SQUARE_MILE":
		return MeasurementUnitAreaImperialSquareMile, nil
	case "METRIC_SQUARE_CENTIMETER":
		return MeasurementUnitAreaMetricSquareCentimeter, nil
	case "METRIC_SQUARE_METER":
		return MeasurementUnitAreaMetricSquareMeter, nil
	case "METRIC_SQUARE_KILOMETER":
		return MeasurementUnitAreaMetricSquareKilometer, nil
	}
	var t MeasurementUnitArea
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitArea) Ptr() *MeasurementUnitArea {
	return &m
}

// The information needed to define a custom unit, provided by the seller.
type MeasurementUnitCustom struct {
	// The name of the custom unit, for example "bushel".
	Name string `json:"name" url:"name"`
	// The abbreviation of the custom unit, such as "bsh" (bushel). This appears
	// in the cart for the Point of Sale app, and in reports.
	Abbreviation string `json:"abbreviation" url:"abbreviation"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MeasurementUnitCustom) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MeasurementUnitCustom) UnmarshalJSON(data []byte) error {
	type unmarshaler MeasurementUnitCustom
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MeasurementUnitCustom(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MeasurementUnitCustom) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MeasurementUnitGeneric string

const (
	MeasurementUnitGenericInvalidGenericUnit MeasurementUnitGeneric = "INVALID_GENERIC_UNIT"
	MeasurementUnitGenericUnit               MeasurementUnitGeneric = "UNIT"
)

func NewMeasurementUnitGenericFromString(s string) (MeasurementUnitGeneric, error) {
	switch s {
	case "INVALID_GENERIC_UNIT":
		return MeasurementUnitGenericInvalidGenericUnit, nil
	case "UNIT":
		return MeasurementUnitGenericUnit, nil
	}
	var t MeasurementUnitGeneric
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitGeneric) Ptr() *MeasurementUnitGeneric {
	return &m
}

// The unit of length used to measure a quantity.
type MeasurementUnitLength string

const (
	MeasurementUnitLengthInvalidLength    MeasurementUnitLength = "INVALID_LENGTH"
	MeasurementUnitLengthImperialInch     MeasurementUnitLength = "IMPERIAL_INCH"
	MeasurementUnitLengthImperialFoot     MeasurementUnitLength = "IMPERIAL_FOOT"
	MeasurementUnitLengthImperialYard     MeasurementUnitLength = "IMPERIAL_YARD"
	MeasurementUnitLengthImperialMile     MeasurementUnitLength = "IMPERIAL_MILE"
	MeasurementUnitLengthMetricMillimeter MeasurementUnitLength = "METRIC_MILLIMETER"
	MeasurementUnitLengthMetricCentimeter MeasurementUnitLength = "METRIC_CENTIMETER"
	MeasurementUnitLengthMetricMeter      MeasurementUnitLength = "METRIC_METER"
	MeasurementUnitLengthMetricKilometer  MeasurementUnitLength = "METRIC_KILOMETER"
)

func NewMeasurementUnitLengthFromString(s string) (MeasurementUnitLength, error) {
	switch s {
	case "INVALID_LENGTH":
		return MeasurementUnitLengthInvalidLength, nil
	case "IMPERIAL_INCH":
		return MeasurementUnitLengthImperialInch, nil
	case "IMPERIAL_FOOT":
		return MeasurementUnitLengthImperialFoot, nil
	case "IMPERIAL_YARD":
		return MeasurementUnitLengthImperialYard, nil
	case "IMPERIAL_MILE":
		return MeasurementUnitLengthImperialMile, nil
	case "METRIC_MILLIMETER":
		return MeasurementUnitLengthMetricMillimeter, nil
	case "METRIC_CENTIMETER":
		return MeasurementUnitLengthMetricCentimeter, nil
	case "METRIC_METER":
		return MeasurementUnitLengthMetricMeter, nil
	case "METRIC_KILOMETER":
		return MeasurementUnitLengthMetricKilometer, nil
	}
	var t MeasurementUnitLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitLength) Ptr() *MeasurementUnitLength {
	return &m
}

// Unit of time used to measure a quantity (a duration).
type MeasurementUnitTime string

const (
	MeasurementUnitTimeInvalidTime        MeasurementUnitTime = "INVALID_TIME"
	MeasurementUnitTimeGenericMillisecond MeasurementUnitTime = "GENERIC_MILLISECOND"
	MeasurementUnitTimeGenericSecond      MeasurementUnitTime = "GENERIC_SECOND"
	MeasurementUnitTimeGenericMinute      MeasurementUnitTime = "GENERIC_MINUTE"
	MeasurementUnitTimeGenericHour        MeasurementUnitTime = "GENERIC_HOUR"
	MeasurementUnitTimeGenericDay         MeasurementUnitTime = "GENERIC_DAY"
)

func NewMeasurementUnitTimeFromString(s string) (MeasurementUnitTime, error) {
	switch s {
	case "INVALID_TIME":
		return MeasurementUnitTimeInvalidTime, nil
	case "GENERIC_MILLISECOND":
		return MeasurementUnitTimeGenericMillisecond, nil
	case "GENERIC_SECOND":
		return MeasurementUnitTimeGenericSecond, nil
	case "GENERIC_MINUTE":
		return MeasurementUnitTimeGenericMinute, nil
	case "GENERIC_HOUR":
		return MeasurementUnitTimeGenericHour, nil
	case "GENERIC_DAY":
		return MeasurementUnitTimeGenericDay, nil
	}
	var t MeasurementUnitTime
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitTime) Ptr() *MeasurementUnitTime {
	return &m
}

// Describes the type of this unit and indicates which field contains the unit information. This is an ‘open’ enum.
type MeasurementUnitUnitType string

const (
	MeasurementUnitUnitTypeInvalidType MeasurementUnitUnitType = "INVALID_TYPE"
	MeasurementUnitUnitTypeTypeCustom  MeasurementUnitUnitType = "TYPE_CUSTOM"
	MeasurementUnitUnitTypeTypeArea    MeasurementUnitUnitType = "TYPE_AREA"
	MeasurementUnitUnitTypeTypeLength  MeasurementUnitUnitType = "TYPE_LENGTH"
	MeasurementUnitUnitTypeTypeVolume  MeasurementUnitUnitType = "TYPE_VOLUME"
	MeasurementUnitUnitTypeTypeWeight  MeasurementUnitUnitType = "TYPE_WEIGHT"
	MeasurementUnitUnitTypeTypeTime    MeasurementUnitUnitType = "TYPE_TIME"
	MeasurementUnitUnitTypeTypeGeneric MeasurementUnitUnitType = "TYPE_GENERIC"
)

func NewMeasurementUnitUnitTypeFromString(s string) (MeasurementUnitUnitType, error) {
	switch s {
	case "INVALID_TYPE":
		return MeasurementUnitUnitTypeInvalidType, nil
	case "TYPE_CUSTOM":
		return MeasurementUnitUnitTypeTypeCustom, nil
	case "TYPE_AREA":
		return MeasurementUnitUnitTypeTypeArea, nil
	case "TYPE_LENGTH":
		return MeasurementUnitUnitTypeTypeLength, nil
	case "TYPE_VOLUME":
		return MeasurementUnitUnitTypeTypeVolume, nil
	case "TYPE_WEIGHT":
		return MeasurementUnitUnitTypeTypeWeight, nil
	case "TYPE_TIME":
		return MeasurementUnitUnitTypeTypeTime, nil
	case "TYPE_GENERIC":
		return MeasurementUnitUnitTypeTypeGeneric, nil
	}
	var t MeasurementUnitUnitType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitUnitType) Ptr() *MeasurementUnitUnitType {
	return &m
}

// The unit of volume used to measure a quantity.
type MeasurementUnitVolume string

const (
	MeasurementUnitVolumeInvalidVolume     MeasurementUnitVolume = "INVALID_VOLUME"
	MeasurementUnitVolumeGenericFluidOunce MeasurementUnitVolume = "GENERIC_FLUID_OUNCE"
	MeasurementUnitVolumeGenericShot       MeasurementUnitVolume = "GENERIC_SHOT"
	MeasurementUnitVolumeGenericCup        MeasurementUnitVolume = "GENERIC_CUP"
	MeasurementUnitVolumeGenericPint       MeasurementUnitVolume = "GENERIC_PINT"
	MeasurementUnitVolumeGenericQuart      MeasurementUnitVolume = "GENERIC_QUART"
	MeasurementUnitVolumeGenericGallon     MeasurementUnitVolume = "GENERIC_GALLON"
	MeasurementUnitVolumeImperialCubicInch MeasurementUnitVolume = "IMPERIAL_CUBIC_INCH"
	MeasurementUnitVolumeImperialCubicFoot MeasurementUnitVolume = "IMPERIAL_CUBIC_FOOT"
	MeasurementUnitVolumeImperialCubicYard MeasurementUnitVolume = "IMPERIAL_CUBIC_YARD"
	MeasurementUnitVolumeMetricMilliliter  MeasurementUnitVolume = "METRIC_MILLILITER"
	MeasurementUnitVolumeMetricLiter       MeasurementUnitVolume = "METRIC_LITER"
)

func NewMeasurementUnitVolumeFromString(s string) (MeasurementUnitVolume, error) {
	switch s {
	case "INVALID_VOLUME":
		return MeasurementUnitVolumeInvalidVolume, nil
	case "GENERIC_FLUID_OUNCE":
		return MeasurementUnitVolumeGenericFluidOunce, nil
	case "GENERIC_SHOT":
		return MeasurementUnitVolumeGenericShot, nil
	case "GENERIC_CUP":
		return MeasurementUnitVolumeGenericCup, nil
	case "GENERIC_PINT":
		return MeasurementUnitVolumeGenericPint, nil
	case "GENERIC_QUART":
		return MeasurementUnitVolumeGenericQuart, nil
	case "GENERIC_GALLON":
		return MeasurementUnitVolumeGenericGallon, nil
	case "IMPERIAL_CUBIC_INCH":
		return MeasurementUnitVolumeImperialCubicInch, nil
	case "IMPERIAL_CUBIC_FOOT":
		return MeasurementUnitVolumeImperialCubicFoot, nil
	case "IMPERIAL_CUBIC_YARD":
		return MeasurementUnitVolumeImperialCubicYard, nil
	case "METRIC_MILLILITER":
		return MeasurementUnitVolumeMetricMilliliter, nil
	case "METRIC_LITER":
		return MeasurementUnitVolumeMetricLiter, nil
	}
	var t MeasurementUnitVolume
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitVolume) Ptr() *MeasurementUnitVolume {
	return &m
}

// Unit of weight used to measure a quantity.
type MeasurementUnitWeight string

const (
	MeasurementUnitWeightInvalidWeight       MeasurementUnitWeight = "INVALID_WEIGHT"
	MeasurementUnitWeightImperialWeightOunce MeasurementUnitWeight = "IMPERIAL_WEIGHT_OUNCE"
	MeasurementUnitWeightImperialPound       MeasurementUnitWeight = "IMPERIAL_POUND"
	MeasurementUnitWeightImperialStone       MeasurementUnitWeight = "IMPERIAL_STONE"
	MeasurementUnitWeightMetricMilligram     MeasurementUnitWeight = "METRIC_MILLIGRAM"
	MeasurementUnitWeightMetricGram          MeasurementUnitWeight = "METRIC_GRAM"
	MeasurementUnitWeightMetricKilogram      MeasurementUnitWeight = "METRIC_KILOGRAM"
)

func NewMeasurementUnitWeightFromString(s string) (MeasurementUnitWeight, error) {
	switch s {
	case "INVALID_WEIGHT":
		return MeasurementUnitWeightInvalidWeight, nil
	case "IMPERIAL_WEIGHT_OUNCE":
		return MeasurementUnitWeightImperialWeightOunce, nil
	case "IMPERIAL_POUND":
		return MeasurementUnitWeightImperialPound, nil
	case "IMPERIAL_STONE":
		return MeasurementUnitWeightImperialStone, nil
	case "METRIC_MILLIGRAM":
		return MeasurementUnitWeightMetricMilligram, nil
	case "METRIC_GRAM":
		return MeasurementUnitWeightMetricGram, nil
	case "METRIC_KILOGRAM":
		return MeasurementUnitWeightMetricKilogram, nil
	}
	var t MeasurementUnitWeight
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MeasurementUnitWeight) Ptr() *MeasurementUnitWeight {
	return &m
}

// Represents a business that sells with Square.
type Merchant struct {
	// The Square-issued ID of the merchant.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The name of the merchant's overall business.
	BusinessName *string `json:"business_name,omitempty" url:"business_name,omitempty"`
	Country      Country `json:"country" url:"country"`
	// The code indicating the [language preferences](https://developer.squareup.com/docs/build-basics/general-considerations/language-preferences) of the merchant, in [BCP 47 format](https://tools.ietf.org/html/bcp47#appendix-A). For example, `en-US` or `fr-CA`.
	LanguageCode *string         `json:"language_code,omitempty" url:"language_code,omitempty"`
	Currency     *Currency       `json:"currency,omitempty" url:"currency,omitempty"`
	Status       *MerchantStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the [main `Location`](https://developer.squareup.com/docs/locations-api#about-the-main-location) for this merchant.
	MainLocationId *string `json:"main_location_id,omitempty" url:"main_location_id,omitempty"`
	// The time when the merchant was created, in RFC 3339 format.
	// For more information, see [Working with Dates](https://developer.squareup.com/docs/build-basics/working-with-dates).
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Merchant) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Merchant) UnmarshalJSON(data []byte) error {
	type unmarshaler Merchant
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Merchant(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Merchant) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MerchantStatus string

const (
	MerchantStatusActive   MerchantStatus = "ACTIVE"
	MerchantStatusInactive MerchantStatus = "INACTIVE"
)

func NewMerchantStatusFromString(s string) (MerchantStatus, error) {
	switch s {
	case "ACTIVE":
		return MerchantStatusActive, nil
	case "INACTIVE":
		return MerchantStatusInactive, nil
	}
	var t MerchantStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MerchantStatus) Ptr() *MerchantStatus {
	return &m
}

// Represents an amount of money. `Money` fields can be signed or unsigned.
// Fields that do not explicitly define whether they are signed or unsigned are
// considered unsigned and can only hold positive amounts. For signed fields, the
// sign of the value indicates the purpose of the money transfer. See
// [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
// for more information.
type Money struct {
	// The amount of money, in the smallest denomination of the currency
	// indicated by `currency`. For example, when `currency` is `USD`, `amount` is
	// in cents. Monetary amounts can be positive or negative. See the specific
	// field description to determine the meaning of the sign in a particular case.
	Amount   *int64    `json:"amount,omitempty" url:"amount,omitempty"`
	Currency *Currency `json:"currency,omitempty" url:"currency,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Money) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Money) UnmarshalJSON(data []byte) error {
	type unmarshaler Money
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Money(value)

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Money) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type OauthScope string

const (
	// **HTTP Method**: `GET`
	//
	// Grants read access to bank account information associated with the targeted
	// Square account. For example, to call the Connect v1 ListBankAccounts endpoint.
	OauthScopeBankAccountsRead OauthScope = "BANK_ACCOUNTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to cash drawer shift information. For example, to call the
	// ListCashDrawerShifts endpoint.
	OauthScopeCashDrawerRead OauthScope = "CASH_DRAWER_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to customer information. For example, to call the
	// ListCustomers endpoint.
	OauthScopeCustomersRead OauthScope = "CUSTOMERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to customer information. For example, to create and update
	// customer profiles.
	OauthScopeCustomersWrite OauthScope = "CUSTOMERS_WRITE"
	// **HTTP Method**: `POST`, `GET`
	//
	// Grants read/write access to device credentials information. For example, to
	// call the CreateDeviceCode endpoint.
	OauthScopeDeviceCredentialManagement OauthScope = "DEVICE_CREDENTIAL_MANAGEMENT"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee profile information. For example, to call the
	// Connect v1 Employees API.
	OauthScopeEmployeesRead OauthScope = "EMPLOYEES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee profile information. For example, to create
	// and modify employee profiles.
	OauthScopeEmployeesWrite OauthScope = "EMPLOYEES_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to inventory information. For example, to call the
	// RetrieveInventoryCount endpoint.
	OauthScopeInventoryRead OauthScope = "INVENTORY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to inventory information. For example, to call the
	// BatchChangeInventory endpoint.
	OauthScopeInventoryWrite OauthScope = "INVENTORY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeItemsRead OauthScope = "ITEMS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to product catalog information. For example, to modify or
	// add to a product catalog.
	OauthScopeItemsWrite OauthScope = "ITEMS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to loyalty information. For example, to call the
	// ListLoyaltyPrograms endpoint.
	OauthScopeLoyaltyRead OauthScope = "LOYALTY_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to loyalty information. For example, to call the
	// CreateLoyaltyAccount endpoint.
	OauthScopeLoyaltyWrite OauthScope = "LOYALTY_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to business and location information. For example, to
	// obtain a location ID for subsequent activity.
	OauthScopeMerchantProfileRead OauthScope = "MERCHANT_PROFILE_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to order information. For example, to call the
	// BatchRetrieveOrders endpoint.
	OauthScopeOrdersRead OauthScope = "ORDERS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to order information. For example, to call the
	// CreateCheckout endpoint.
	OauthScopeOrdersWrite OauthScope = "ORDERS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to transaction and refund information. For example, to call
	// the RetrieveTransaction endpoint.
	OauthScopePaymentsRead OauthScope = "PAYMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to transaction and refunds information. For example, to
	// process payments with the Payments or Checkout API.
	OauthScopePaymentsWrite OauthScope = "PAYMENTS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allow third party applications to deduct a portion of each transaction amount.
	// **Required** to use multiparty transaction functionality with the Payments
	// API.
	OauthScopePaymentsWriteAdditionalRecipients OauthScope = "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to payments and refunds information. For example, to
	// process in-person payments.
	OauthScopePaymentsWriteInPerson OauthScope = "PAYMENTS_WRITE_IN_PERSON"
	// **HTTP Method**: `GET`
	//
	// Grants read access to settlement (deposit) information. For example, to call
	// the Connect v1 ListSettlements endpoint.
	OauthScopeSettlementsRead OauthScope = "SETTLEMENTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard information. For example, to call the
	// Connect v2 SearchShifts endpoint.
	OauthScopeTimecardsRead OauthScope = "TIMECARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee shift information. For example, to create
	// and modify employee shifts.
	OauthScopeTimecardsWrite OauthScope = "TIMECARDS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to employee timecard settings information. For example, to
	// call the GetBreakType endpoint.
	OauthScopeTimecardsSettingsRead OauthScope = "TIMECARDS_SETTINGS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to employee timecard settings information. For example, to
	// call the UpdateBreakType endpoint.
	OauthScopeTimecardsSettingsWrite OauthScope = "TIMECARDS_SETTINGS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to booking information. For example, to call the
	// RetrieveBooking endpoint.
	OauthScopeAppointmentsRead OauthScope = "APPOINTMENTS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to booking information. For example, to call the CreateBooking endpoint.
	OauthScopeAppointmentsWrite OauthScope = "APPOINTMENTS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to booking business settings. For example, to call the
	// ListTeamMemberBookingProfiles endpoint.
	OauthScopeAppointmentsBusinessSettingsRead OauthScope = "APPOINTMENTS_BUSINESS_SETTINGS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to invoice information. For example, to call the ListInvoices endpoint.
	OauthScopeInvoicesRead OauthScope = "INVOICES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to invoice information. For example, to call the CreateInvoice endpoint.
	OauthScopeInvoicesWrite OauthScope = "INVOICES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to subscription information. For example, to call the RetrieveSubscription
	// endpoint.
	OauthScopeSubscriptionsRead OauthScope = "SUBSCRIPTIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to subscription information. For example, to call the CreateSubscription
	// endpoint.
	OauthScopeSubscriptionsWrite OauthScope = "SUBSCRIPTIONS_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to dispute information. For example, to call the RetrieveDispute
	// endpoint.
	OauthScopeDisputesRead OauthScope = "DISPUTES_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to dispute information. For example, to call the SubmitEvidence
	// endpoint.
	OauthScopeDisputesWrite OauthScope = "DISPUTES_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to gift card information. For example, to call the RetrieveGiftCard
	// endpoint.
	OauthScopeGiftcardsRead OauthScope = "GIFTCARDS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to gift card information. For example, to call the CreateGiftCard
	// endpoint.
	OauthScopeGiftcardsWrite OauthScope = "GIFTCARDS_WRITE"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Write access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsWrite OauthScope = "ONLINE_STORE_SNIPPETS_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store snippets on published websites.
	OauthScopeOnlineStoreSnippetsRead OauthScope = "ONLINE_STORE_SNIPPETS_READ"
	// **HTTP Method**: `GET`, `POST`
	//
	// Read access to ECOM online store site details.
	OauthScopeOnlineStoreSiteRead OauthScope = "ONLINE_STORE_SITE_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Allows the developer to process payments on behalf of a seller using a shared on file payment method.
	OauthScopePaymentsWriteSharedOnfile OauthScope = "PAYMENTS_WRITE_SHARED_ONFILE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to all of a seller's booking information, calendar, and business details.
	// This permission must be accompanied by the `APPOINTMENTS_READ` permission.
	OauthScopeAppointmentsAllRead OauthScope = "APPOINTMENTS_ALL_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to all booking details, including double-booking a seller.
	// This permission must be accompanied by the `APPOINTMENTS_WRITE` permission.
	OauthScopeAppointmentsAllWrite OauthScope = "APPOINTMENTS_ALL_WRITE"
	// **HTTP Method**: `POST`, `PUT`
	//
	// Grants write access to business and location information. For example, to create a new location or
	// update the business hours at an existing location.
	OauthScopeMerchantProfileWrite OauthScope = "MERCHANT_PROFILE_WRITE"
	// **HTTP Method**: `GET`, `POST`
	//
	// Grants read access to vendor information, for example, when calling the
	// `RetrieveVendor` endpoint.
	OauthScopeVendorRead OauthScope = "VENDOR_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to vendor information, for example, when calling the
	// `BulkUpdateVendors` endpoint.
	OauthScopeVendorWrite OauthScope = "VENDOR_WRITE"
	// **HTTP Method**: `GET`
	//
	// Grants read access to payouts and payout entries information. For example,
	// to call the Connect v2 `ListPayouts` endpoint.
	OauthScopePayoutsRead OauthScope = "PAYOUTS_READ"
	// **HTTP Method**: `GET`
	//
	// Grants read access to reservation information, for example, when calling the
	// `RetrieveReservation` endpoint.
	OauthScopeReservationsRead OauthScope = "RESERVATIONS_READ"
	// **HTTP Method**: `POST`, `PUT`, `DELETE`
	//
	// Grants write access to reservation information, for example, when calling the
	// `CreateReservation` endpoint.
	OauthScopeReservationsWrite OauthScope = "RESERVATIONS_WRITE"
)

func NewOauthScopeFromString(s string) (OauthScope, error) {
	switch s {
	case "BANK_ACCOUNTS_READ":
		return OauthScopeBankAccountsRead, nil
	case "CASH_DRAWER_READ":
		return OauthScopeCashDrawerRead, nil
	case "CUSTOMERS_READ":
		return OauthScopeCustomersRead, nil
	case "CUSTOMERS_WRITE":
		return OauthScopeCustomersWrite, nil
	case "DEVICE_CREDENTIAL_MANAGEMENT":
		return OauthScopeDeviceCredentialManagement, nil
	case "EMPLOYEES_READ":
		return OauthScopeEmployeesRead, nil
	case "EMPLOYEES_WRITE":
		return OauthScopeEmployeesWrite, nil
	case "INVENTORY_READ":
		return OauthScopeInventoryRead, nil
	case "INVENTORY_WRITE":
		return OauthScopeInventoryWrite, nil
	case "ITEMS_READ":
		return OauthScopeItemsRead, nil
	case "ITEMS_WRITE":
		return OauthScopeItemsWrite, nil
	case "LOYALTY_READ":
		return OauthScopeLoyaltyRead, nil
	case "LOYALTY_WRITE":
		return OauthScopeLoyaltyWrite, nil
	case "MERCHANT_PROFILE_READ":
		return OauthScopeMerchantProfileRead, nil
	case "ORDERS_READ":
		return OauthScopeOrdersRead, nil
	case "ORDERS_WRITE":
		return OauthScopeOrdersWrite, nil
	case "PAYMENTS_READ":
		return OauthScopePaymentsRead, nil
	case "PAYMENTS_WRITE":
		return OauthScopePaymentsWrite, nil
	case "PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS":
		return OauthScopePaymentsWriteAdditionalRecipients, nil
	case "PAYMENTS_WRITE_IN_PERSON":
		return OauthScopePaymentsWriteInPerson, nil
	case "SETTLEMENTS_READ":
		return OauthScopeSettlementsRead, nil
	case "TIMECARDS_READ":
		return OauthScopeTimecardsRead, nil
	case "TIMECARDS_WRITE":
		return OauthScopeTimecardsWrite, nil
	case "TIMECARDS_SETTINGS_READ":
		return OauthScopeTimecardsSettingsRead, nil
	case "TIMECARDS_SETTINGS_WRITE":
		return OauthScopeTimecardsSettingsWrite, nil
	case "APPOINTMENTS_READ":
		return OauthScopeAppointmentsRead, nil
	case "APPOINTMENTS_WRITE":
		return OauthScopeAppointmentsWrite, nil
	case "APPOINTMENTS_BUSINESS_SETTINGS_READ":
		return OauthScopeAppointmentsBusinessSettingsRead, nil
	case "INVOICES_READ":
		return OauthScopeInvoicesRead, nil
	case "INVOICES_WRITE":
		return OauthScopeInvoicesWrite, nil
	case "SUBSCRIPTIONS_READ":
		return OauthScopeSubscriptionsRead, nil
	case "SUBSCRIPTIONS_WRITE":
		return OauthScopeSubscriptionsWrite, nil
	case "DISPUTES_READ":
		return OauthScopeDisputesRead, nil
	case "DISPUTES_WRITE":
		return OauthScopeDisputesWrite, nil
	case "GIFTCARDS_READ":
		return OauthScopeGiftcardsRead, nil
	case "GIFTCARDS_WRITE":
		return OauthScopeGiftcardsWrite, nil
	case "ONLINE_STORE_SNIPPETS_WRITE":
		return OauthScopeOnlineStoreSnippetsWrite, nil
	case "ONLINE_STORE_SNIPPETS_READ":
		return OauthScopeOnlineStoreSnippetsRead, nil
	case "ONLINE_STORE_SITE_READ":
		return OauthScopeOnlineStoreSiteRead, nil
	case "PAYMENTS_WRITE_SHARED_ONFILE":
		return OauthScopePaymentsWriteSharedOnfile, nil
	case "APPOINTMENTS_ALL_READ":
		return OauthScopeAppointmentsAllRead, nil
	case "APPOINTMENTS_ALL_WRITE":
		return OauthScopeAppointmentsAllWrite, nil
	case "MERCHANT_PROFILE_WRITE":
		return OauthScopeMerchantProfileWrite, nil
	case "VENDOR_READ":
		return OauthScopeVendorRead, nil
	case "VENDOR_WRITE":
		return OauthScopeVendorWrite, nil
	case "PAYOUTS_READ":
		return OauthScopePayoutsRead, nil
	case "RESERVATIONS_READ":
		return OauthScopeReservationsRead, nil
	case "RESERVATIONS_WRITE":
		return OauthScopeReservationsWrite, nil
	}
	var t OauthScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OauthScope) Ptr() *OauthScope {
	return &o
}

// Contains all information related to a single order to process with Square,
// including line items that specify the products to purchase. `Order` objects also
// include information about any associated tenders, refunds, and returns.
//
// All Connect V2 Transactions have all been converted to Orders including all associated
// itemization data.
type Order struct {
	// The order's unique ID.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The ID of the seller location that this order is associated with.
	LocationId string `json:"location_id" url:"location_id"`
	// A client-specified ID to associate an entity in another system
	// with this order.
	ReferenceId *string      `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	Source      *OrderSource `json:"source,omitempty" url:"source,omitempty"`
	// The ID of the [customer](entity:Customer) associated with the order.
	//
	// **IMPORTANT:** You should specify a `customer_id` if you want the corresponding payment transactions
	// to be explicitly linked to the customer in the Seller Dashboard. If this field is omitted, the
	// `customer_id` assigned to any underlying `Payment` objects is ignored and might result in the
	// creation of new [instant profiles](https://developer.squareup.com/docs/customers-api/what-it-does#instant-profiles).
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The line items included in the order.
	LineItems []*OrderLineItem `json:"line_items,omitempty" url:"line_items,omitempty"`
	// The list of all taxes associated with the order.
	//
	// Taxes can be scoped to either `ORDER` or `LINE_ITEM`. For taxes with `LINE_ITEM` scope, an
	// `OrderLineItemAppliedTax` must be added to each line item that the tax applies to. For taxes
	// with `ORDER` scope, the server generates an `OrderLineItemAppliedTax` for every line item.
	//
	// On reads, each tax in the list includes the total amount of that tax applied to the order.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any taxes in this field, using the deprecated
	// `line_items.taxes` field results in an error. Use `line_items.applied_taxes`
	// instead.
	Taxes []*OrderLineItemTax `json:"taxes,omitempty" url:"taxes,omitempty"`
	// The list of all discounts associated with the order.
	//
	// Discounts can be scoped to either `ORDER` or `LINE_ITEM`. For discounts scoped to `LINE_ITEM`,
	// an `OrderLineItemAppliedDiscount` must be added to each line item that the discount applies to.
	// For discounts with `ORDER` scope, the server generates an `OrderLineItemAppliedDiscount`
	// for every line item.
	//
	// **IMPORTANT**: If `LINE_ITEM` scope is set on any discounts in this field, using the deprecated
	// `line_items.discounts` field results in an error. Use `line_items.applied_discounts`
	// instead.
	Discounts []*OrderLineItemDiscount `json:"discounts,omitempty" url:"discounts,omitempty"`
	// A list of service charges applied to the order.
	ServiceCharges []*OrderServiceCharge `json:"service_charges,omitempty" url:"service_charges,omitempty"`
	// Details about order fulfillment.
	//
	// Orders can only be created with at most one fulfillment. However, orders returned
	// by the API might contain multiple fulfillments.
	Fulfillments []*OrderFulfillment `json:"fulfillments,omitempty" url:"fulfillments,omitempty"`
	// A collection of items from sale orders being returned in this one. Normally part of an
	// itemized return or exchange. There is exactly one `Return` object per sale `Order` being
	// referenced.
	Returns            []*OrderReturn           `json:"returns,omitempty" url:"returns,omitempty"`
	ReturnAmounts      *OrderMoneyAmounts       `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`
	NetAmounts         *OrderMoneyAmounts       `json:"net_amounts,omitempty" url:"net_amounts,omitempty"`
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	// The refunds that are part of this order.
	Refunds []*Refund `json:"refunds,omitempty" url:"refunds,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The timestamp for when the order was created, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp for when the order was last updated, in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// The timestamp for when the order reached a terminal [state](entity:OrderState), in RFC 3339 format (for example "2016-09-04T23:59:33.123Z").
	ClosedAt *string     `json:"closed_at,omitempty" url:"closed_at,omitempty"`
	State    *OrderState `json:"state,omitempty" url:"state,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders).
	Version                 *int   `json:"version,omitempty" url:"version,omitempty"`
	TotalMoney              *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney           *Money `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney      *Money `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalTipMoney           *Money `json:"total_tip_money,omitempty" url:"total_tip_money,omitempty"`
	TotalServiceChargeMoney *Money `json:"total_service_charge_money,omitempty" url:"total_service_charge_money,omitempty"`
	// A short-term identifier for the order (such as a customer first name,
	// table number, or auto-generated order number that resets daily).
	TicketName     *string              `json:"ticket_name,omitempty" url:"ticket_name,omitempty"`
	PricingOptions *OrderPricingOptions `json:"pricing_options,omitempty" url:"pricing_options,omitempty"`
	// A set-like list of Rewards that have been added to the Order.
	Rewards           []*OrderReward `json:"rewards,omitempty" url:"rewards,omitempty"`
	NetAmountDueMoney *Money         `json:"net_amount_due_money,omitempty" url:"net_amount_due_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *Order) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *Order) UnmarshalJSON(data []byte) error {
	type unmarshaler Order
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = Order(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *Order) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A lightweight description of an [order](entity:Order) that is returned when
// `returned_entries` is `true` on a [SearchOrdersRequest](api-endpoint:Orders-SearchOrders).
type OrderEntry struct {
	// The ID of the order.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The version number, which is incremented each time an update is committed to the order.
	// Orders that were not created through the API do not include a version number and
	// therefore cannot be updated.
	//
	// [Read more about working with versions.](https://developer.squareup.com/docs/orders-api/manage-orders#update-orders)
	Version *int `json:"version,omitempty" url:"version,omitempty"`
	// The location ID the order belongs to.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains details about how to fulfill this order.
type OrderFulfillment struct {
	// A unique ID that identifies the fulfillment only within this order.
	Uid                 *string                                         `json:"uid,omitempty" url:"uid,omitempty"`
	Type                *OrderFulfillmentType                           `json:"type,omitempty" url:"type,omitempty"`
	State               *OrderFulfillmentState                          `json:"state,omitempty" url:"state,omitempty"`
	LineItemApplication *OrderFulfillmentFulfillmentLineItemApplication `json:"line_item_application,omitempty" url:"line_item_application,omitempty"`
	// A list of entries pertaining to the fulfillment of an order. Each entry must reference
	// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
	// fulfill.
	//
	// Multiple entries can reference the same line item `uid`, as long as the total quantity among
	// all fulfillment entries referencing a single line item does not exceed the quantity of the
	// order's line item itself.
	//
	// An order cannot be marked as `COMPLETED` before all fulfillments are `COMPLETED`,
	// `CANCELED`, or `FAILED`. Fulfillments can be created and completed independently
	// before order completion.
	Entries []*OrderFulfillmentFulfillmentEntry `json:"entries,omitempty" url:"entries,omitempty"`
	// Application-defined data attached to this fulfillment. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata        map[string]string                `json:"metadata,omitempty" url:"metadata,omitempty"`
	PickupDetails   *OrderFulfillmentPickupDetails   `json:"pickup_details,omitempty" url:"pickup_details,omitempty"`
	ShipmentDetails *OrderFulfillmentShipmentDetails `json:"shipment_details,omitempty" url:"shipment_details,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Links an order line item to a fulfillment. Each entry must reference
// a valid `uid` for an order line item in the `line_item_uid` field, as well as a `quantity` to
// fulfill.
type OrderFulfillmentFulfillmentEntry struct {
	// A unique ID that identifies the fulfillment entry only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` from the order line item.
	LineItemUid string `json:"line_item_uid" url:"line_item_uid"`
	// The quantity of the line item being fulfilled, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Fulfillments for line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity string `json:"quantity" url:"quantity"`
	// Application-defined data attached to this fulfillment entry. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentFulfillmentEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentFulfillmentEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentFulfillmentEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentFulfillmentEntry(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentFulfillmentEntry) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The `line_item_application` describes what order line items this fulfillment applies
// to. It can be `ALL` or `ENTRY_LIST` with a supplied list of fulfillment entries.
type OrderFulfillmentFulfillmentLineItemApplication string

const (
	OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication OrderFulfillmentFulfillmentLineItemApplication = "UNKNOWN_APPLICATION"
	OrderFulfillmentFulfillmentLineItemApplicationAll                OrderFulfillmentFulfillmentLineItemApplication = "ALL"
	OrderFulfillmentFulfillmentLineItemApplicationEntryList          OrderFulfillmentFulfillmentLineItemApplication = "ENTRY_LIST"
)

func NewOrderFulfillmentFulfillmentLineItemApplicationFromString(s string) (OrderFulfillmentFulfillmentLineItemApplication, error) {
	switch s {
	case "UNKNOWN_APPLICATION":
		return OrderFulfillmentFulfillmentLineItemApplicationUnknownApplication, nil
	case "ALL":
		return OrderFulfillmentFulfillmentLineItemApplicationAll, nil
	case "ENTRY_LIST":
		return OrderFulfillmentFulfillmentLineItemApplicationEntryList, nil
	}
	var t OrderFulfillmentFulfillmentLineItemApplication
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentFulfillmentLineItemApplication) Ptr() *OrderFulfillmentFulfillmentLineItemApplication {
	return &o
}

// Contains details necessary to fulfill a pickup order.
type OrderFulfillmentPickupDetails struct {
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment expires if it is not accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z"). The expiration time can only be set up to 7 days in the future.
	// If `expires_at` is not set, this pickup fulfillment is automatically accepted when
	// placed.
	ExpiresAt *string `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The duration of time after which an open and accepted pickup fulfillment
	// is automatically moved to the `COMPLETED` state. The duration must be in RFC 3339
	// format (for example, "P1W3D").
	//
	// If not set, this pickup fulfillment remains accepted until it is canceled or completed.
	AutoCompleteDuration *string `json:"auto_complete_duration,omitempty" url:"auto_complete_duration,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// that represents the start of the pickup window. Must be in RFC 3339 timestamp format, e.g.,
	// "2016-09-04T23:59:33.123Z".
	//
	// For fulfillments with the schedule type `ASAP`, this is automatically set
	// to the current time plus the expected duration to prepare the fulfillment.
	PickupAt *string `json:"pickup_at,omitempty" url:"pickup_at,omitempty"`
	// The window of time in which the order should be picked up after the `pickup_at` timestamp.
	// Must be in RFC 3339 duration format, e.g., "P1W3D". Can be used as an
	// informational guideline for merchants.
	PickupWindowDuration *string `json:"pickup_window_duration,omitempty" url:"pickup_window_duration,omitempty"`
	// The duration of time it takes to prepare this fulfillment.
	// The duration must be in RFC 3339 format (for example, "P1W3D").
	PrepTimeDuration *string `json:"prep_time_duration,omitempty" url:"prep_time_duration,omitempty"`
	// A note to provide additional instructions about the pickup
	// fulfillment displayed in the Square Point of Sale application and set by the API.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was placed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was accepted. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	AcceptedAt *string `json:"accepted_at,omitempty" url:"accepted_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was rejected. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	RejectedAt *string `json:"rejected_at,omitempty" url:"rejected_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment is marked as ready for pickup. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ReadyAt *string `json:"ready_at,omitempty" url:"ready_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment expired. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ExpiredAt *string `json:"expired_at,omitempty" url:"expired_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was picked up by the recipient. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PickedUpAt *string `json:"picked_up_at,omitempty" url:"picked_up_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the fulfillment was canceled. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the pickup was canceled. The maximum length: 100 characters.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// If set to `true`, indicates that this pickup order is for curbside pickup, not in-store pickup.
	IsCurbsidePickup *bool `json:"is_curbside_pickup,omitempty" url:"is_curbside_pickup,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentPickupDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentPickupDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentPickupDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentPickupDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentPickupDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Information about the fulfillment recipient.
type OrderFulfillmentRecipient struct {
	// The ID of the customer associated with the fulfillment.
	//
	// If `customer_id` is provided, the fulfillment recipient's `display_name`,
	// `email_address`, and `phone_number` are automatically populated from the
	// targeted customer profile. If these fields are set in the request, the request
	// values override the information from the customer profile. If the
	// targeted customer profile does not contain the necessary information and
	// these fields are left unset, the request results in an error.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// The display name of the fulfillment recipient. This field is required.
	//
	// If provided, the display name overrides the corresponding customer profile value
	// indicated by `customer_id`.
	DisplayName *string `json:"display_name,omitempty" url:"display_name,omitempty"`
	// The email address of the fulfillment recipient.
	//
	// If provided, the email address overrides the corresponding customer profile value
	// indicated by `customer_id`.
	EmailAddress *string `json:"email_address,omitempty" url:"email_address,omitempty"`
	// The phone number of the fulfillment recipient. This field is required.
	//
	// If provided, the phone number overrides the corresponding customer profile value
	// indicated by `customer_id`.
	PhoneNumber *string  `json:"phone_number,omitempty" url:"phone_number,omitempty"`
	Address     *Address `json:"address,omitempty" url:"address,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentRecipient) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentRecipient) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentRecipient
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentRecipient(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentRecipient) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the details necessary to fulfill a shipment order.
type OrderFulfillmentShipmentDetails struct {
	Recipient *OrderFulfillmentRecipient `json:"recipient,omitempty" url:"recipient,omitempty"`
	// The shipping carrier being used to ship this fulfillment (such as UPS, FedEx, or USPS).
	Carrier *string `json:"carrier,omitempty" url:"carrier,omitempty"`
	// A note with additional information for the shipping carrier.
	ShippingNote *string `json:"shipping_note,omitempty" url:"shipping_note,omitempty"`
	// A description of the type of shipping product purchased from the carrier
	// (such as First Class, Priority, or Express).
	ShippingType *string `json:"shipping_type,omitempty" url:"shipping_type,omitempty"`
	// The reference number provided by the carrier to track the shipment's progress.
	TrackingNumber *string `json:"tracking_number,omitempty" url:"tracking_number,omitempty"`
	// A link to the tracking webpage on the carrier's website.
	TrackingUrl *string `json:"tracking_url,omitempty" url:"tracking_url,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment was requested. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	PlacedAt *string `json:"placed_at,omitempty" url:"placed_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `RESERVED` state, which indicates that preparation
	// of this shipment has begun. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	InProgressAt *string `json:"in_progress_at,omitempty" url:"in_progress_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `PREPARED` state, which indicates that the
	// fulfillment is packaged. The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	PackagedAt *string `json:"packaged_at,omitempty" url:"packaged_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment is expected to be delivered to the shipping carrier.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	ExpectedShippedAt *string `json:"expected_shipped_at,omitempty" url:"expected_shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when this fulfillment was moved to the `COMPLETED` state, which indicates that
	// the fulfillment has been given to the shipping carrier. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	ShippedAt *string `json:"shipped_at,omitempty" url:"shipped_at,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating the shipment was canceled.
	// The timestamp must be in RFC 3339 format (for example, "2016-09-04T23:59:33.123Z").
	CanceledAt *string `json:"canceled_at,omitempty" url:"canceled_at,omitempty"`
	// A description of why the shipment was canceled.
	CancelReason *string `json:"cancel_reason,omitempty" url:"cancel_reason,omitempty"`
	// The [timestamp](https://developer.squareup.com/docs/build-basics/working-with-dates)
	// indicating when the shipment failed to be completed. The timestamp must be in RFC 3339 format
	// (for example, "2016-09-04T23:59:33.123Z").
	FailedAt *string `json:"failed_at,omitempty" url:"failed_at,omitempty"`
	// A description of why the shipment failed to be completed.
	FailureReason *string `json:"failure_reason,omitempty" url:"failure_reason,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderFulfillmentShipmentDetails) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderFulfillmentShipmentDetails) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderFulfillmentShipmentDetails
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderFulfillmentShipmentDetails(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderFulfillmentShipmentDetails) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The current state of this fulfillment.
type OrderFulfillmentState string

const (
	OrderFulfillmentStateFulfillmentStateDoNotUse OrderFulfillmentState = "FULFILLMENT_STATE_DO_NOT_USE"
	OrderFulfillmentStateProposed                 OrderFulfillmentState = "PROPOSED"
	OrderFulfillmentStateReserved                 OrderFulfillmentState = "RESERVED"
	OrderFulfillmentStatePrepared                 OrderFulfillmentState = "PREPARED"
	OrderFulfillmentStateCompleted                OrderFulfillmentState = "COMPLETED"
	OrderFulfillmentStateCanceled                 OrderFulfillmentState = "CANCELED"
	OrderFulfillmentStateFailed                   OrderFulfillmentState = "FAILED"
)

func NewOrderFulfillmentStateFromString(s string) (OrderFulfillmentState, error) {
	switch s {
	case "FULFILLMENT_STATE_DO_NOT_USE":
		return OrderFulfillmentStateFulfillmentStateDoNotUse, nil
	case "PROPOSED":
		return OrderFulfillmentStateProposed, nil
	case "RESERVED":
		return OrderFulfillmentStateReserved, nil
	case "PREPARED":
		return OrderFulfillmentStatePrepared, nil
	case "COMPLETED":
		return OrderFulfillmentStateCompleted, nil
	case "CANCELED":
		return OrderFulfillmentStateCanceled, nil
	case "FAILED":
		return OrderFulfillmentStateFailed, nil
	}
	var t OrderFulfillmentState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentState) Ptr() *OrderFulfillmentState {
	return &o
}

// The type of fulfillment.
type OrderFulfillmentType string

const (
	OrderFulfillmentTypeFulfillmentTypeDoNotUse OrderFulfillmentType = "FULFILLMENT_TYPE_DO_NOT_USE"
	OrderFulfillmentTypeCustom                  OrderFulfillmentType = "CUSTOM"
	OrderFulfillmentTypePickup                  OrderFulfillmentType = "PICKUP"
	OrderFulfillmentTypeManagedDelivery         OrderFulfillmentType = "MANAGED_DELIVERY"
	OrderFulfillmentTypeShipment                OrderFulfillmentType = "SHIPMENT"
	OrderFulfillmentTypeDigital                 OrderFulfillmentType = "DIGITAL"
	OrderFulfillmentTypeDelivery                OrderFulfillmentType = "DELIVERY"
	OrderFulfillmentTypeSimple                  OrderFulfillmentType = "SIMPLE"
)

func NewOrderFulfillmentTypeFromString(s string) (OrderFulfillmentType, error) {
	switch s {
	case "FULFILLMENT_TYPE_DO_NOT_USE":
		return OrderFulfillmentTypeFulfillmentTypeDoNotUse, nil
	case "CUSTOM":
		return OrderFulfillmentTypeCustom, nil
	case "PICKUP":
		return OrderFulfillmentTypePickup, nil
	case "MANAGED_DELIVERY":
		return OrderFulfillmentTypeManagedDelivery, nil
	case "SHIPMENT":
		return OrderFulfillmentTypeShipment, nil
	case "DIGITAL":
		return OrderFulfillmentTypeDigital, nil
	case "DELIVERY":
		return OrderFulfillmentTypeDelivery, nil
	case "SIMPLE":
		return OrderFulfillmentTypeSimple, nil
	}
	var t OrderFulfillmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderFulfillmentType) Ptr() *OrderFulfillmentType {
	return &o
}

// Represents a line item in an order. Each line item describes a different
// product to purchase, with its own quantity and price details.
type OrderLineItem struct {
	// A unique ID that identifies the line item only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity purchased, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a quantity of `"0"` are automatically removed
	// when paying for or otherwise completing the order.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity     string             `json:"quantity" url:"quantity"`
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this line item.
	VariationName *string                `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	ItemType      *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// Application-defined data attached to this line item. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	Modifiers []*OrderLineItemModifier `json:"modifiers,omitempty" url:"modifiers,omitempty"`
	// The list of references to taxes applied to this line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a
	// top-level `OrderLineItemTax` applied to the line item. On reads, the
	// amount applied is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every line
	// item for all `ORDER` scoped taxes added to the order. `OrderLineItemAppliedTax`
	// records for `LINE_ITEM` scoped taxes must be added in requests for the tax
	// to apply to any line items.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to discounts applied to this line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderLineItemDiscounts` applied to the line item. On reads, the amount
	// applied is populated.
	//
	// An `OrderLineItemAppliedDiscount` is automatically created on every line item for all
	// `ORDER` scoped discounts that are added to the order. `OrderLineItemAppliedDiscount` records
	// for `LINE_ITEM` scoped discounts must be added in requests for the discount to apply to any
	// line items.
	//
	// To change the amount of a discount, modify the referenced top-level discount.
	AppliedDiscounts         []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	BasePriceMoney           *Money                          `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	VariationTotalPriceMoney *Money                          `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	GrossSalesMoney          *Money                          `json:"gross_sales_money,omitempty" url:"gross_sales_money,omitempty"`
	TotalTaxMoney            *Money                          `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney       *Money                          `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalMoney               *Money                          `json:"total_money,omitempty" url:"total_money,omitempty"`
	PricingBlocklists        *OrderLineItemPricingBlocklists `json:"pricing_blocklists,omitempty" url:"pricing_blocklists,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a discount to a line item in an order.
//
// Order scoped discounts have automatically applied discounts present for each line item.
// Line-item scoped discounts must have applied discounts added manually for any applicable line
// items. The corresponding applied money is automatically computed based on participating
// line items.
type OrderLineItemAppliedDiscount struct {
	// A unique ID that identifies the applied discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that the applied discount represents. It must
	// reference a discount present in the `order.discounts` field.
	//
	// This field is immutable. To change which discounts apply to a line item,
	// you must delete the discount and re-add it as a new `OrderLineItemAppliedDiscount`.
	DiscountUid  string `json:"discount_uid" url:"discount_uid"`
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents an applied portion of a tax to a line item in an order.
//
// Order-scoped taxes automatically include the applied taxes in each line item.
// Line item taxes must be referenced from any applicable line items.
// The corresponding applied money is automatically computed, based on the
// set of participating line items.
type OrderLineItemAppliedTax struct {
	// A unique ID that identifies the applied tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax for which this applied tax represents. It must reference
	// a tax present in the `order.taxes` field.
	//
	// This field is immutable. To change which taxes apply to a line item, delete and add a new
	// `OrderLineItemAppliedTax`.
	TaxUid       string `json:"tax_uid" url:"tax_uid"`
	AppliedMoney *Money `json:"applied_money,omitempty" url:"applied_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemAppliedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemAppliedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemAppliedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemAppliedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemAppliedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount that applies to one or more line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the
// amount contributed by the item to the order subtotal.
type OrderLineItemDiscount struct {
	// A unique ID that identifies the discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string                    `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the discount, as a string representation of a decimal number.
	// A value of `7.25` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage   *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney  *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney *Money  `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	// Application-defined data attached to this discount. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string           `json:"metadata,omitempty" url:"metadata,omitempty"`
	Scope    *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`
	// The reward IDs corresponding to this discount. The application and
	// specification of discounts that have `reward_ids` are completely controlled by the backing
	// criteria corresponding to the reward tiers of the rewards that are added to the order
	// through the Loyalty API. To manually unapply discounts that are the result of added rewards,
	// the rewards must be removed from the order through the Loyalty API.
	RewardIds []string `json:"reward_ids,omitempty" url:"reward_ids,omitempty"`
	// The object ID of a [pricing rule](entity:CatalogPricingRule) to be applied
	// automatically to this discount. The specification and application of the discounts, to
	// which a `pricing_rule_id` is assigned, are completely controlled by the corresponding
	// pricing rule.
	PricingRuleId *string `json:"pricing_rule_id,omitempty" url:"pricing_rule_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level discount.
type OrderLineItemDiscountScope string

const (
	OrderLineItemDiscountScopeOtherDiscountScope OrderLineItemDiscountScope = "OTHER_DISCOUNT_SCOPE"
	OrderLineItemDiscountScopeLineItem           OrderLineItemDiscountScope = "LINE_ITEM"
	OrderLineItemDiscountScopeOrder              OrderLineItemDiscountScope = "ORDER"
)

func NewOrderLineItemDiscountScopeFromString(s string) (OrderLineItemDiscountScope, error) {
	switch s {
	case "OTHER_DISCOUNT_SCOPE":
		return OrderLineItemDiscountScopeOtherDiscountScope, nil
	case "LINE_ITEM":
		return OrderLineItemDiscountScopeLineItem, nil
	case "ORDER":
		return OrderLineItemDiscountScopeOrder, nil
	}
	var t OrderLineItemDiscountScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountScope) Ptr() *OrderLineItemDiscountScope {
	return &o
}

// Indicates how the discount is applied to the associated line item or order.
type OrderLineItemDiscountType string

const (
	OrderLineItemDiscountTypeUnknownDiscount    OrderLineItemDiscountType = "UNKNOWN_DISCOUNT"
	OrderLineItemDiscountTypeFixedPercentage    OrderLineItemDiscountType = "FIXED_PERCENTAGE"
	OrderLineItemDiscountTypeFixedAmount        OrderLineItemDiscountType = "FIXED_AMOUNT"
	OrderLineItemDiscountTypeVariablePercentage OrderLineItemDiscountType = "VARIABLE_PERCENTAGE"
	OrderLineItemDiscountTypeVariableAmount     OrderLineItemDiscountType = "VARIABLE_AMOUNT"
)

func NewOrderLineItemDiscountTypeFromString(s string) (OrderLineItemDiscountType, error) {
	switch s {
	case "UNKNOWN_DISCOUNT":
		return OrderLineItemDiscountTypeUnknownDiscount, nil
	case "FIXED_PERCENTAGE":
		return OrderLineItemDiscountTypeFixedPercentage, nil
	case "FIXED_AMOUNT":
		return OrderLineItemDiscountTypeFixedAmount, nil
	case "VARIABLE_PERCENTAGE":
		return OrderLineItemDiscountTypeVariablePercentage, nil
	case "VARIABLE_AMOUNT":
		return OrderLineItemDiscountTypeVariableAmount, nil
	}
	var t OrderLineItemDiscountType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemDiscountType) Ptr() *OrderLineItemDiscountType {
	return &o
}

// Represents the line item type.
type OrderLineItemItemType string

const (
	OrderLineItemItemTypeDoNotUse     OrderLineItemItemType = "DO_NOT_USE"
	OrderLineItemItemTypeItem         OrderLineItemItemType = "ITEM"
	OrderLineItemItemTypeCustomAmount OrderLineItemItemType = "CUSTOM_AMOUNT"
	OrderLineItemItemTypeGiftCard     OrderLineItemItemType = "GIFT_CARD"
)

func NewOrderLineItemItemTypeFromString(s string) (OrderLineItemItemType, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderLineItemItemTypeDoNotUse, nil
	case "ITEM":
		return OrderLineItemItemTypeItem, nil
	case "CUSTOM_AMOUNT":
		return OrderLineItemItemTypeCustomAmount, nil
	case "GIFT_CARD":
		return OrderLineItemItemTypeGiftCard, nil
	}
	var t OrderLineItemItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemItemType) Ptr() *OrderLineItemItemType {
	return &o
}

// A [CatalogModifier](entity:CatalogModifier).
type OrderLineItemModifier struct {
	// A unique ID that identifies the modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity of the line item modifier. The modifier quantity can be 0 or more.
	// For example, suppose a restaurant offers a cheeseburger on the menu. When a buyer orders
	// this item, the restaurant records the purchase by creating an `Order` object with a line item
	// for a burger. The line item includes a line item modifier: the name is cheese and the quantity
	// is 1. The buyer has the option to order extra cheese (or no cheese). If the buyer chooses
	// the extra cheese option, the modifier quantity increases to 2. If the buyer does not want
	// any cheese, the modifier quantity is set to 0.
	Quantity        *string `json:"quantity,omitempty" url:"quantity,omitempty"`
	BasePriceMoney  *Money  `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	TotalPriceMoney *Money  `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`
	// Application-defined data attached to this order. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Describes pricing adjustments that are blocked from manual and
// automatic application to a line item. For more information, see
// [Apply Taxes and Discounts](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts).
type OrderLineItemPricingBlocklists struct {
	// A list of discounts blocked from applying to the line item.
	// Discounts can be blocked by the `discount_uid` (for ad hoc discounts) or
	// the `discount_catalog_object_id` (for catalog discounts).
	BlockedDiscounts []*OrderLineItemPricingBlocklistsBlockedDiscount `json:"blocked_discounts,omitempty" url:"blocked_discounts,omitempty"`
	// A list of taxes blocked from applying to the line item.
	// Taxes can be blocked by the `tax_uid` (for ad hoc taxes) or
	// the `tax_catalog_object_id` (for catalog taxes).
	BlockedTaxes []*OrderLineItemPricingBlocklistsBlockedTax `json:"blocked_taxes,omitempty" url:"blocked_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklists) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklists) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklists
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklists(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklists) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A discount to block from applying to a line item. The discount must be
// identified by either `discount_uid` or `discount_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedDiscount struct {
	// A unique ID of the `BlockedDiscount` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the discount that should be blocked. Use this field to block
	// ad hoc discounts. For catalog discounts, use the `discount_catalog_object_id` field.
	DiscountUid *string `json:"discount_uid,omitempty" url:"discount_uid,omitempty"`
	// The `catalog_object_id` of the discount that should be blocked.
	// Use this field to block catalog discounts. For ad hoc discounts, use the
	// `discount_uid` field.
	DiscountCatalogObjectId *string `json:"discount_catalog_object_id,omitempty" url:"discount_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A tax to block from applying to a line item. The tax must be
// identified by either `tax_uid` or `tax_catalog_object_id`, but not both.
type OrderLineItemPricingBlocklistsBlockedTax struct {
	// A unique ID of the `BlockedTax` within the order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the tax that should be blocked. Use this field to block
	// ad hoc taxes. For catalog, taxes use the `tax_catalog_object_id` field.
	TaxUid *string `json:"tax_uid,omitempty" url:"tax_uid,omitempty"`
	// The `catalog_object_id` of the tax that should be blocked.
	// Use this field to block catalog taxes. For ad hoc taxes, use the
	// `tax_uid` field.
	TaxCatalogObjectId *string `json:"tax_catalog_object_id,omitempty" url:"tax_catalog_object_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemPricingBlocklistsBlockedTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemPricingBlocklistsBlockedTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemPricingBlocklistsBlockedTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax that applies to one or more line item in the order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero line item totals.
// The amount distributed to each line item is relative to the amount the item
// contributes to the order subtotal.
type OrderLineItemTax struct {
	// A unique ID that identifies the tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string               `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal
	// number. For example, a value of `"7.25"` corresponds to a percentage of
	// 7.25%.
	Percentage *string `json:"percentage,omitempty" url:"percentage,omitempty"`
	// Application-defined data attached to this tax. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata     map[string]string      `json:"metadata,omitempty" url:"metadata,omitempty"`
	AppliedMoney *Money                 `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`
	// Determines whether the tax was automatically applied to the order based on
	// the catalog configuration. For an example, see
	// [Automatically Apply Taxes to an Order](https://developer.squareup.com/docs/orders-api/apply-taxes-and-discounts/auto-apply-taxes).
	AutoApplied *bool `json:"auto_applied,omitempty" url:"auto_applied,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderLineItemTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderLineItemTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderLineItemTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderLineItemTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderLineItemTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Indicates whether this is a line-item or order-level tax.
type OrderLineItemTaxScope string

const (
	OrderLineItemTaxScopeOtherTaxScope OrderLineItemTaxScope = "OTHER_TAX_SCOPE"
	OrderLineItemTaxScopeLineItem      OrderLineItemTaxScope = "LINE_ITEM"
	OrderLineItemTaxScopeOrder         OrderLineItemTaxScope = "ORDER"
)

func NewOrderLineItemTaxScopeFromString(s string) (OrderLineItemTaxScope, error) {
	switch s {
	case "OTHER_TAX_SCOPE":
		return OrderLineItemTaxScopeOtherTaxScope, nil
	case "LINE_ITEM":
		return OrderLineItemTaxScopeLineItem, nil
	case "ORDER":
		return OrderLineItemTaxScopeOrder, nil
	}
	var t OrderLineItemTaxScope
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxScope) Ptr() *OrderLineItemTaxScope {
	return &o
}

// Indicates how the tax is applied to the associated line item or order.
type OrderLineItemTaxType string

const (
	OrderLineItemTaxTypeUnknownTax OrderLineItemTaxType = "UNKNOWN_TAX"
	OrderLineItemTaxTypeAdditive   OrderLineItemTaxType = "ADDITIVE"
	OrderLineItemTaxTypeInclusive  OrderLineItemTaxType = "INCLUSIVE"
)

func NewOrderLineItemTaxTypeFromString(s string) (OrderLineItemTaxType, error) {
	switch s {
	case "UNKNOWN_TAX":
		return OrderLineItemTaxTypeUnknownTax, nil
	case "ADDITIVE":
		return OrderLineItemTaxTypeAdditive, nil
	case "INCLUSIVE":
		return OrderLineItemTaxTypeInclusive, nil
	}
	var t OrderLineItemTaxType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderLineItemTaxType) Ptr() *OrderLineItemTaxType {
	return &o
}

// A collection of various money amounts.
type OrderMoneyAmounts struct {
	TotalMoney         *Money `json:"total_money,omitempty" url:"total_money,omitempty"`
	TaxMoney           *Money `json:"tax_money,omitempty" url:"tax_money,omitempty"`
	DiscountMoney      *Money `json:"discount_money,omitempty" url:"discount_money,omitempty"`
	TipMoney           *Money `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	ServiceChargeMoney *Money `json:"service_charge_money,omitempty" url:"service_charge_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderMoneyAmounts) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderMoneyAmounts) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderMoneyAmounts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderMoneyAmounts(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderMoneyAmounts) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Pricing options for an order. The options affect how the order's price is calculated.
// They can be used, for example, to apply automatic price adjustments that are based on preconfigured
// [pricing rules](entity:CatalogPricingRule).
type OrderPricingOptions struct {
	// The option to determine whether pricing rule-based
	// discounts are automatically applied to an order.
	AutoApplyDiscounts *bool `json:"auto_apply_discounts,omitempty" url:"auto_apply_discounts,omitempty"`
	// The option to determine whether rule-based taxes are automatically
	// applied to an order when the criteria of the corresponding rules are met.
	AutoApplyTaxes *bool `json:"auto_apply_taxes,omitempty" url:"auto_apply_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderPricingOptions) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderPricingOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderPricingOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderPricingOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderPricingOptions) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Contains the measurement unit for a quantity and a precision that
// specifies the number of digits after the decimal point for decimal quantities.
type OrderQuantityUnit struct {
	MeasurementUnit *MeasurementUnit `json:"measurement_unit,omitempty" url:"measurement_unit,omitempty"`
	// For non-integer quantities, represents the number of digits after the decimal point that are
	// recorded for this quantity.
	//
	// For example, a precision of 1 allows quantities such as `"1.0"` and `"1.1"`, but not `"1.01"`.
	//
	// Min: 0. Max: 5.
	Precision *int `json:"precision,omitempty" url:"precision,omitempty"`
	// The catalog object ID referencing the
	// [CatalogMeasurementUnit](entity:CatalogMeasurementUnit).
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this measurement unit references.
	//
	// This field is set when this is a catalog-backed measurement unit.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderQuantityUnit) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderQuantityUnit) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderQuantityUnit
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderQuantityUnit(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderQuantityUnit) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The set of line items, service charges, taxes, discounts, tips, and other items being returned in an order.
type OrderReturn struct {
	// A unique ID that identifies the return only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// An order that contains the original sale of these return line items. This is unset
	// for unlinked returns.
	SourceOrderId *string `json:"source_order_id,omitempty" url:"source_order_id,omitempty"`
	// A collection of line items that are being returned.
	ReturnLineItems []*OrderReturnLineItem `json:"return_line_items,omitempty" url:"return_line_items,omitempty"`
	// A collection of service charges that are being returned.
	ReturnServiceCharges []*OrderReturnServiceCharge `json:"return_service_charges,omitempty" url:"return_service_charges,omitempty"`
	// A collection of references to taxes being returned for an order, including the total
	// applied tax amount to be returned. The taxes must reference a top-level tax ID from the source
	// order.
	ReturnTaxes []*OrderReturnTax `json:"return_taxes,omitempty" url:"return_taxes,omitempty"`
	// A collection of references to discounts being returned for an order, including the total
	// applied discount amount to be returned. The discounts must reference a top-level discount ID
	// from the source order.
	ReturnDiscounts    []*OrderReturnDiscount   `json:"return_discounts,omitempty" url:"return_discounts,omitempty"`
	RoundingAdjustment *OrderRoundingAdjustment `json:"rounding_adjustment,omitempty" url:"rounding_adjustment,omitempty"`
	ReturnAmounts      *OrderMoneyAmounts       `json:"return_amounts,omitempty" url:"return_amounts,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturn) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturn) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturn
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturn(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturn) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a discount being returned that applies to one or more return line items in an
// order.
//
// Fixed-amount, order-scoped discounts are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnDiscount struct {
	// A unique ID that identifies the returned discount only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The discount `uid` from the order that contains the original application of this discount.
	SourceDiscountUid *string `json:"source_discount_uid,omitempty" url:"source_discount_uid,omitempty"`
	// The catalog object ID referencing [CatalogDiscount](entity:CatalogDiscount).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this discount references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The discount's name.
	Name *string                    `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemDiscountType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// A value of `"7.25"` corresponds to a percentage of 7.25%.
	//
	// `percentage` is not set for amount-based discounts.
	Percentage   *string                     `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney  *Money                      `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney *Money                      `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemDiscountScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnDiscount) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnDiscount) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnDiscount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnDiscount(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnDiscount) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The line item being returned in an order.
type OrderReturnLineItem struct {
	// A unique ID for this return line-item entry.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The `uid` of the line item in the original sale order.
	SourceLineItemUid *string `json:"source_line_item_uid,omitempty" url:"source_line_item_uid,omitempty"`
	// The name of the line item.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The quantity returned, formatted as a decimal number.
	// For example, `"3"`.
	//
	// Line items with a `quantity_unit` can have non-integer quantities.
	// For example, `"1.70000"`.
	Quantity     string             `json:"quantity" url:"quantity"`
	QuantityUnit *OrderQuantityUnit `json:"quantity_unit,omitempty" url:"quantity_unit,omitempty"`
	// The note of the return line item.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// The [CatalogItemVariation](entity:CatalogItemVariation) ID applied to this return line item.
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the variation applied to this return line item.
	VariationName *string                `json:"variation_name,omitempty" url:"variation_name,omitempty"`
	ItemType      *OrderLineItemItemType `json:"item_type,omitempty" url:"item_type,omitempty"`
	// The [CatalogModifier](entity:CatalogModifier)s applied to this line item.
	ReturnModifiers []*OrderReturnLineItemModifier `json:"return_modifiers,omitempty" url:"return_modifiers,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the return line item. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderReturnTax` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// The list of references to `OrderReturnDiscount` entities applied to the return line item. Each
	// `OrderLineItemAppliedDiscount` has a `discount_uid` that references the `uid` of a top-level
	// `OrderReturnDiscount` applied to the return line item. On reads, the applied amount
	// is populated.
	AppliedDiscounts         []*OrderLineItemAppliedDiscount `json:"applied_discounts,omitempty" url:"applied_discounts,omitempty"`
	BasePriceMoney           *Money                          `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	VariationTotalPriceMoney *Money                          `json:"variation_total_price_money,omitempty" url:"variation_total_price_money,omitempty"`
	GrossReturnMoney         *Money                          `json:"gross_return_money,omitempty" url:"gross_return_money,omitempty"`
	TotalTaxMoney            *Money                          `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	TotalDiscountMoney       *Money                          `json:"total_discount_money,omitempty" url:"total_discount_money,omitempty"`
	TotalMoney               *Money                          `json:"total_money,omitempty" url:"total_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItem) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItem) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItem) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A line item modifier being returned.
type OrderReturnLineItemModifier struct {
	// A unique ID that identifies the return modifier only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The modifier `uid` from the order's line item that contains the
	// original sale of this line item modifier.
	SourceModifierUid *string `json:"source_modifier_uid,omitempty" url:"source_modifier_uid,omitempty"`
	// The catalog object ID referencing [CatalogModifier](entity:CatalogModifier).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this line item modifier references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The name of the item modifier.
	Name            *string `json:"name,omitempty" url:"name,omitempty"`
	BasePriceMoney  *Money  `json:"base_price_money,omitempty" url:"base_price_money,omitempty"`
	TotalPriceMoney *Money  `json:"total_price_money,omitempty" url:"total_price_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnLineItemModifier) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnLineItemModifier) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnLineItemModifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnLineItemModifier(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnLineItemModifier) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents the service charge applied to the original order.
type OrderReturnServiceCharge struct {
	// A unique ID that identifies the return service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The service charge `uid` from the order containing the original
	// service charge. `source_service_charge_uid` is `null` for
	// unlinked returns.
	SourceServiceChargeUid *string `json:"source_service_charge_uid,omitempty" url:"source_service_charge_uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID of the associated [OrderServiceCharge](entity:OrderServiceCharge).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The percentage of the service charge, as a string representation of
	// a decimal number. For example, a value of `"7.25"` corresponds to a
	// percentage of 7.25%.
	//
	// Either `percentage` or `amount_money` should be set, but not both.
	Percentage       *string                             `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney      *Money                              `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney     *Money                              `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	TotalMoney       *Money                              `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney    *Money                              `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the surcharge can be taxed. Service charges
	// calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to `OrderReturnTax` entities applied to the
	// `OrderReturnServiceCharge`. Each `OrderLineItemAppliedTax` has a `tax_uid`
	// that references the `uid` of a top-level `OrderReturnTax` that is being
	// applied to the `OrderReturnServiceCharge`. On reads, the applied amount is
	// populated.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a tax being returned that applies to one or more return line items in an order.
//
// Fixed-amount, order-scoped taxes are distributed across all non-zero return line item totals.
// The amount distributed to each return line item is relative to that item’s contribution to the
// order subtotal.
type OrderReturnTax struct {
	// A unique ID that identifies the returned tax only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The tax `uid` from the order that contains the original tax charge.
	SourceTaxUid *string `json:"source_tax_uid,omitempty" url:"source_tax_uid,omitempty"`
	// The catalog object ID referencing [CatalogTax](entity:CatalogTax).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this tax references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The tax's name.
	Name *string               `json:"name,omitempty" url:"name,omitempty"`
	Type *OrderLineItemTaxType `json:"type,omitempty" url:"type,omitempty"`
	// The percentage of the tax, as a string representation of a decimal number.
	// For example, a value of `"7.25"` corresponds to a percentage of 7.25%.
	Percentage   *string                `json:"percentage,omitempty" url:"percentage,omitempty"`
	AppliedMoney *Money                 `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	Scope        *OrderLineItemTaxScope `json:"scope,omitempty" url:"scope,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReturnTax) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReturnTax) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReturnTax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReturnTax(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReturnTax) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a reward that can be applied to an order if the necessary
// reward tier criteria are met. Rewards are created through the Loyalty API.
type OrderReward struct {
	// The identifier of the reward.
	Id string `json:"id" url:"id"`
	// The identifier of the reward tier corresponding to this reward.
	RewardTierId string `json:"reward_tier_id" url:"reward_tier_id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderReward) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderReward) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderReward
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderReward(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderReward) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// A rounding adjustment of the money being returned. Commonly used to apply cash rounding
// when the minimum unit of the account is smaller than the lowest physical denomination of the currency.
type OrderRoundingAdjustment struct {
	// A unique ID that identifies the rounding adjustment only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the rounding adjustment from the original sale order.
	Name        *string `json:"name,omitempty" url:"name,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderRoundingAdjustment) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderRoundingAdjustment) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderRoundingAdjustment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderRoundingAdjustment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderRoundingAdjustment) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a service charge applied to an order.
type OrderServiceCharge struct {
	// A unique ID that identifies the service charge only within this order.
	Uid *string `json:"uid,omitempty" url:"uid,omitempty"`
	// The name of the service charge.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The catalog object ID referencing the service charge [CatalogObject](entity:CatalogObject).
	CatalogObjectId *string `json:"catalog_object_id,omitempty" url:"catalog_object_id,omitempty"`
	// The version of the catalog object that this service charge references.
	CatalogVersion *int64 `json:"catalog_version,omitempty" url:"catalog_version,omitempty"`
	// The service charge percentage as a string representation of a
	// decimal number. For example, `"7.25"` indicates a service charge of 7.25%.
	//
	// Exactly 1 of `percentage` or `amount_money` should be set.
	Percentage       *string                             `json:"percentage,omitempty" url:"percentage,omitempty"`
	AmountMoney      *Money                              `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppliedMoney     *Money                              `json:"applied_money,omitempty" url:"applied_money,omitempty"`
	TotalMoney       *Money                              `json:"total_money,omitempty" url:"total_money,omitempty"`
	TotalTaxMoney    *Money                              `json:"total_tax_money,omitempty" url:"total_tax_money,omitempty"`
	CalculationPhase *OrderServiceChargeCalculationPhase `json:"calculation_phase,omitempty" url:"calculation_phase,omitempty"`
	// Indicates whether the service charge can be taxed. If set to `true`,
	// order-level taxes automatically apply to the service charge. Note that
	// service charges calculated in the `TOTAL_PHASE` cannot be marked as taxable.
	Taxable *bool `json:"taxable,omitempty" url:"taxable,omitempty"`
	// The list of references to the taxes applied to this service charge. Each
	// `OrderLineItemAppliedTax` has a `tax_uid` that references the `uid` of a top-level
	// `OrderLineItemTax` that is being applied to this service charge. On reads, the amount applied
	// is populated.
	//
	// An `OrderLineItemAppliedTax` is automatically created on every taxable service charge
	// for all `ORDER` scoped taxes that are added to the order. `OrderLineItemAppliedTax` records
	// for `LINE_ITEM` scoped taxes must be added in requests for the tax to apply to any taxable
	// service charge. Taxable service charges have the `taxable` field set to `true` and calculated
	// in the `SUBTOTAL_PHASE`.
	//
	// To change the amount of a tax, modify the referenced top-level tax.
	AppliedTaxes []*OrderLineItemAppliedTax `json:"applied_taxes,omitempty" url:"applied_taxes,omitempty"`
	// Application-defined data attached to this service charge. Metadata fields are intended
	// to store descriptive references or associations with an entity in another system or store brief
	// information about the object. Square does not process this field; it only stores and returns it
	// in relevant API calls. Do not use metadata to store any sensitive information (such as personally
	// identifiable information or card details).
	//
	// Keys written by applications must be 60 characters or less and must be in the character set
	// `[a-zA-Z0-9_-]`. Entries can also include metadata generated by Square. These keys are prefixed
	// with a namespace, separated from the key with a ':' character.
	//
	// Values have a maximum length of 255 characters.
	//
	// An application can have up to 10 entries per metadata field.
	//
	// Entries written by applications are private and can only be read or modified by the same
	// application.
	//
	// For more information, see [Metadata](https://developer.squareup.com/docs/build-basics/metadata).
	Metadata map[string]string       `json:"metadata,omitempty" url:"metadata,omitempty"`
	Type     *OrderServiceChargeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderServiceCharge) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderServiceCharge) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderServiceCharge
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderServiceCharge(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderServiceCharge) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Represents a phase in the process of calculating order totals.
// Service charges are applied after the indicated phase.
//
// [Read more about how order totals are calculated.](https://developer.squareup.com/docs/orders-api/how-it-works#how-totals-are-calculated)
type OrderServiceChargeCalculationPhase string

const (
	OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse OrderServiceChargeCalculationPhase = "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE"
	OrderServiceChargeCalculationPhaseSubtotalPhase                         OrderServiceChargeCalculationPhase = "SUBTOTAL_PHASE"
	OrderServiceChargeCalculationPhaseTotalPhase                            OrderServiceChargeCalculationPhase = "TOTAL_PHASE"
	OrderServiceChargeCalculationPhaseApportionedPercentagePhase            OrderServiceChargeCalculationPhase = "APPORTIONED_PERCENTAGE_PHASE"
	OrderServiceChargeCalculationPhaseApportionedAmountPhase                OrderServiceChargeCalculationPhase = "APPORTIONED_AMOUNT_PHASE"
)

func NewOrderServiceChargeCalculationPhaseFromString(s string) (OrderServiceChargeCalculationPhase, error) {
	switch s {
	case "SERVICE_CHARGE_CALCULATION_PHASE_DO_NOT_USE":
		return OrderServiceChargeCalculationPhaseServiceChargeCalculationPhaseDoNotUse, nil
	case "SUBTOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseSubtotalPhase, nil
	case "TOTAL_PHASE":
		return OrderServiceChargeCalculationPhaseTotalPhase, nil
	case "APPORTIONED_PERCENTAGE_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedPercentagePhase, nil
	case "APPORTIONED_AMOUNT_PHASE":
		return OrderServiceChargeCalculationPhaseApportionedAmountPhase, nil
	}
	var t OrderServiceChargeCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeCalculationPhase) Ptr() *OrderServiceChargeCalculationPhase {
	return &o
}

type OrderServiceChargeType string

const (
	OrderServiceChargeTypeServiceChargeTypeDoNotUse OrderServiceChargeType = "SERVICE_CHARGE_TYPE_DO_NOT_USE"
	OrderServiceChargeTypeAutoGratuity              OrderServiceChargeType = "AUTO_GRATUITY"
	OrderServiceChargeTypeCustom                    OrderServiceChargeType = "CUSTOM"
)

func NewOrderServiceChargeTypeFromString(s string) (OrderServiceChargeType, error) {
	switch s {
	case "SERVICE_CHARGE_TYPE_DO_NOT_USE":
		return OrderServiceChargeTypeServiceChargeTypeDoNotUse, nil
	case "AUTO_GRATUITY":
		return OrderServiceChargeTypeAutoGratuity, nil
	case "CUSTOM":
		return OrderServiceChargeTypeCustom, nil
	}
	var t OrderServiceChargeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderServiceChargeType) Ptr() *OrderServiceChargeType {
	return &o
}

// Represents the origination details of an order.
type OrderSource struct {
	// The name used to identify the place (physical or digital) that an order originates.
	// If unset, the name defaults to the name of the application that created the order.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OrderSource) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OrderSource) UnmarshalJSON(data []byte) error {
	type unmarshaler OrderSource
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OrderSource(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OrderSource) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// The state of the order.
type OrderState string

const (
	OrderStateDoNotUse  OrderState = "DO_NOT_USE"
	OrderStateOpen      OrderState = "OPEN"
	OrderStateCompleted OrderState = "COMPLETED"
	OrderStateCanceled  OrderState = "CANCELED"
	OrderStateDraft     OrderState = "DRAFT"
)

func NewOrderStateFromString(s string) (OrderState, error) {
	switch s {
	case "DO_NOT_USE":
		return OrderStateDoNotUse, nil
	case "OPEN":
		return OrderStateOpen, nil
	case "COMPLETED":
		return OrderStateCompleted, nil
	case "CANCELED":
		return OrderStateCanceled, nil
	case "DRAFT":
		return OrderStateDraft, nil
	}
	var t OrderState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderState) Ptr() *OrderState {
	return &o
}

// Represents a payment processed by the Square API.
type Payment struct {
	// A unique ID for the payment.
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The timestamp of when the payment was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payment was last updated, in RFC 3339 format.
	UpdatedAt     *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	AmountMoney   *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	TipMoney      *Money  `json:"tip_money,omitempty" url:"tip_money,omitempty"`
	TotalMoney    *Money  `json:"total_money,omitempty" url:"total_money,omitempty"`
	AppFeeMoney   *Money  `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	ApprovedMoney *Money  `json:"approved_money,omitempty" url:"approved_money,omitempty"`
	// The processing fees and fee adjustments assessed by Square for this payment.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	RefundedMoney *Money           `json:"refunded_money,omitempty" url:"refunded_money,omitempty"`
	// Indicates whether the payment is APPROVED, PENDING, COMPLETED, CANCELED, or FAILED.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The duration of time after the payment's creation when Square automatically applies the
	// `delay_action` to the payment. This automatic `delay_action` applies only to payments that
	// do not reach a terminal state (COMPLETED, CANCELED, or FAILED) before the `delay_duration`
	// time period.
	//
	// This field is specified as a time duration, in RFC 3339 format.
	//
	// Notes:
	// This feature is only supported for card payments.
	//
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// The action to be applied to the payment when the `delay_duration` has elapsed.
	//
	// Current values include `CANCEL` and `COMPLETE`.
	DelayAction *string `json:"delay_action,omitempty" url:"delay_action,omitempty"`
	// The read-only timestamp of when the `delay_action` is automatically applied,
	// in RFC 3339 format.
	//
	// Note that this field is calculated by summing the payment's `delay_duration` and `created_at`
	// fields. The `created_at` field is generated by Square and might not exactly match the
	// time on your local machine.
	DelayedUntil *string `json:"delayed_until,omitempty" url:"delayed_until,omitempty"`
	// The source type for this payment.
	//
	// Current values include `CARD`, `BANK_ACCOUNT`, `WALLET`, `BUY_NOW_PAY_LATER`, `CASH`, or
	// `EXTERNAL`. For information about these payment source types,
	// see [Take Payments](https://developer.squareup.com/docs/payments-api/take-payments).
	SourceType            *string                    `json:"source_type,omitempty" url:"source_type,omitempty"`
	CardDetails           *CardPaymentDetails        `json:"card_details,omitempty" url:"card_details,omitempty"`
	CashDetails           *CashPaymentDetails        `json:"cash_details,omitempty" url:"cash_details,omitempty"`
	BankAccountDetails    *BankAccountPaymentDetails `json:"bank_account_details,omitempty" url:"bank_account_details,omitempty"`
	ExternalDetails       *ExternalPaymentDetails    `json:"external_details,omitempty" url:"external_details,omitempty"`
	WalletDetails         *DigitalWalletDetails      `json:"wallet_details,omitempty" url:"wallet_details,omitempty"`
	BuyNowPayLaterDetails *BuyNowPayLaterDetails     `json:"buy_now_pay_later_details,omitempty" url:"buy_now_pay_later_details,omitempty"`
	// The ID of the location associated with the payment.
	LocationId *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	// The ID of the order associated with the payment.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// An optional ID that associates the payment with an entity in
	// another system.
	ReferenceId *string `json:"reference_id,omitempty" url:"reference_id,omitempty"`
	// The [Customer](entity:Customer) ID of the customer associated with the payment.
	CustomerId *string `json:"customer_id,omitempty" url:"customer_id,omitempty"`
	// **Deprecated**: Use `Payment.team_member_id` instead.
	//
	// An optional ID of the employee associated with taking the payment.
	EmployeeId *string `json:"employee_id,omitempty" url:"employee_id,omitempty"`
	// An optional ID of the [TeamMember](entity:TeamMember) associated with taking the payment.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`
	// A list of `refund_id`s identifying refunds for the payment.
	RefundIds      []string        `json:"refund_ids,omitempty" url:"refund_ids,omitempty"`
	RiskEvaluation *RiskEvaluation `json:"risk_evaluation,omitempty" url:"risk_evaluation,omitempty"`
	// The buyer's email address.
	BuyerEmailAddress *string  `json:"buyer_email_address,omitempty" url:"buyer_email_address,omitempty"`
	BillingAddress    *Address `json:"billing_address,omitempty" url:"billing_address,omitempty"`
	ShippingAddress   *Address `json:"shipping_address,omitempty" url:"shipping_address,omitempty"`
	// An optional note to include when creating a payment.
	Note *string `json:"note,omitempty" url:"note,omitempty"`
	// Additional payment information that gets added to the customer's card statement
	// as part of the statement description.
	//
	// Note that the `statement_description_identifier` might get truncated on the statement description
	// to fit the required information including the Square identifier (SQ \*) and the name of the
	// seller taking the payment.
	StatementDescriptionIdentifier *string `json:"statement_description_identifier,omitempty" url:"statement_description_identifier,omitempty"`
	// Actions that can be performed on this payment:
	//
	// - `EDIT_AMOUNT_UP` - The payment amount can be edited up.
	// - `EDIT_AMOUNT_DOWN` - The payment amount can be edited down.
	// - `EDIT_TIP_AMOUNT_UP` - The tip amount can be edited up.
	// - `EDIT_TIP_AMOUNT_DOWN` - The tip amount can be edited down.
	// - `EDIT_DELAY_ACTION` - The delay_action can be edited.
	Capabilities []string `json:"capabilities,omitempty" url:"capabilities,omitempty"`
	// The payment's receipt number.
	// The field is missing if a payment is canceled.
	ReceiptNumber *string `json:"receipt_number,omitempty" url:"receipt_number,omitempty"`
	// The URL for the payment's receipt.
	// The field is only populated for COMPLETED payments.
	ReceiptUrl         *string             `json:"receipt_url,omitempty" url:"receipt_url,omitempty"`
	DeviceDetails      *DeviceDetails      `json:"device_details,omitempty" url:"device_details,omitempty"`
	ApplicationDetails *ApplicationDetails `json:"application_details,omitempty" url:"application_details,omitempty"`
	// Used for optimistic concurrency. This opaque token identifies a specific version of the
	// `Payment` object.
	VersionToken *string `json:"version_token,omitempty" url:"version_token,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payment) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payment) UnmarshalJSON(data []byte) error {
	type unmarshaler Payment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payment(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payment) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PaymentOptions struct {
	// Indicates whether the `Payment` objects created from this `TerminalCheckout` are automatically
	// `COMPLETED` or left in an `APPROVED` state for later modification.
	Autocomplete *bool `json:"autocomplete,omitempty" url:"autocomplete,omitempty"`
	// The duration of time after the payment's creation when Square automatically cancels the
	// payment. This automatic cancellation applies only to payments that do not reach a terminal state
	// (COMPLETED, CANCELED, or FAILED) before the `delay_duration` time period.
	//
	// This parameter should be specified as a time duration, in RFC 3339 format, with a minimum value
	// of 1 minute.
	//
	// Note: This feature is only supported for card payments. This parameter can only be set for a delayed
	// capture payment (`autocomplete=false`).
	// Default:
	//
	// - Card-present payments: "PT36H" (36 hours) from the creation time.
	// - Card-not-present payments: "P7D" (7 days) from the creation time.
	DelayDuration *string `json:"delay_duration,omitempty" url:"delay_duration,omitempty"`
	// If set to `true` and charging a Square Gift Card, a payment might be returned with
	// `amount_money` equal to less than what was requested. For example, a request for $20 when charging
	// a Square Gift Card with a balance of $5 results in an APPROVED payment of $5. You might choose
	// to prompt the buyer for an additional payment to cover the remainder or cancel the Gift Card
	// payment.
	//
	// This field cannot be `true` when `autocomplete = true`.
	// This field cannot be `true` when an `order_id` isn't specified.
	//
	// For more information, see
	// [Take Partial Payments](https://developer.squareup.com/docs/payments-api/take-payments/card-payments/partial-payments-with-gift-cards).
	//
	// Default: false
	AcceptPartialAuthorization *bool `json:"accept_partial_authorization,omitempty" url:"accept_partial_authorization,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentOptions) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentOptions(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentOptions) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a refund of a payment made using Square. Contains information about
// the original payment and the amount of money refunded.
type PaymentRefund struct {
	// The unique ID for this refund, generated by Square.
	Id string `json:"id" url:"id"`
	// The refund's status:
	//
	// - `PENDING` - Awaiting approval.
	// - `COMPLETED` - Successfully completed.
	// - `REJECTED` - The refund was rejected.
	// - `FAILED` - An error occurred.
	Status *string `json:"status,omitempty" url:"status,omitempty"`
	// The location ID associated with the payment this refund is attached to.
	LocationId  *string `json:"location_id,omitempty" url:"location_id,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	AppFeeMoney *Money  `json:"app_fee_money,omitempty" url:"app_fee_money,omitempty"`
	// Processing fees and fee adjustments assessed by Square for this refund.
	ProcessingFee []*ProcessingFee `json:"processing_fee,omitempty" url:"processing_fee,omitempty"`
	// The ID of the payment associated with this refund.
	PaymentId *string `json:"payment_id,omitempty" url:"payment_id,omitempty"`
	// The ID of the order associated with the refund.
	OrderId *string `json:"order_id,omitempty" url:"order_id,omitempty"`
	// The reason for the refund.
	Reason *string `json:"reason,omitempty" url:"reason,omitempty"`
	// The timestamp of when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the refund was last updated, in RFC 3339 format.
	UpdatedAt *string `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	// An optional ID of the team member associated with taking the payment.
	TeamMemberId *string `json:"team_member_id,omitempty" url:"team_member_id,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaymentRefund) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaymentRefund) UnmarshalJSON(data []byte) error {
	type unmarshaler PaymentRefund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaymentRefund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaymentRefund) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// An accounting of the amount owed the seller and record of the actual transfer to their
// external bank account or to the Square balance.
type Payout struct {
	// A unique ID for the payout.
	Id     string        `json:"id" url:"id"`
	Status *PayoutStatus `json:"status,omitempty" url:"status,omitempty"`
	// The ID of the location associated with the payout.
	LocationId string `json:"location_id" url:"location_id"`
	// The timestamp of when the payout was created and submitted for deposit to the seller's banking destination, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The timestamp of when the payout was last updated, in RFC 3339 format.
	UpdatedAt   *string      `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	AmountMoney *Money       `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	Destination *Destination `json:"destination,omitempty" url:"destination,omitempty"`
	// The version number, which is incremented each time an update is made to this payout record.
	// The version number helps developers receive event notifications or feeds out of order.
	Version *int        `json:"version,omitempty" url:"version,omitempty"`
	Type    *PayoutType `json:"type,omitempty" url:"type,omitempty"`
	// A list of transfer fees and any taxes on the fees assessed by Square for this payout.
	PayoutFee []*PayoutFee `json:"payout_fee,omitempty" url:"payout_fee,omitempty"`
	// The calendar date, in ISO 8601 format (YYYY-MM-DD), when the payout is due to arrive in the seller’s banking destination.
	ArrivalDate *string `json:"arrival_date,omitempty" url:"arrival_date,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Payout) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Payout) UnmarshalJSON(data []byte) error {
	type unmarshaler Payout
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Payout(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Payout) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents a payout fee that can incur as part of a payout.
type PayoutFee struct {
	AmountMoney *Money `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string        `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	Type        *PayoutFeeType `json:"type,omitempty" url:"type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PayoutFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PayoutFee) UnmarshalJSON(data []byte) error {
	type unmarshaler PayoutFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PayoutFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PayoutFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Represents the type of payout fee that can incur as part of a payout.
type PayoutFeeType string

const (
	PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse PayoutFeeType = "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE"
	PayoutFeeTypeTransferFee                  PayoutFeeType = "TRANSFER_FEE"
	PayoutFeeTypeTaxOnTransferFee             PayoutFeeType = "TAX_ON_TRANSFER_FEE"
)

func NewPayoutFeeTypeFromString(s string) (PayoutFeeType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_FEE_TYPE_DO_NOT_USE":
		return PayoutFeeTypeUnknownPayoutFeeTypeDoNotUse, nil
	case "TRANSFER_FEE":
		return PayoutFeeTypeTransferFee, nil
	case "TAX_ON_TRANSFER_FEE":
		return PayoutFeeTypeTaxOnTransferFee, nil
	}
	var t PayoutFeeType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutFeeType) Ptr() *PayoutFeeType {
	return &p
}

// Payout status types
type PayoutStatus string

const (
	PayoutStatusUnknownPayoutStatusDoNotUse PayoutStatus = "UNKNOWN_PAYOUT_STATUS_DO_NOT_USE"
	PayoutStatusSent                        PayoutStatus = "SENT"
	PayoutStatusFailed                      PayoutStatus = "FAILED"
	PayoutStatusPaid                        PayoutStatus = "PAID"
)

func NewPayoutStatusFromString(s string) (PayoutStatus, error) {
	switch s {
	case "UNKNOWN_PAYOUT_STATUS_DO_NOT_USE":
		return PayoutStatusUnknownPayoutStatusDoNotUse, nil
	case "SENT":
		return PayoutStatusSent, nil
	case "FAILED":
		return PayoutStatusFailed, nil
	case "PAID":
		return PayoutStatusPaid, nil
	}
	var t PayoutStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutStatus) Ptr() *PayoutStatus {
	return &p
}

// The type of payout: “BATCH” or “SIMPLE”.
// BATCH payouts include a list of payout entries that can be considered settled.
// SIMPLE payouts do not have any payout entries associated with them
// and will show up as one of the payout entries in a future BATCH payout.
type PayoutType string

const (
	PayoutTypeUnknownPayoutTypeDoNotUse PayoutType = "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE"
	PayoutTypeBatch                     PayoutType = "BATCH"
	PayoutTypeSimple                    PayoutType = "SIMPLE"
)

func NewPayoutTypeFromString(s string) (PayoutType, error) {
	switch s {
	case "UNKNOWN_PAYOUT_TYPE_DO_NOT_USE":
		return PayoutTypeUnknownPayoutTypeDoNotUse, nil
	case "BATCH":
		return PayoutTypeBatch, nil
	case "SIMPLE":
		return PayoutTypeSimple, nil
	}
	var t PayoutType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PayoutType) Ptr() *PayoutType {
	return &p
}

// Represents the Square processing fee.
type ProcessingFee struct {
	// The timestamp of when the fee takes effect, in RFC 3339 format.
	EffectiveAt *string `json:"effective_at,omitempty" url:"effective_at,omitempty"`
	// The type of fee assessed or adjusted. The fee type can be `INITIAL` or `ADJUSTMENT`.
	Type        *string `json:"type,omitempty" url:"type,omitempty"`
	AmountMoney *Money  `json:"amount_money,omitempty" url:"amount_money,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *ProcessingFee) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *ProcessingFee) UnmarshalJSON(data []byte) error {
	type unmarshaler ProcessingFee
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ProcessingFee(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ProcessingFee) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Indicates the Square product used to generate a change.
type Product string

const (
	ProductProductDoNotUse    Product = "PRODUCT_DO_NOT_USE"
	ProductSquarePos          Product = "SQUARE_POS"
	ProductExternalApi        Product = "EXTERNAL_API"
	ProductBilling            Product = "BILLING"
	ProductAppointments       Product = "APPOINTMENTS"
	ProductInvoices           Product = "INVOICES"
	ProductOnlineStore        Product = "ONLINE_STORE"
	ProductPayroll            Product = "PAYROLL"
	ProductDashboard          Product = "DASHBOARD"
	ProductItemLibraryImport  Product = "ITEM_LIBRARY_IMPORT"
	ProductRetail             Product = "RETAIL"
	ProductRestaurant         Product = "RESTAURANT"
	ProductCustomersDirectory Product = "CUSTOMERS_DIRECTORY"
	ProductOther              Product = "OTHER"
)

func NewProductFromString(s string) (Product, error) {
	switch s {
	case "PRODUCT_DO_NOT_USE":
		return ProductProductDoNotUse, nil
	case "SQUARE_POS":
		return ProductSquarePos, nil
	case "EXTERNAL_API":
		return ProductExternalApi, nil
	case "BILLING":
		return ProductBilling, nil
	case "APPOINTMENTS":
		return ProductAppointments, nil
	case "INVOICES":
		return ProductInvoices, nil
	case "ONLINE_STORE":
		return ProductOnlineStore, nil
	case "PAYROLL":
		return ProductPayroll, nil
	case "DASHBOARD":
		return ProductDashboard, nil
	case "ITEM_LIBRARY_IMPORT":
		return ProductItemLibraryImport, nil
	case "RETAIL":
		return ProductRetail, nil
	case "RESTAURANT":
		return ProductRestaurant, nil
	case "CUSTOMERS_DIRECTORY":
		return ProductCustomersDirectory, nil
	case "OTHER":
		return ProductOther, nil
	}
	var t Product
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Product) Ptr() *Product {
	return &p
}

// Represents a refund processed for a Square transaction.
type Refund struct {
	// The refund's unique ID.
	Id string `json:"id" url:"id"`
	// The ID of the refund's associated location.
	LocationId string `json:"location_id" url:"location_id"`
	// The ID of the transaction that the refunded tender is part of.
	TransactionId *string `json:"transaction_id,omitempty" url:"transaction_id,omitempty"`
	// The ID of the refunded tender.
	TenderId string `json:"tender_id" url:"tender_id"`
	// The timestamp for when the refund was created, in RFC 3339 format.
	CreatedAt *string `json:"created_at,omitempty" url:"created_at,omitempty"`
	// The reason for the refund being issued.
	Reason             string       `json:"reason" url:"reason"`
	AmountMoney        *Money       `json:"amount_money,omitempty" url:"amount_money,omitempty"`
	Status             RefundStatus `json:"status" url:"status"`
	ProcessingFeeMoney *Money       `json:"processing_fee_money,omitempty" url:"processing_fee_money,omitempty"`
	// Additional recipients (other than the merchant) receiving a portion of this refund.
	// For example, fees assessed on a refund of a purchase by a third party integration.
	AdditionalRecipients []*AdditionalRecipient `json:"additional_recipients,omitempty" url:"additional_recipients,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Refund) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Refund) UnmarshalJSON(data []byte) error {
	type unmarshaler Refund
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Refund(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Refund) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the response returned by
// [RefundPayment](api-endpoint:Refunds-RefundPayment).
//
// If there are errors processing the request, the `refund` field might not be
// present, or it might be present with a status of `FAILED`.
type RefundPaymentResponse struct {
	// Information about errors encountered during the request.
	Errors []*Error       `json:"errors,omitempty" url:"errors,omitempty"`
	Refund *PaymentRefund `json:"refund,omitempty" url:"refund,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RefundPaymentResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RefundPaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RefundPaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RefundPaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RefundPaymentResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Indicates a refund's current status.
type RefundStatus string

const (
	RefundStatusPending  RefundStatus = "PENDING"
	RefundStatusApproved RefundStatus = "APPROVED"
	RefundStatusRejected RefundStatus = "REJECTED"
	RefundStatusFailed   RefundStatus = "FAILED"
)

func NewRefundStatusFromString(s string) (RefundStatus, error) {
	switch s {
	case "PENDING":
		return RefundStatusPending, nil
	case "APPROVED":
		return RefundStatusApproved, nil
	case "REJECTED":
		return RefundStatusRejected, nil
	case "FAILED":
		return RefundStatusFailed, nil
	}
	var t RefundStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RefundStatus) Ptr() *RefundStatus {
	return &r
}

type RetrieveCatalogObjectResponse struct {
	// Any errors that occurred during the request.
	Errors []*Error       `json:"errors,omitempty" url:"errors,omitempty"`
	Object *CatalogObject `json:"object,omitempty" url:"object,omitempty"`
	// A list of `CatalogObject`s referenced by the object in the `object` field.
	RelatedObjects []*CatalogObject `json:"related_objects,omitempty" url:"related_objects,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCatalogObjectResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCatalogObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCatalogObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCatalogObjectResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCatalogObjectResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Defines the fields that are included in the response body of
// a request to the `RetrieveCustomer` endpoint.
//
// Either `errors` or `customer` is present in a given response (never both).
type RetrieveCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors   []*Error  `json:"errors,omitempty" url:"errors,omitempty"`
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveCustomerResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveCustomerResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The response object returned by the [RetrieveMerchant](api-endpoint:Merchants-RetrieveMerchant) endpoint.
type RetrieveMerchantResponse struct {
	// Information on errors encountered during the request.
	Errors   []*Error  `json:"errors,omitempty" url:"errors,omitempty"`
	Merchant *Merchant `json:"merchant,omitempty" url:"merchant,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveMerchantResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveMerchantResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveMerchantResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveMerchantResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveMerchantResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RetrieveOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RetrieveOrderResponse) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RetrieveOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RetrieveOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetrieveOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RetrieveOrderResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Represents fraud risk information for the associated payment.
//
// When you take a payment through Square's Payments API (using the `CreatePayment`
// endpoint), Square evaluates it and assigns a risk level to the payment. Sellers
// can use this information to determine the course of action (for example,
// provide the goods/services or refund the payment).
type RiskEvaluation struct {
	// The timestamp when payment risk was evaluated, in RFC 3339 format.
	CreatedAt *string                  `json:"created_at,omitempty" url:"created_at,omitempty"`
	RiskLevel *RiskEvaluationRiskLevel `json:"risk_level,omitempty" url:"risk_level,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RiskEvaluation) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RiskEvaluation) UnmarshalJSON(data []byte) error {
	type unmarshaler RiskEvaluation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RiskEvaluation(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RiskEvaluation) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RiskEvaluationRiskLevel string

const (
	RiskEvaluationRiskLevelDoNotUse RiskEvaluationRiskLevel = "DO_NOT_USE"
	RiskEvaluationRiskLevelPending  RiskEvaluationRiskLevel = "PENDING"
	RiskEvaluationRiskLevelNormal   RiskEvaluationRiskLevel = "NORMAL"
	RiskEvaluationRiskLevelModerate RiskEvaluationRiskLevel = "MODERATE"
	RiskEvaluationRiskLevelHigh     RiskEvaluationRiskLevel = "HIGH"
)

func NewRiskEvaluationRiskLevelFromString(s string) (RiskEvaluationRiskLevel, error) {
	switch s {
	case "DO_NOT_USE":
		return RiskEvaluationRiskLevelDoNotUse, nil
	case "PENDING":
		return RiskEvaluationRiskLevelPending, nil
	case "NORMAL":
		return RiskEvaluationRiskLevelNormal, nil
	case "MODERATE":
		return RiskEvaluationRiskLevelModerate, nil
	case "HIGH":
		return RiskEvaluationRiskLevelHigh, nil
	}
	var t RiskEvaluationRiskLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RiskEvaluationRiskLevel) Ptr() *RiskEvaluationRiskLevel {
	return &r
}

// A filter based on the order `customer_id` and any tender `customer_id`
// associated with the order. It does not filter based on the
// [FulfillmentRecipient](entity:OrderFulfillmentRecipient) `customer_id`.
type SearchOrdersCustomerFilter struct {
	// A list of customer IDs to filter by.
	//
	// Max: 10 customer IDs.
	CustomerIds []string `json:"customer_ids,omitempty" url:"customer_ids,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersCustomerFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersCustomerFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersCustomerFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersCustomerFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersCustomerFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter for `Order` objects based on whether their `CREATED_AT`,
// `CLOSED_AT`, or `UPDATED_AT` timestamps fall within a specified time range.
// You can specify the time range and which timestamp to filter for. You can filter
// for only one time range at a time.
//
// For each time range, the start time and end time are inclusive. If the end time
// is absent, it defaults to the time of the first request for the cursor.
//
// **Important:** If you use the `DateTimeFilter` in a `SearchOrders` query,
// you must set the `sort_field` in [OrdersSort](entity:SearchOrdersSort)
// to the same field you filter for. For example, if you set the `CLOSED_AT` field
// in `DateTimeFilter`, you must set the `sort_field` in `SearchOrdersSort` to
// `CLOSED_AT`. Otherwise, `SearchOrders` throws an error.
// [Learn more about filtering orders by time range.](https://developer.squareup.com/docs/orders-api/manage-orders#important-note-on-filtering-orders-by-time-range)
type SearchOrdersDateTimeFilter struct {
	CreatedAt *TimeRange `json:"created_at,omitempty" url:"created_at,omitempty"`
	UpdatedAt *TimeRange `json:"updated_at,omitempty" url:"updated_at,omitempty"`
	ClosedAt  *TimeRange `json:"closed_at,omitempty" url:"closed_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersDateTimeFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersDateTimeFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersDateTimeFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersDateTimeFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersDateTimeFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filtering criteria to use for a `SearchOrders` request. Multiple filters
// are ANDed together.
type SearchOrdersFilter struct {
	StateFilter       *SearchOrdersStateFilter       `json:"state_filter,omitempty" url:"state_filter,omitempty"`
	DateTimeFilter    *SearchOrdersDateTimeFilter    `json:"date_time_filter,omitempty" url:"date_time_filter,omitempty"`
	FulfillmentFilter *SearchOrdersFulfillmentFilter `json:"fulfillment_filter,omitempty" url:"fulfillment_filter,omitempty"`
	SourceFilter      *SearchOrdersSourceFilter      `json:"source_filter,omitempty" url:"source_filter,omitempty"`
	CustomerFilter    *SearchOrdersCustomerFilter    `json:"customer_filter,omitempty" url:"customer_filter,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter based on [order fulfillment](entity:OrderFulfillment) information.
type SearchOrdersFulfillmentFilter struct {
	// A list of [fulfillment types](entity:OrderFulfillmentType) to filter
	// for. The list returns orders if any of its fulfillments match any of the fulfillment types
	// listed in this field.
	// See [OrderFulfillmentType](#type-orderfulfillmenttype) for possible values
	FulfillmentTypes []OrderFulfillmentType `json:"fulfillment_types,omitempty" url:"fulfillment_types,omitempty"`
	// A list of [fulfillment states](entity:OrderFulfillmentState) to filter
	// for. The list returns orders if any of its fulfillments match any of the
	// fulfillment states listed in this field.
	// See [OrderFulfillmentState](#type-orderfulfillmentstate) for possible values
	FulfillmentStates []OrderFulfillmentState `json:"fulfillment_states,omitempty" url:"fulfillment_states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersFulfillmentFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersFulfillmentFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersFulfillmentFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersFulfillmentFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersFulfillmentFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Contains query criteria for the search.
type SearchOrdersQuery struct {
	Filter *SearchOrdersFilter `json:"filter,omitempty" url:"filter,omitempty"`
	Sort   *SearchOrdersSort   `json:"sort,omitempty" url:"sort,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersQuery) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersQuery(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersQuery) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Either the `order_entries` or `orders` field is set, depending on whether
// `return_entries` is set on the [SearchOrdersRequest](api-endpoint:Orders-SearchOrders).
type SearchOrdersResponse struct {
	// A list of [OrderEntries](entity:OrderEntry) that fit the query
	// conditions. The list is populated only if `return_entries` is set to `true` in the request.
	OrderEntries []*OrderEntry `json:"order_entries,omitempty" url:"order_entries,omitempty"`
	// A list of
	// [Order](entity:Order) objects that match the query conditions. The list is populated only if
	// `return_entries` is set to `false` in the request.
	Orders []*Order `json:"orders,omitempty" url:"orders,omitempty"`
	// The pagination cursor to be used in a subsequent request. If unset,
	// this is the final response.
	// For more information, see [Pagination](https://developer.squareup.com/docs/basics/api101/pagination).
	Cursor *string `json:"cursor,omitempty" url:"cursor,omitempty"`
	// [Errors](entity:Error) encountered during the search.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sorting criteria for a `SearchOrders` request. Results can only be sorted
// by a timestamp field.
type SearchOrdersSort struct {
	SortField SearchOrdersSortField `json:"sort_field" url:"sort_field"`
	SortOrder *SortOrder            `json:"sort_order,omitempty" url:"sort_order,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSort) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSort) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSort
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSort(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSort) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Specifies which timestamp to use to sort `SearchOrder` results.
type SearchOrdersSortField string

const (
	SearchOrdersSortFieldDoNotUse  SearchOrdersSortField = "DO_NOT_USE"
	SearchOrdersSortFieldCreatedAt SearchOrdersSortField = "CREATED_AT"
	SearchOrdersSortFieldUpdatedAt SearchOrdersSortField = "UPDATED_AT"
	SearchOrdersSortFieldClosedAt  SearchOrdersSortField = "CLOSED_AT"
)

func NewSearchOrdersSortFieldFromString(s string) (SearchOrdersSortField, error) {
	switch s {
	case "DO_NOT_USE":
		return SearchOrdersSortFieldDoNotUse, nil
	case "CREATED_AT":
		return SearchOrdersSortFieldCreatedAt, nil
	case "UPDATED_AT":
		return SearchOrdersSortFieldUpdatedAt, nil
	case "CLOSED_AT":
		return SearchOrdersSortFieldClosedAt, nil
	}
	var t SearchOrdersSortField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SearchOrdersSortField) Ptr() *SearchOrdersSortField {
	return &s
}

// A filter based on order `source` information.
type SearchOrdersSourceFilter struct {
	// Filters by the [Source](entity:OrderSource) `name`. The filter returns any orders
	// with a `source.name` that matches any of the listed source names.
	//
	// Max: 10 source names.
	SourceNames []string `json:"source_names,omitempty" url:"source_names,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersSourceFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersSourceFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersSourceFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersSourceFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersSourceFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Filter by the current order `state`.
type SearchOrdersStateFilter struct {
	// States to filter for.
	// See [OrderState](#type-orderstate) for possible values
	States []OrderState `json:"states,omitempty" url:"states,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SearchOrdersStateFilter) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SearchOrdersStateFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler SearchOrdersStateFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SearchOrdersStateFilter(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SearchOrdersStateFilter) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The order (e.g., chronological or alphabetical) in which results from a request are returned.
type SortOrder string

const (
	SortOrderDesc SortOrder = "DESC"
	SortOrderAsc  SortOrder = "ASC"
)

func NewSortOrderFromString(s string) (SortOrder, error) {
	switch s {
	case "DESC":
		return SortOrderDesc, nil
	case "ASC":
		return SortOrderAsc, nil
	}
	var t SortOrder
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SortOrder) Ptr() *SortOrder {
	return &s
}

// Represents information about the application used to generate a change.
type SourceApplication struct {
	Product *Product `json:"product,omitempty" url:"product,omitempty"`
	// **Read only** The Square-assigned ID of the application. This field is used only if the
	// [product](entity:Product) type is `EXTERNAL_API`.
	ApplicationId *string `json:"application_id,omitempty" url:"application_id,omitempty"`
	// **Read only** The display name of the application
	// (for example, `"Custom Application"` or `"Square POS 4.74 for Android"`).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SourceApplication) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceApplication) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceApplication
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceApplication(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceApplication) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Determines the billing cadence of a [Subscription](entity:Subscription)
type SubscriptionCadence string

const (
	SubscriptionCadenceSubscriptionCadenceDoNotUse SubscriptionCadence = "SUBSCRIPTION_CADENCE_DO_NOT_USE"
	SubscriptionCadenceDaily                       SubscriptionCadence = "DAILY"
	SubscriptionCadenceWeekly                      SubscriptionCadence = "WEEKLY"
	SubscriptionCadenceEveryTwoWeeks               SubscriptionCadence = "EVERY_TWO_WEEKS"
	SubscriptionCadenceThirtyDays                  SubscriptionCadence = "THIRTY_DAYS"
	SubscriptionCadenceSixtyDays                   SubscriptionCadence = "SIXTY_DAYS"
	SubscriptionCadenceNinetyDays                  SubscriptionCadence = "NINETY_DAYS"
	SubscriptionCadenceMonthly                     SubscriptionCadence = "MONTHLY"
	SubscriptionCadenceEveryTwoMonths              SubscriptionCadence = "EVERY_TWO_MONTHS"
	SubscriptionCadenceQuarterly                   SubscriptionCadence = "QUARTERLY"
	SubscriptionCadenceEveryFourMonths             SubscriptionCadence = "EVERY_FOUR_MONTHS"
	SubscriptionCadenceEverySixMonths              SubscriptionCadence = "EVERY_SIX_MONTHS"
	SubscriptionCadenceAnnual                      SubscriptionCadence = "ANNUAL"
	SubscriptionCadenceEveryTwoYears               SubscriptionCadence = "EVERY_TWO_YEARS"
)

func NewSubscriptionCadenceFromString(s string) (SubscriptionCadence, error) {
	switch s {
	case "SUBSCRIPTION_CADENCE_DO_NOT_USE":
		return SubscriptionCadenceSubscriptionCadenceDoNotUse, nil
	case "DAILY":
		return SubscriptionCadenceDaily, nil
	case "WEEKLY":
		return SubscriptionCadenceWeekly, nil
	case "EVERY_TWO_WEEKS":
		return SubscriptionCadenceEveryTwoWeeks, nil
	case "THIRTY_DAYS":
		return SubscriptionCadenceThirtyDays, nil
	case "SIXTY_DAYS":
		return SubscriptionCadenceSixtyDays, nil
	case "NINETY_DAYS":
		return SubscriptionCadenceNinetyDays, nil
	case "MONTHLY":
		return SubscriptionCadenceMonthly, nil
	case "EVERY_TWO_MONTHS":
		return SubscriptionCadenceEveryTwoMonths, nil
	case "QUARTERLY":
		return SubscriptionCadenceQuarterly, nil
	case "EVERY_FOUR_MONTHS":
		return SubscriptionCadenceEveryFourMonths, nil
	case "EVERY_SIX_MONTHS":
		return SubscriptionCadenceEverySixMonths, nil
	case "ANNUAL":
		return SubscriptionCadenceAnnual, nil
	case "EVERY_TWO_YEARS":
		return SubscriptionCadenceEveryTwoYears, nil
	}
	var t SubscriptionCadence
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SubscriptionCadence) Ptr() *SubscriptionCadence {
	return &s
}

// Describes a phase in a subscription plan. For more information, see
// [Set Up and Manage a Subscription Plan](https://developer.squareup.com/docs/subscriptions-api/setup-plan).
type SubscriptionPhase struct {
	// The Square-assigned ID of the subscription phase. This field cannot be changed after a `SubscriptionPhase` is created.
	Uid     *string             `json:"uid,omitempty" url:"uid,omitempty"`
	Cadence SubscriptionCadence `json:"cadence" url:"cadence"`
	// The number of `cadence`s the phase lasts. If not set, the phase never ends. Only the last phase can be indefinite. This field cannot be changed after a `SubscriptionPhase` is created.
	Periods             *int   `json:"periods,omitempty" url:"periods,omitempty"`
	RecurringPriceMoney *Money `json:"recurring_price_money,omitempty" url:"recurring_price_money,omitempty"`
	// The position this phase appears in the sequence of phases defined for the plan, indexed from 0. This field cannot be changed after a `SubscriptionPhase` is created.
	Ordinal *int64 `json:"ordinal,omitempty" url:"ordinal,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SubscriptionPhase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubscriptionPhase) UnmarshalJSON(data []byte) error {
	type unmarshaler SubscriptionPhase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubscriptionPhase(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubscriptionPhase) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// When to calculate the taxes due on a cart.
type TaxCalculationPhase string

const (
	TaxCalculationPhaseTaxSubtotalPhase TaxCalculationPhase = "TAX_SUBTOTAL_PHASE"
	TaxCalculationPhaseTaxTotalPhase    TaxCalculationPhase = "TAX_TOTAL_PHASE"
)

func NewTaxCalculationPhaseFromString(s string) (TaxCalculationPhase, error) {
	switch s {
	case "TAX_SUBTOTAL_PHASE":
		return TaxCalculationPhaseTaxSubtotalPhase, nil
	case "TAX_TOTAL_PHASE":
		return TaxCalculationPhaseTaxTotalPhase, nil
	}
	var t TaxCalculationPhase
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxCalculationPhase) Ptr() *TaxCalculationPhase {
	return &t
}

// Identifiers for the location used by various governments for tax purposes.
type TaxIds struct {
	// The EU VAT number for this location. For example, `IE3426675K`.
	// If the EU VAT number is present, it is well-formed and has been
	// validated with VIES, the VAT Information Exchange System.
	EuVat *string `json:"eu_vat,omitempty" url:"eu_vat,omitempty"`
	// The SIRET (Système d'Identification du Répertoire des Entreprises et de leurs Etablissements)
	// number is a 14-digit code issued by the French INSEE. For example, `39922799000021`.
	FrSiret *string `json:"fr_siret,omitempty" url:"fr_siret,omitempty"`
	// The French government uses the NAF (Nomenclature des Activités Françaises) to display and
	// track economic statistical data. This is also called the APE (Activite Principale de l’Entreprise) code.
	// For example, `6910Z`.
	FrNaf *string `json:"fr_naf,omitempty" url:"fr_naf,omitempty"`
	// The NIF (Numero de Identificacion Fiscal) number is a nine-character tax identifier used in Spain.
	// If it is present, it has been validated. For example, `73628495A`.
	EsNif *string `json:"es_nif,omitempty" url:"es_nif,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TaxIds) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaxIds) UnmarshalJSON(data []byte) error {
	type unmarshaler TaxIds
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaxIds(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaxIds) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Whether to the tax amount should be additional to or included in the CatalogItem price.
type TaxInclusionType string

const (
	TaxInclusionTypeAdditive  TaxInclusionType = "ADDITIVE"
	TaxInclusionTypeInclusive TaxInclusionType = "INCLUSIVE"
)

func NewTaxInclusionTypeFromString(s string) (TaxInclusionType, error) {
	switch s {
	case "ADDITIVE":
		return TaxInclusionTypeAdditive, nil
	case "INCLUSIVE":
		return TaxInclusionTypeInclusive, nil
	}
	var t TaxInclusionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TaxInclusionType) Ptr() *TaxInclusionType {
	return &t
}

// Represents a generic time range. The start and end values are
// represented in RFC 3339 format. Time ranges are customized to be
// inclusive or exclusive based on the needs of a particular endpoint.
// Refer to the relevant endpoint-specific documentation to determine
// how time ranges are handled.
type TimeRange struct {
	// A datetime value in RFC 3339 format indicating when the time range
	// starts.
	StartAt *string `json:"start_at,omitempty" url:"start_at,omitempty"`
	// A datetime value in RFC 3339 format indicating when the time range
	// ends.
	EndAt *string `json:"end_at,omitempty" url:"end_at,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TimeRange) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeRange) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeRange(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeRange) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Defines the fields that are included in the response body of
// a request to the `UpdateCustomer` endpoint.
//
// Either `errors` or `customer` is present in a given response (never both).
type UpdateCustomerResponse struct {
	// Any errors that occurred during the request.
	Errors   []*Error  `json:"errors,omitempty" url:"errors,omitempty"`
	Customer *Customer `json:"customer,omitempty" url:"customer,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateCustomerResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateCustomerResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateCustomerResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateCustomerResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateCustomerResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the fields that are included in the response body of
// a request to the [UpdateOrder](api-endpoint:Orders-UpdateOrder) endpoint.
type UpdateOrderResponse struct {
	Order *Order `json:"order,omitempty" url:"order,omitempty"`
	// Any errors that occurred during the request.
	Errors []*Error `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdateOrderResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateOrderResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateOrderResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateOrderResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateOrderResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Defines the response returned by
// [UpdatePayment](api-endpoint:Payments-UpdatePayment).
type UpdatePaymentResponse struct {
	// Any errors that occurred during the request.
	Errors  []*Error `json:"errors,omitempty" url:"errors,omitempty"`
	Payment *Payment `json:"payment,omitempty" url:"payment,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (u *UpdatePaymentResponse) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdatePaymentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdatePaymentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdatePaymentResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties

	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdatePaymentResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
